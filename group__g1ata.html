<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KallistiOS: G1 ATA</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">KallistiOS<span id="projectnumber">&#160;##version##</span>
   </div>
   <div id="projectbrief">Independent SDK for the Sega Dreamcast</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__g1ata.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">G1 ATA<div class="ingroups"><a class="el" href="group__vfs.html">Filesystem</a> &raquo; <a class="el" href="group__vfs__drivers.html">Drivers</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Driver for Accessing an ATA device on the G1 Bus.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__ata__devices" id="r_group__ata__devices"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ata__devices.html">Device Definitions</a></td></tr>
<tr class="memdesc:group__ata__devices"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATA device definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:g1ata_8h" id="r_g1ata_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="g1ata_8h.html">g1ata.h</a></td></tr>
<tr class="memdesc:g1ata_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">G1 bus ATA interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga3dc455d7a6f219451ddba518a9ce8114" id="r_ga3dc455d7a6f219451ddba518a9ce8114"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#ga3dc455d7a6f219451ddba518a9ce8114">G1_ATA_MASTER</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:ga3dc455d7a6f219451ddba518a9ce8114"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATA master device.  <br /></td></tr>
<tr class="separator:ga3dc455d7a6f219451ddba518a9ce8114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga149da23b0353a4e53a622524c2139a0f" id="r_ga149da23b0353a4e53a622524c2139a0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#ga149da23b0353a4e53a622524c2139a0f">G1_ATA_MASTER_ALT</a>&#160;&#160;&#160;0x90</td></tr>
<tr class="memdesc:ga149da23b0353a4e53a622524c2139a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATA master device (compatible with old drives).  <br /></td></tr>
<tr class="separator:ga149da23b0353a4e53a622524c2139a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae8f19eb526271a0f0cf2884b2e4c0f6" id="r_gaae8f19eb526271a0f0cf2884b2e4c0f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#gaae8f19eb526271a0f0cf2884b2e4c0f6">G1_ATA_SLAVE</a>&#160;&#160;&#160;0xB0</td></tr>
<tr class="memdesc:gaae8f19eb526271a0f0cf2884b2e4c0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATA slave device.  <br /></td></tr>
<tr class="separator:gaae8f19eb526271a0f0cf2884b2e4c0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef5c019f3d6b409726956f00c1039c5d" id="r_gaef5c019f3d6b409726956f00c1039c5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#gaef5c019f3d6b409726956f00c1039c5d">G1_ATA_LBA_MODE</a>&#160;&#160;&#160;0x40</td></tr>
<tr class="memdesc:gaef5c019f3d6b409726956f00c1039c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select LBA addressing mode.  <br /></td></tr>
<tr class="separator:gaef5c019f3d6b409726956f00c1039c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga67ede571c7cde858b4c9cb3465168efc" id="r_ga67ede571c7cde858b4c9cb3465168efc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#ga67ede571c7cde858b4c9cb3465168efc">g1_dma_in_progress</a> (void)</td></tr>
<tr class="memdesc:ga67ede571c7cde858b4c9cb3465168efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is there a G1 DMA in progress currently?  <br /></td></tr>
<tr class="separator:ga67ede571c7cde858b4c9cb3465168efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf825be9217635fd35c3f6ca66584bf05" id="r_gaf825be9217635fd35c3f6ca66584bf05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#gaf825be9217635fd35c3f6ca66584bf05">g1_ata_mutex_lock</a> (void)</td></tr>
<tr class="memdesc:gaf825be9217635fd35c3f6ca66584bf05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the G1 ATA mutex.  <br /></td></tr>
<tr class="separator:gaf825be9217635fd35c3f6ca66584bf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9c78c55f6e6d56fd132392c96b8cd3" id="r_ga6c9c78c55f6e6d56fd132392c96b8cd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#ga6c9c78c55f6e6d56fd132392c96b8cd3">g1_ata_mutex_unlock</a> (void)</td></tr>
<tr class="memdesc:ga6c9c78c55f6e6d56fd132392c96b8cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the G1 ATA mutex.  <br /></td></tr>
<tr class="separator:ga6c9c78c55f6e6d56fd132392c96b8cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0137c3ac610f71d5734ec42b8900bbc" id="r_gab0137c3ac610f71d5734ec42b8900bbc"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#gab0137c3ac610f71d5734ec42b8900bbc">g1_ata_select_device</a> (uint8_t dev)</td></tr>
<tr class="memdesc:gab0137c3ac610f71d5734ec42b8900bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the active ATA device.  <br /></td></tr>
<tr class="separator:gab0137c3ac610f71d5734ec42b8900bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941fd09568265fcecfdf402c99d1615f" id="r_ga941fd09568265fcecfdf402c99d1615f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#ga941fd09568265fcecfdf402c99d1615f">g1_ata_read_chs</a> (uint16_t c, uint8_t h, uint8_t s, size_t count, void *buf)</td></tr>
<tr class="memdesc:ga941fd09568265fcecfdf402c99d1615f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one or more disk sectors with Cylinder-Head-Sector addressing.  <br /></td></tr>
<tr class="separator:ga941fd09568265fcecfdf402c99d1615f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd4c03e6620c3343dea0d7539a85393e" id="r_gafd4c03e6620c3343dea0d7539a85393e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#gafd4c03e6620c3343dea0d7539a85393e">g1_ata_write_chs</a> (uint16_t c, uint8_t h, uint8_t s, size_t count, const void *buf)</td></tr>
<tr class="memdesc:gafd4c03e6620c3343dea0d7539a85393e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write one or more disk sectors with Cylinder-Head-Sector addressing.  <br /></td></tr>
<tr class="separator:gafd4c03e6620c3343dea0d7539a85393e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf867d803272850203f8454ac9a4dc1cb" id="r_gaf867d803272850203f8454ac9a4dc1cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#gaf867d803272850203f8454ac9a4dc1cb">g1_ata_read_lba</a> (uint64_t sector, size_t count, void *buf)</td></tr>
<tr class="memdesc:gaf867d803272850203f8454ac9a4dc1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one or more disk sectors with Linear Block Addressing (LBA).  <br /></td></tr>
<tr class="separator:gaf867d803272850203f8454ac9a4dc1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga467cd59afd6cb2dd7e34ed3c44435f7c" id="r_ga467cd59afd6cb2dd7e34ed3c44435f7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#ga467cd59afd6cb2dd7e34ed3c44435f7c">g1_ata_read_lba_dma</a> (uint64_t sector, size_t count, void *buf, int block)</td></tr>
<tr class="memdesc:ga467cd59afd6cb2dd7e34ed3c44435f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA read disk sectors with Linear Block Addressing (LBA).  <br /></td></tr>
<tr class="separator:ga467cd59afd6cb2dd7e34ed3c44435f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51875b08c887f50edda02f45a557ba95" id="r_ga51875b08c887f50edda02f45a557ba95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#ga51875b08c887f50edda02f45a557ba95">g1_ata_write_lba</a> (uint64_t sector, size_t count, const void *buf)</td></tr>
<tr class="memdesc:ga51875b08c887f50edda02f45a557ba95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write one or more disk sectors with Linear Block Addressing (LBA).  <br /></td></tr>
<tr class="separator:ga51875b08c887f50edda02f45a557ba95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga748d6f450c50bcb8d8d5d1ac36660618" id="r_ga748d6f450c50bcb8d8d5d1ac36660618"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#ga748d6f450c50bcb8d8d5d1ac36660618">g1_ata_write_lba_dma</a> (uint64_t sector, size_t count, const void *buf, int block)</td></tr>
<tr class="memdesc:ga748d6f450c50bcb8d8d5d1ac36660618"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA Write disk sectors with Linear Block Addressing (LBA).  <br /></td></tr>
<tr class="separator:ga748d6f450c50bcb8d8d5d1ac36660618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga102506f22a28150ab96d78be54376dbe" id="r_ga102506f22a28150ab96d78be54376dbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#ga102506f22a28150ab96d78be54376dbe">g1_ata_flush</a> (void)</td></tr>
<tr class="memdesc:ga102506f22a28150ab96d78be54376dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the write cache on the attached disk.  <br /></td></tr>
<tr class="separator:ga102506f22a28150ab96d78be54376dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d5b0d0c0a66c9660a43256c571f9bca" id="r_ga1d5b0d0c0a66c9660a43256c571f9bca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#ga1d5b0d0c0a66c9660a43256c571f9bca">g1_ata_lba_mode</a> (void)</td></tr>
<tr class="memdesc:ga1d5b0d0c0a66c9660a43256c571f9bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get LBA mode of the attached disk.  <br /></td></tr>
<tr class="separator:ga1d5b0d0c0a66c9660a43256c571f9bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21a75e3407701721fa923b08459ca5b9" id="r_ga21a75e3407701721fa923b08459ca5b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#ga21a75e3407701721fa923b08459ca5b9">g1_ata_blockdev_for_partition</a> (int partition, int dma, <a class="el" href="structkos__blockdev__t.html">kos_blockdev_t</a> *rv, uint8_t *partition_type)</td></tr>
<tr class="memdesc:ga21a75e3407701721fa923b08459ca5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a block device for a given partition on the slave ATA device.  <br /></td></tr>
<tr class="separator:ga21a75e3407701721fa923b08459ca5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a083fefa816448a0520526742487c95" id="r_ga8a083fefa816448a0520526742487c95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#ga8a083fefa816448a0520526742487c95">g1_ata_blockdev_for_device</a> (int dma, <a class="el" href="structkos__blockdev__t.html">kos_blockdev_t</a> *rv)</td></tr>
<tr class="memdesc:ga8a083fefa816448a0520526742487c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a block device for the attached ATA device.  <br /></td></tr>
<tr class="separator:ga8a083fefa816448a0520526742487c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67c0f6bc5bfa659c3111876c1f1d500" id="r_gaf67c0f6bc5bfa659c3111876c1f1d500"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#gaf67c0f6bc5bfa659c3111876c1f1d500">g1_ata_init</a> (void)</td></tr>
<tr class="memdesc:gaf67c0f6bc5bfa659c3111876c1f1d500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize G1 ATA support.  <br /></td></tr>
<tr class="separator:gaf67c0f6bc5bfa659c3111876c1f1d500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3befbd5c8156aca64209e9b3c3eec2f7" id="r_ga3befbd5c8156aca64209e9b3c3eec2f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g1ata.html#ga3befbd5c8156aca64209e9b3c3eec2f7">g1_ata_shutdown</a> (void)</td></tr>
<tr class="memdesc:ga3befbd5c8156aca64209e9b3c3eec2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down G1 ATA support.  <br /></td></tr>
<tr class="separator:ga3befbd5c8156aca64209e9b3c3eec2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for Accessing an ATA device on the G1 Bus. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaef5c019f3d6b409726956f00c1039c5d" name="gaef5c019f3d6b409726956f00c1039c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef5c019f3d6b409726956f00c1039c5d">&#9670;&#160;</a></span>G1_ATA_LBA_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define G1_ATA_LBA_MODE&#160;&#160;&#160;0x40</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select LBA addressing mode. </p>
<p>OR this constant with one of the device constants (<a class="el" href="group__g1ata.html#ga3dc455d7a6f219451ddba518a9ce8114">G1_ATA_MASTER</a> or <a class="el" href="group__g1ata.html#gaae8f19eb526271a0f0cf2884b2e4c0f6">G1_ATA_SLAVE</a>) to select LBA addressing mode. The various g1_ata_* functions all do this as appropriate already, so you shouldn't have to worry about this one at all. This bit is irrelevant for packet devices. </p>

</div>
</div>
<a id="ga3dc455d7a6f219451ddba518a9ce8114" name="ga3dc455d7a6f219451ddba518a9ce8114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dc455d7a6f219451ddba518a9ce8114">&#9670;&#160;</a></span>G1_ATA_MASTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define G1_ATA_MASTER&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ATA master device. </p>
<p>This constant selects the master device on the ATA bus. This is normally the GD-ROM drive.</p>
<dl class="section note"><dt>Note</dt><dd>The GD-ROM really does not like the reserved bits being set in the device select register, hence why this constant doesn't select them. Some hard drives may require them, however. If you find one that does, then you should use the <a class="el" href="group__g1ata.html#ga149da23b0353a4e53a622524c2139a0f">G1_ATA_MASTER_ALT</a> constant to access it if it is the master device on the bus. </dd></dl>

</div>
</div>
<a id="ga149da23b0353a4e53a622524c2139a0f" name="ga149da23b0353a4e53a622524c2139a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga149da23b0353a4e53a622524c2139a0f">&#9670;&#160;</a></span>G1_ATA_MASTER_ALT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define G1_ATA_MASTER_ALT&#160;&#160;&#160;0x90</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ATA master device (compatible with old drives). </p>
<p>This constant selects the master device on the ATA bus, with the old reserved bits set to 1. If you have a drive that predates ATA-2, then this will probably be the constant you want to access it as the master device.</p>
<dl class="section note"><dt>Note</dt><dd>Do not use this constant to access the GD-ROM. It will not work. Use <a class="el" href="group__g1ata.html#ga3dc455d7a6f219451ddba518a9ce8114">G1_ATA_MASTER</a> instead. </dd></dl>

</div>
</div>
<a id="gaae8f19eb526271a0f0cf2884b2e4c0f6" name="gaae8f19eb526271a0f0cf2884b2e4c0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae8f19eb526271a0f0cf2884b2e4c0f6">&#9670;&#160;</a></span>G1_ATA_SLAVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define G1_ATA_SLAVE&#160;&#160;&#160;0xB0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ATA slave device. </p>
<p>This constant selects the slave device on the ATA bus. This is where you would find a hard drive, if the user has an adapter installed. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8a083fefa816448a0520526742487c95" name="ga8a083fefa816448a0520526742487c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a083fefa816448a0520526742487c95">&#9670;&#160;</a></span>g1_ata_blockdev_for_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int g1_ata_blockdev_for_device </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkos__blockdev__t.html">kos_blockdev_t</a> *&#160;</td>
          <td class="paramname"><em>rv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a block device for the attached ATA device. </p>
<p>This function creates a block device descriptor for the attached ATA device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dma</td><td>Set to 1 to use DMA for reads/writes on the device, if available. </td></tr>
    <tr><td class="paramname">rv</td><td>Used to return the block device. Must be non-NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>ENXIO</em> - ATA support not initialized or no device attached <br  />
<em>EFAULT</em> - rv was NULL <br  />
<em>ENOMEM</em> - out of memory </dd></dl>

</div>
</div>
<a id="ga21a75e3407701721fa923b08459ca5b9" name="ga21a75e3407701721fa923b08459ca5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21a75e3407701721fa923b08459ca5b9">&#9670;&#160;</a></span>g1_ata_blockdev_for_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int g1_ata_blockdev_for_partition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkos__blockdev__t.html">kos_blockdev_t</a> *&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>partition_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a block device for a given partition on the slave ATA device. </p>
<p>This function creates a block device descriptor for the given partition on the attached ATA device. This block device is used to interface with various filesystems on the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td>The partition number (0-3) to use. </td></tr>
    <tr><td class="paramname">dma</td><td>Set to 1 to use DMA for reads/writes on the device, if available. </td></tr>
    <tr><td class="paramname">rv</td><td>Used to return the block device. Must be non-NULL. </td></tr>
    <tr><td class="paramname">partition_type</td><td>Used to return the partition type. Must be non-NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>ENXIO</em> - ATA support not initialized or no device attached <br  />
<em>EIO</em> - an I/O error occurred in reading data <br  />
<em>EINVAL</em> - invalid partition number was given <br  />
<em>EFAULT</em> - rv or partition_type was NULL <br  />
<em>ENOENT</em> - no MBR found <br  />
<em>ENOENT</em> - no partition at the specified position <br  />
<em>ENOMEM</em> - out of memory</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This interface currently only supports MBR-formatted disks. There is currently no support for GPT partition tables. </dd></dl>

</div>
</div>
<a id="ga102506f22a28150ab96d78be54376dbe" name="ga102506f22a28150ab96d78be54376dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga102506f22a28150ab96d78be54376dbe">&#9670;&#160;</a></span>g1_ata_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int g1_ata_flush </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the write cache on the attached disk. </p>
<p>This function flushes the write cache on the disk attached as the slave device on the G1 ATA bus. This ensures that all writes that have previously completed are fully persisted to the disk. You should do this before unmounting any disks or exiting your program if you have called any of the write functions in here.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success. &lt;0 on error, setting errno as appropriate.</dd></dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>ENXIO</em> - ATA support not initialized or no device attached </dd></dl>

</div>
</div>
<a id="gaf67c0f6bc5bfa659c3111876c1f1d500" name="gaf67c0f6bc5bfa659c3111876c1f1d500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf67c0f6bc5bfa659c3111876c1f1d500">&#9670;&#160;</a></span>g1_ata_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int g1_ata_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize G1 ATA support. </p>
<p>This function initializes the rest of this subsystem and completes a scan of the G1 ATA bus for devices. This function may take a while to complete with some devices. Currently only the slave device is scanned, as the master device should always be the GD-ROM drive.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0 on error or if no device is present </dd></dl>

</div>
</div>
<a id="ga1d5b0d0c0a66c9660a43256c571f9bca" name="ga1d5b0d0c0a66c9660a43256c571f9bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d5b0d0c0a66c9660a43256c571f9bca">&#9670;&#160;</a></span>g1_ata_lba_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int g1_ata_lba_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get LBA mode of the attached disk. </p>
<dl class="section return"><dt>Returns</dt><dd>-1 on error, 0 - CHS, 28 - LBA28, 48 - LBA48</dd></dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>ENXIO</em> - ATA support not initialized or no device attached </dd></dl>

</div>
</div>
<a id="gaf825be9217635fd35c3f6ca66584bf05" name="gaf825be9217635fd35c3f6ca66584bf05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf825be9217635fd35c3f6ca66584bf05">&#9670;&#160;</a></span>g1_ata_mutex_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int g1_ata_mutex_lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the G1 ATA mutex. </p>
<p>This function locks the mutex that arbitrates access to the ATA bus. You should never have to do this on your own unless you're accessing devices manually yourself.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Failure conditions are exactly the same as the <a class="el" href="mutex_8h.html#a6d52957b6bb80a33988222ba146a4faf">mutex_lock()</a> function. </dd></dl>

</div>
</div>
<a id="ga6c9c78c55f6e6d56fd132392c96b8cd3" name="ga6c9c78c55f6e6d56fd132392c96b8cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c9c78c55f6e6d56fd132392c96b8cd3">&#9670;&#160;</a></span>g1_ata_mutex_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int g1_ata_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the G1 ATA mutex. </p>
<p>This function unlocks the mutex that arbitrates access to the ATA bus. You should never have to do this on your own unless you're accessing devices manually yourself.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Failure conditions are exactly the same as the <a class="el" href="mutex_8h.html#aa2205ebb532937430c2576ca61f62ddf">mutex_unlock()</a> function. </dd></dl>

</div>
</div>
<a id="ga941fd09568265fcecfdf402c99d1615f" name="ga941fd09568265fcecfdf402c99d1615f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga941fd09568265fcecfdf402c99d1615f">&#9670;&#160;</a></span>g1_ata_read_chs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int g1_ata_read_chs </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one or more disk sectors with Cylinder-Head-Sector addressing. </p>
<p>This function reads one or more 512-byte disk blocks from the slave device on the G1 ATA bus using Cylinder-Head-Sector addressing. This function uses PIO and blocks until the data is read in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The cylinder to start reading from. </td></tr>
    <tr><td class="paramname">h</td><td>The head to start reading from. </td></tr>
    <tr><td class="paramname">s</td><td>The sector to start reading from. </td></tr>
    <tr><td class="paramname">count</td><td>The number of disk sectors to read. </td></tr>
    <tr><td class="paramname">buf</td><td>Storage for the read-in disk sectors. This should be at least (count * 512) bytes in length, and must be at least 16-bit aligned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. &lt; 0 on failure, setting errno as appropriate.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unless you're accessing a really old hard drive, you probably do not want to use this function to access the disk. Use the <a class="el" href="group__g1ata.html#gaf867d803272850203f8454ac9a4dc1cb" title="Read one or more disk sectors with Linear Block Addressing (LBA).">g1_ata_read_lba()</a> function instead of this one, unless you get an error from that function indicating that LBA addressing is not supported.</dd></dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EIO</em> - an I/O error occurred in reading data <br  />
<em>ENXIO</em> - ATA support not initialized or no device attached <br  />
<em>EOVERFLOW</em> - one or more of the requested sectors is out of the range of the disk </dd></dl>

</div>
</div>
<a id="gaf867d803272850203f8454ac9a4dc1cb" name="gaf867d803272850203f8454ac9a4dc1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf867d803272850203f8454ac9a4dc1cb">&#9670;&#160;</a></span>g1_ata_read_lba()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int g1_ata_read_lba </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>sector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one or more disk sectors with Linear Block Addressing (LBA). </p>
<p>This function reads one or more 512-byte disk blocks from the slave device on the G1 ATA bus using LBA mode (either 28 or 48 bits, as appropriate). This function uses PIO and blocks until the data is read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sector</td><td>The sector to start reading from. </td></tr>
    <tr><td class="paramname">count</td><td>The number of disk sectors to read. </td></tr>
    <tr><td class="paramname">buf</td><td>Storage for the read-in disk sectors. This should be at least (count * 512) bytes in length, and must be at least 16-bit aligned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. &lt; 0 on failure, setting errno as appropriate.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If errno is set to ENOTSUP after calling this function, you must use the <a class="el" href="group__g1ata.html#ga941fd09568265fcecfdf402c99d1615f" title="Read one or more disk sectors with Cylinder-Head-Sector addressing.">g1_ata_read_chs()</a> function instead.</dd></dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EIO</em> - an I/O error occurred in reading data <br  />
<em>ENXIO</em> - ATA support not initialized or no device attached <br  />
<em>EOVERFLOW</em> - one or more of the requested sectors is out of the range of the disk <br  />
<em>ENOTSUP</em> - LBA mode not supported by the device </dd></dl>

</div>
</div>
<a id="ga467cd59afd6cb2dd7e34ed3c44435f7c" name="ga467cd59afd6cb2dd7e34ed3c44435f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga467cd59afd6cb2dd7e34ed3c44435f7c">&#9670;&#160;</a></span>g1_ata_read_lba_dma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int g1_ata_read_lba_dma </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>sector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DMA read disk sectors with Linear Block Addressing (LBA). </p>
<p>This function reads one or more 512-byte disk blocks from the slave device on the G1 ATA bus using LBA mode (either 28 or 48 bits, as appropriate). This function uses DMA and optionally blocks until the data is read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sector</td><td>The sector to start reading from. </td></tr>
    <tr><td class="paramname">count</td><td>The number of disk sectors to read. </td></tr>
    <tr><td class="paramname">buf</td><td>Storage for the read-in disk sectors. This should be at least (count * 512) bytes in length, and must be at least 32-byte aligned. </td></tr>
    <tr><td class="paramname">block</td><td>Non-zero to block until the transfer completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. &lt; 0 on failure, setting errno as appropriate.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If errno is set to ENOTSUP after calling this function, you must use a CHS addressed transfer function instead, like <a class="el" href="group__g1ata.html#ga941fd09568265fcecfdf402c99d1615f" title="Read one or more disk sectors with Cylinder-Head-Sector addressing.">g1_ata_read_chs()</a>.</dd>
<dd>
If errno is set to EPERM after calling this function, DMA mode is not supported. You should use a PIO transfer function like <a class="el" href="group__g1ata.html#gaf867d803272850203f8454ac9a4dc1cb" title="Read one or more disk sectors with Linear Block Addressing (LBA).">g1_ata_read_lba()</a> instead.</dd></dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EIO</em> - an I/O error occurred in reading data <br  />
<em>ENXIO</em> - ATA support not initialized or no device attached <br  />
<em>EOVERFLOW</em> - one or more of the requested sectors is out of the range of the disk <br  />
<em>ENOTSUP</em> - LBA mode not supported by the device <br  />
<em>EPERM</em> - device does not support DMA </dd></dl>

</div>
</div>
<a id="gab0137c3ac610f71d5734ec42b8900bbc" name="gab0137c3ac610f71d5734ec42b8900bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0137c3ac610f71d5734ec42b8900bbc">&#9670;&#160;</a></span>g1_ata_select_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t g1_ata_select_device </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the active ATA device. </p>
<p>This function sets the device that any further ATA commands will go to. You shouldn't have to ever call this yourself, as it should be done for you by any of the access functions. This must be called with the ATA lock held.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to access (generally either <a class="el" href="group__g1ata.html#ga3dc455d7a6f219451ddba518a9ce8114">G1_ATA_MASTER</a> or <a class="el" href="group__g1ata.html#gaae8f19eb526271a0f0cf2884b2e4c0f6">G1_ATA_SLAVE</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous active device (or 0x0F if the function would block in an IRQ handler).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function may block if there is a transfer ongoing. If called in an IRQ handler and the call would otherwise block, 0x0F is returned. </dd></dl>

</div>
</div>
<a id="ga3befbd5c8156aca64209e9b3c3eec2f7" name="ga3befbd5c8156aca64209e9b3c3eec2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3befbd5c8156aca64209e9b3c3eec2f7">&#9670;&#160;</a></span>g1_ata_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void g1_ata_shutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shut down G1 ATA support. </p>
<p>This function shuts down the rest of this subsystem, and attempts to flush the write cache of any attached slave devices. Accessing any ATA devices using this subsystem after this function is called may produce undefined results. </p>

</div>
</div>
<a id="gafd4c03e6620c3343dea0d7539a85393e" name="gafd4c03e6620c3343dea0d7539a85393e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd4c03e6620c3343dea0d7539a85393e">&#9670;&#160;</a></span>g1_ata_write_chs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int g1_ata_write_chs </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write one or more disk sectors with Cylinder-Head-Sector addressing. </p>
<p>This function writes one or more 512-byte disk blocks to the slave device on the G1 ATA bus using Cylinder-Head-Sector addressing. This function uses PIO and blocks until the data is written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The cylinder to start writing to. </td></tr>
    <tr><td class="paramname">h</td><td>The head to start writing to. </td></tr>
    <tr><td class="paramname">s</td><td>The sector to start writing to. </td></tr>
    <tr><td class="paramname">count</td><td>The number of disk sectors to write. </td></tr>
    <tr><td class="paramname">buf</td><td>The data to write to the disk. This should be (count * 512) bytes in length and must be at least 16-bit aligned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. &lt; 0 on failure, setting errno as appropriate.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unless you're accessing a really old hard drive, you probably do not want to use this function to access the disk. Use the <a class="el" href="group__g1ata.html#ga51875b08c887f50edda02f45a557ba95" title="Write one or more disk sectors with Linear Block Addressing (LBA).">g1_ata_write_lba()</a> function instead of this one, unless you get an error from that function indicating that LBA addressing is not supported.</dd></dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>ENXIO</em> - ATA support not initialized or no device attached <br  />
<em>EOVERFLOW</em> - one or more of the requested sectors is out of the range of the disk </dd></dl>

</div>
</div>
<a id="ga51875b08c887f50edda02f45a557ba95" name="ga51875b08c887f50edda02f45a557ba95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51875b08c887f50edda02f45a557ba95">&#9670;&#160;</a></span>g1_ata_write_lba()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int g1_ata_write_lba </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>sector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write one or more disk sectors with Linear Block Addressing (LBA). </p>
<p>This function writes one or more 512-byte disk blocks to the slave device on the G1 ATA bus using LBA mode (either 28 or 48 bits, as appropriate). This function uses PIO and blocks until the data is written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sector</td><td>The sector to start writing to. </td></tr>
    <tr><td class="paramname">count</td><td>The number of disk sectors to write. </td></tr>
    <tr><td class="paramname">buf</td><td>The data to write to the disk. This should be (count * 512) bytes in length and must be at least 16-bit aligned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. &lt; 0 on failure, setting errno as appropriate.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If errno is set to ENOTSUP after calling this function, you must use the <a class="el" href="group__g1ata.html#gafd4c03e6620c3343dea0d7539a85393e" title="Write one or more disk sectors with Cylinder-Head-Sector addressing.">g1_ata_write_chs()</a> function instead.</dd></dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>ENXIO</em> - ATA support not initialized or no device attached <br  />
<em>EOVERFLOW</em> - one or more of the requested sectors is out of the range of the disk <br  />
<em>ENOTSUP</em> - LBA mode not supported by the device </dd></dl>

</div>
</div>
<a id="ga748d6f450c50bcb8d8d5d1ac36660618" name="ga748d6f450c50bcb8d8d5d1ac36660618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga748d6f450c50bcb8d8d5d1ac36660618">&#9670;&#160;</a></span>g1_ata_write_lba_dma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int g1_ata_write_lba_dma </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>sector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DMA Write disk sectors with Linear Block Addressing (LBA). </p>
<p>This function writes one or more 512-byte disk blocks to the slave device on the G1 ATA bus using LBA mode (either 28 or 48 bits, as appropriate). This function uses DMA and optionally blocks until the data is written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sector</td><td>The sector to start writing to. </td></tr>
    <tr><td class="paramname">count</td><td>The number of disk sectors to write. </td></tr>
    <tr><td class="paramname">buf</td><td>The data to write to the disk. This should be (count * 512) bytes in length and must be at least 32-byte aligned. </td></tr>
    <tr><td class="paramname">block</td><td>Non-zero to block until the transfer completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. &lt; 0 on failure, setting errno as appropriate.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If errno is set to ENOTSUP after calling this function, you must use the <a class="el" href="group__g1ata.html#gafd4c03e6620c3343dea0d7539a85393e" title="Write one or more disk sectors with Cylinder-Head-Sector addressing.">g1_ata_write_chs()</a> function instead.</dd>
<dd>
If errno is set to EPERM after calling this function, DMA mode is not supported. You should use a PIO transfer function like <a class="el" href="group__g1ata.html#ga51875b08c887f50edda02f45a557ba95" title="Write one or more disk sectors with Linear Block Addressing (LBA).">g1_ata_write_lba()</a> instead.</dd></dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>ENXIO</em> - ATA support not initialized or no device attached <br  />
<em>EOVERFLOW</em> - one or more of the requested sectors is out of the range of the disk <br  />
<em>ENOTSUP</em> - LBA mode not supported by the device <br  />
<em>EPERM</em> - device does not support DMA </dd></dl>

</div>
</div>
<a id="ga67ede571c7cde858b4c9cb3465168efc" name="ga67ede571c7cde858b4c9cb3465168efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67ede571c7cde858b4c9cb3465168efc">&#9670;&#160;</a></span>g1_dma_in_progress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int g1_dma_in_progress </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is there a G1 DMA in progress currently? </p>
<p>This function returns non-zero if a DMA is in progress. This can be used to check on the completion of DMA transfers when non-blocking mode was selected at transfer time.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if no DMA is in progress, nonzero otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
