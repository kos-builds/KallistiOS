<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KallistiOS: include/kos/mutex.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">KallistiOS<span id="projectnumber">&#160;##version##</span>
   </div>
   <div id="projectbrief">Independent SDK for the Sega Dreamcast</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('mutex_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mutex.h File Reference<div class="ingroups"><a class="el" href="group__threading.html">Threading</a> &raquo; <a class="el" href="group__kthreads.html">Kernel</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Mutual exclusion locks.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="cdefs_8h_source.html">kos/cdefs.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="thread_8h_source.html">kos/thread.h</a>&gt;</code><br />
</div>
<p><a href="mutex_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutex__t.html">mutex_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutual exclusion lock type.  <a href="structmutex__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a10ba6c8c4a5e2bcf9f5f5fd41675e122" id="r_a10ba6c8c4a5e2bcf9f5f5fd41675e122"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html#a10ba6c8c4a5e2bcf9f5f5fd41675e122">MUTEX_INITIALIZER</a>&#160;&#160;&#160;{ <a class="el" href="mutex_8h.html#af3e937b10010ee796438a34e952deabc">MUTEX_TYPE_NORMAL</a>, 0, NULL, 0 }</td></tr>
<tr class="memdesc:a10ba6c8c4a5e2bcf9f5f5fd41675e122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for a transient mutex.  <br /></td></tr>
<tr class="separator:a10ba6c8c4a5e2bcf9f5f5fd41675e122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476311eac2b4e19d4f4e8787ece4fdac" id="r_a476311eac2b4e19d4f4e8787ece4fdac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html#a476311eac2b4e19d4f4e8787ece4fdac">ERRORCHECK_MUTEX_INITIALIZER</a>&#160;&#160;&#160;{ <a class="el" href="mutex_8h.html#a6827e82217edbcae3dd5e0a0bd148d21">MUTEX_TYPE_ERRORCHECK</a>, 0, NULL, 0 }</td></tr>
<tr class="memdesc:a476311eac2b4e19d4f4e8787ece4fdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for a transient error-checking mutex.  <br /></td></tr>
<tr class="separator:a476311eac2b4e19d4f4e8787ece4fdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61b0138de93e2154cfec0bd06f0674f" id="r_af61b0138de93e2154cfec0bd06f0674f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html#af61b0138de93e2154cfec0bd06f0674f">RECURSIVE_MUTEX_INITIALIZER</a>&#160;&#160;&#160;{ <a class="el" href="mutex_8h.html#aa5ed66e571a9798291a39fef1e52554c">MUTEX_TYPE_RECURSIVE</a>, 0, NULL, 0 }</td></tr>
<tr class="memdesc:af61b0138de93e2154cfec0bd06f0674f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for a transient recursive mutex.  <br /></td></tr>
<tr class="separator:af61b0138de93e2154cfec0bd06f0674f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mutex types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Types of Mutexes supported by KOS</p>
<p>The values defined in here are the various types of mutexes that KallistiOS supports. </p>
</div></td></tr>
<tr class="memitem:af3e937b10010ee796438a34e952deabc" id="r_af3e937b10010ee796438a34e952deabc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html#af3e937b10010ee796438a34e952deabc">MUTEX_TYPE_NORMAL</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:af3e937b10010ee796438a34e952deabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal mutex type.  <br /></td></tr>
<tr class="separator:af3e937b10010ee796438a34e952deabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1672a919084c44796af20a3e901f2c72" id="r_a1672a919084c44796af20a3e901f2c72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html#a1672a919084c44796af20a3e901f2c72">MUTEX_TYPE_OLDNORMAL</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a1672a919084c44796af20a3e901f2c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for MUTEX_TYPE_NORMAL.  <br /></td></tr>
<tr class="separator:a1672a919084c44796af20a3e901f2c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6827e82217edbcae3dd5e0a0bd148d21" id="r_a6827e82217edbcae3dd5e0a0bd148d21"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html#a6827e82217edbcae3dd5e0a0bd148d21">MUTEX_TYPE_ERRORCHECK</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a6827e82217edbcae3dd5e0a0bd148d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error-checking mutex type.  <br /></td></tr>
<tr class="separator:a6827e82217edbcae3dd5e0a0bd148d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ed66e571a9798291a39fef1e52554c" id="r_aa5ed66e571a9798291a39fef1e52554c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html#aa5ed66e571a9798291a39fef1e52554c">MUTEX_TYPE_RECURSIVE</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:aa5ed66e571a9798291a39fef1e52554c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive mutex type.  <br /></td></tr>
<tr class="separator:aa5ed66e571a9798291a39fef1e52554c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f34b72699f1133d557221857841e748" id="r_a1f34b72699f1133d557221857841e748"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html#a1f34b72699f1133d557221857841e748">MUTEX_TYPE_DEFAULT</a>&#160;&#160;&#160;<a class="el" href="mutex_8h.html#af3e937b10010ee796438a34e952deabc">MUTEX_TYPE_NORMAL</a></td></tr>
<tr class="memdesc:a1f34b72699f1133d557221857841e748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default mutex type.  <br /></td></tr>
<tr class="separator:a1f34b72699f1133d557221857841e748"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a734bb84ae02ae0f4570ca5ee990a6763" id="r_a734bb84ae02ae0f4570ca5ee990a6763"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html#a734bb84ae02ae0f4570ca5ee990a6763">mutex_create</a> (void) <a class="el" href="group__system__macros.html#ga392e91d0f8a0af994874aadeed30534d">__depr</a>(&quot;Use <a class="el" href="mutex_8h.html#a97641c93da9e9fdac2f2ba8900214ced">mutex_init</a> or an initializer.&quot;)</td></tr>
<tr class="memdesc:a734bb84ae02ae0f4570ca5ee990a6763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new mutex.  <br /></td></tr>
<tr class="separator:a734bb84ae02ae0f4570ca5ee990a6763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97641c93da9e9fdac2f2ba8900214ced" id="r_a97641c93da9e9fdac2f2ba8900214ced"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html#a97641c93da9e9fdac2f2ba8900214ced">mutex_init</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m, int mtype)</td></tr>
<tr class="memdesc:a97641c93da9e9fdac2f2ba8900214ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new mutex.  <br /></td></tr>
<tr class="separator:a97641c93da9e9fdac2f2ba8900214ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1aaf1b06327156001d9dbf48712b82a" id="r_ab1aaf1b06327156001d9dbf48712b82a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html#ab1aaf1b06327156001d9dbf48712b82a">mutex_destroy</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m)</td></tr>
<tr class="memdesc:ab1aaf1b06327156001d9dbf48712b82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a mutex.  <br /></td></tr>
<tr class="separator:ab1aaf1b06327156001d9dbf48712b82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d52957b6bb80a33988222ba146a4faf" id="r_a6d52957b6bb80a33988222ba146a4faf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html#a6d52957b6bb80a33988222ba146a4faf">mutex_lock</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m)</td></tr>
<tr class="memdesc:a6d52957b6bb80a33988222ba146a4faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a mutex.  <br /></td></tr>
<tr class="separator:a6d52957b6bb80a33988222ba146a4faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8260339f6c2847b95974ab628aced2" id="r_abb8260339f6c2847b95974ab628aced2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html#abb8260339f6c2847b95974ab628aced2">mutex_lock_timed</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m, int timeout)</td></tr>
<tr class="memdesc:abb8260339f6c2847b95974ab628aced2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a mutex (with a timeout).  <br /></td></tr>
<tr class="separator:abb8260339f6c2847b95974ab628aced2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393e3f1e5beeec8f9755b817871cc384" id="r_a393e3f1e5beeec8f9755b817871cc384"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html#a393e3f1e5beeec8f9755b817871cc384">mutex_is_locked</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m)</td></tr>
<tr class="memdesc:a393e3f1e5beeec8f9755b817871cc384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a mutex is locked.  <br /></td></tr>
<tr class="separator:a393e3f1e5beeec8f9755b817871cc384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df89d04ae48ba3be8e15edf845dbe4c" id="r_a6df89d04ae48ba3be8e15edf845dbe4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html#a6df89d04ae48ba3be8e15edf845dbe4c">mutex_trylock</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m)</td></tr>
<tr class="memdesc:a6df89d04ae48ba3be8e15edf845dbe4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to lock a mutex.  <br /></td></tr>
<tr class="separator:a6df89d04ae48ba3be8e15edf845dbe4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2205ebb532937430c2576ca61f62ddf" id="r_aa2205ebb532937430c2576ca61f62ddf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html#aa2205ebb532937430c2576ca61f62ddf">mutex_unlock</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m)</td></tr>
<tr class="memdesc:aa2205ebb532937430c2576ca61f62ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a mutex.  <br /></td></tr>
<tr class="separator:aa2205ebb532937430c2576ca61f62ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f687859cfc8f7a9dcbff7a7eedbcf81" id="r_a8f687859cfc8f7a9dcbff7a7eedbcf81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html#a8f687859cfc8f7a9dcbff7a7eedbcf81">mutex_unlock_as_thread</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m, <a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:a8f687859cfc8f7a9dcbff7a7eedbcf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a mutex under another thread's authority.  <br /></td></tr>
<tr class="separator:a8f687859cfc8f7a9dcbff7a7eedbcf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Mutual exclusion locks. </p>
<p>This file defines mutual exclusion locks (or mutexes for short). The concept of a mutex is one of the most common types of locks in a multi-threaded environment. Mutexes do exactly what they sound like, they keep two (or more) threads mutually exclusive from one another. A mutex is used around a block of code to prevent two threads from interfering with one another when only one would be appropriate to be in the block at a time.</p>
<p>KallistiOS implements 3 types of mutexes, to bring it roughly in-line with POSIX. The types of mutexes that can be made are normal, error-checking, and recursive. Each has its own strengths and weaknesses, which are briefly discussed below.</p>
<p>A normal mutex (MUTEX_TYPE_NORMAL) is the fastest and simplest mutex of the bunch. This is roughly equivalent to a semaphore that has been initialized with a count of 1. There is no protection against threads unlocking normal mutexes they didn't lock, nor is there any protection against deadlocks that would arise from locking the mutex twice.</p>
<p>An error-checking mutex (MUTEX_TYPE_ERRORCHECK) adds a small amount of error checking on top of a normal mutex. This type will not allow you to lock the mutex twice (it will return an error if the same thread tries to lock it two times so it will not deadlock), and it will not allow a different thread to unlock the mutex if it isn't the one holding the lock.</p>
<p>A recursive mutex (MUTEX_TYPE_RECURSIVE) extends the error checking mutex by allowing you to lock the mutex twice in the same thread, but you must also unlock it twice (this works for any number of locks &ndash; lock it n times, you must unlock it n times). Still only one thread can hold the lock, but it may hold it as many times as it needs to. This is equivalent to the recursive_lock_t type that was available in KallistiOS for a while (before it was basically merged back into a normal mutex).</p>
<p>There is a fourth type of mutex defined (MUTEX_TYPE_DEFAULT), which maps to the MUTEX_TYPE_NORMAL type. This is simply for alignment with POSIX.</p>
<dl class="section author"><dt>Author</dt><dd>Lawrence Sebald </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="sem_8h.html" title="Semaphores.">kos/sem.h</a> </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a476311eac2b4e19d4f4e8787ece4fdac" name="a476311eac2b4e19d4f4e8787ece4fdac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476311eac2b4e19d4f4e8787ece4fdac">&#9670;&#160;</a></span>ERRORCHECK_MUTEX_INITIALIZER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERRORCHECK_MUTEX_INITIALIZER&#160;&#160;&#160;{ <a class="el" href="mutex_8h.html#a6827e82217edbcae3dd5e0a0bd148d21">MUTEX_TYPE_ERRORCHECK</a>, 0, NULL, 0 }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for a transient error-checking mutex. </p>

</div>
</div>
<a id="a10ba6c8c4a5e2bcf9f5f5fd41675e122" name="a10ba6c8c4a5e2bcf9f5f5fd41675e122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ba6c8c4a5e2bcf9f5f5fd41675e122">&#9670;&#160;</a></span>MUTEX_INITIALIZER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MUTEX_INITIALIZER&#160;&#160;&#160;{ <a class="el" href="mutex_8h.html#af3e937b10010ee796438a34e952deabc">MUTEX_TYPE_NORMAL</a>, 0, NULL, 0 }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for a transient mutex. </p>

</div>
</div>
<a id="a1f34b72699f1133d557221857841e748" name="a1f34b72699f1133d557221857841e748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f34b72699f1133d557221857841e748">&#9670;&#160;</a></span>MUTEX_TYPE_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MUTEX_TYPE_DEFAULT&#160;&#160;&#160;<a class="el" href="mutex_8h.html#af3e937b10010ee796438a34e952deabc">MUTEX_TYPE_NORMAL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default mutex type. </p>

</div>
</div>
<a id="a6827e82217edbcae3dd5e0a0bd148d21" name="a6827e82217edbcae3dd5e0a0bd148d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6827e82217edbcae3dd5e0a0bd148d21">&#9670;&#160;</a></span>MUTEX_TYPE_ERRORCHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MUTEX_TYPE_ERRORCHECK&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error-checking mutex type. </p>

</div>
</div>
<a id="af3e937b10010ee796438a34e952deabc" name="af3e937b10010ee796438a34e952deabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e937b10010ee796438a34e952deabc">&#9670;&#160;</a></span>MUTEX_TYPE_NORMAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MUTEX_TYPE_NORMAL&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normal mutex type. </p>

</div>
</div>
<a id="a1672a919084c44796af20a3e901f2c72" name="a1672a919084c44796af20a3e901f2c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1672a919084c44796af20a3e901f2c72">&#9670;&#160;</a></span>MUTEX_TYPE_OLDNORMAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MUTEX_TYPE_OLDNORMAL&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for MUTEX_TYPE_NORMAL. </p>

</div>
</div>
<a id="aa5ed66e571a9798291a39fef1e52554c" name="aa5ed66e571a9798291a39fef1e52554c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ed66e571a9798291a39fef1e52554c">&#9670;&#160;</a></span>MUTEX_TYPE_RECURSIVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MUTEX_TYPE_RECURSIVE&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursive mutex type. </p>

</div>
</div>
<a id="af61b0138de93e2154cfec0bd06f0674f" name="af61b0138de93e2154cfec0bd06f0674f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61b0138de93e2154cfec0bd06f0674f">&#9670;&#160;</a></span>RECURSIVE_MUTEX_INITIALIZER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RECURSIVE_MUTEX_INITIALIZER&#160;&#160;&#160;{ <a class="el" href="mutex_8h.html#aa5ed66e571a9798291a39fef1e52554c">MUTEX_TYPE_RECURSIVE</a>, 0, NULL, 0 }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for a transient recursive mutex. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a734bb84ae02ae0f4570ca5ee990a6763" name="a734bb84ae02ae0f4570ca5ee990a6763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734bb84ae02ae0f4570ca5ee990a6763">&#9670;&#160;</a></span>mutex_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmutex__t.html">mutex_t</a> * mutex_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new mutex. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>This function allocates and initializes a new mutex for use. This function will always create mutexes of the type MUTEX_TYPE_NORMAL.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created mutex on success, or NULL on failure (errno will be set as appropriate).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is formally deprecated. It should not be used in any future code, and may be removed in the future. You should instead use <a class="el" href="mutex_8h.html#a97641c93da9e9fdac2f2ba8900214ced" title="Initialize a new mutex.">mutex_init()</a>. </dd></dl>

</div>
</div>
<a id="ab1aaf1b06327156001d9dbf48712b82a" name="ab1aaf1b06327156001d9dbf48712b82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1aaf1b06327156001d9dbf48712b82a">&#9670;&#160;</a></span>mutex_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mutex_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a mutex. </p>
<p>This function destroys a mutex, releasing any memory that may have been allocated internally for it. It is your responsibility to make sure that all threads waiting on the mutex are taken care of before destroying the mutex.</p>
<p>This function can be called on statically initialized as well as dynamically initialized mutexes.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EBUSY</em> - the mutex is currently locked </dd></dl>

</div>
</div>
<a id="a97641c93da9e9fdac2f2ba8900214ced" name="a97641c93da9e9fdac2f2ba8900214ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97641c93da9e9fdac2f2ba8900214ced">&#9670;&#160;</a></span>mutex_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mutex_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new mutex. </p>
<p>This function initializes a new mutex for use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mutex to initialize </td></tr>
    <tr><td class="paramname">mtype</td><td>The type of the mutex to initialize it to</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EINVAL</em> - an invalid type of mutex was specified</dd></dl>
<dl class="section see"><dt>See also</dt><dd>mutex_types </dd></dl>

</div>
</div>
<a id="a393e3f1e5beeec8f9755b817871cc384" name="a393e3f1e5beeec8f9755b817871cc384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393e3f1e5beeec8f9755b817871cc384">&#9670;&#160;</a></span>mutex_is_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mutex_is_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a mutex is locked. </p>
<p>This function will check whether or not a mutex is currently locked. This is not a thread-safe way to determine if the mutex will be locked by the time you get around to doing it. If you wish to attempt to lock a mutex without blocking, look at <a class="el" href="mutex_8h.html#a6df89d04ae48ba3be8e15edf845dbe4c" title="Attempt to lock a mutex.">mutex_trylock()</a>, not this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mutex to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If the mutex is not currently locked </td></tr>
    <tr><td class="paramname">1</td><td>If the mutex is currently locked </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d52957b6bb80a33988222ba146a4faf" name="a6d52957b6bb80a33988222ba146a4faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d52957b6bb80a33988222ba146a4faf">&#9670;&#160;</a></span>mutex_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mutex_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a mutex. </p>
<p>This function will lock a mutex, if it is not already locked by another thread. If it is locked by another thread already, this function will block until the mutex has been acquired for the calling thread.</p>
<p>The semantics of this function depend on the type of mutex that is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mutex to acquire </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success </td></tr>
    <tr><td class="paramname">-1</td><td>On error, sets errno as appropriate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EPERM</em> - called inside an interrupt <br  />
<em>EINVAL</em> - the mutex has not been initialized properly <br  />
<em>EAGAIN</em> - lock has been acquired too many times (recursive) <br  />
<em>EDEADLK</em> - would deadlock (error-checking) </dd></dl>

</div>
</div>
<a id="abb8260339f6c2847b95974ab628aced2" name="abb8260339f6c2847b95974ab628aced2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8260339f6c2847b95974ab628aced2">&#9670;&#160;</a></span>mutex_lock_timed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mutex_lock_timed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a mutex (with a timeout). </p>
<p>This function will attempt to lock a mutex. If the lock can be acquired immediately, the function will return immediately. If not, the function will block for up to the specified number of milliseconds to wait for the lock. If the lock cannot be acquired in this timeframe, this function will return an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mutex to acquire </td></tr>
    <tr><td class="paramname">timeout</td><td>The number of milliseconds to wait for the lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EPERM</em> - called inside an interrupt <br  />
<em>EINVAL</em> - the mutex has not been initialized properly <br  />
<em>EINVAL</em> - the timeout value was invalid (less than 0) <br  />
<em>ETIMEDOUT</em> - the timeout expired <br  />
<em>EAGAIN</em> - lock has been acquired too many times (recursive) <br  />
<em>EDEADLK</em> - would deadlock (error-checking) </dd></dl>

</div>
</div>
<a id="a6df89d04ae48ba3be8e15edf845dbe4c" name="a6df89d04ae48ba3be8e15edf845dbe4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df89d04ae48ba3be8e15edf845dbe4c">&#9670;&#160;</a></span>mutex_trylock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mutex_trylock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to lock a mutex. </p>
<p>This function will attempt to acquire the mutex for the calling thread, returning immediately whether or not it could be acquired. If the mutex cannot be acquired, an error will be returned.</p>
<p>This function is safe to call inside an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mutex to attempt to acquire </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On successfully acquiring the mutex </td></tr>
    <tr><td class="paramname">-1</td><td>If the mutex cannot be acquired without blocking</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EAGAIN</em> - the mutex is already locked (<a class="el" href="mutex_8h.html#a6d52957b6bb80a33988222ba146a4faf" title="Lock a mutex.">mutex_lock()</a> would block) <br  />
<em>EINVAL</em> - the mutex has not been initialized properly <br  />
<em>EAGAIN</em> - lock has been acquired too many times (recursive) <br  />
<em>EDEADLK</em> - would deadlock (error-checking) </dd></dl>

</div>
</div>
<a id="aa2205ebb532937430c2576ca61f62ddf" name="aa2205ebb532937430c2576ca61f62ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2205ebb532937430c2576ca61f62ddf">&#9670;&#160;</a></span>mutex_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mutex_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock a mutex. </p>
<p>This function will unlock a mutex, allowing other threads to acquire it. The semantics of this operation depend on the mutex type in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mutex to unlock </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EPERM</em> - the current thread does not own the mutex (error-checking or recursive) </dd></dl>

</div>
</div>
<a id="a8f687859cfc8f7a9dcbff7a7eedbcf81" name="a8f687859cfc8f7a9dcbff7a7eedbcf81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f687859cfc8f7a9dcbff7a7eedbcf81">&#9670;&#160;</a></span>mutex_unlock_as_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mutex_unlock_as_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock a mutex under another thread's authority. </p>
<p>This function allows an IRQ handler to unlock a mutex that was locked by a normal kernel thread. This function is only for use in IRQ handlers, so it will generally not be of much use outside of the kernel itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mutex to unlock </td></tr>
    <tr><td class="paramname">thd</td><td>The thread owning the mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EPERM</em> - the specified thread does not own the mutex <br  />
<em>EACCES</em> - called outside an IRQ handler </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_db731743ba9f17d1ef3041653c74f067.html">kos</a></li><li class="navelem"><a class="el" href="mutex_8h.html">mutex.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
