<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KallistiOS: include/kos/rwsem.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">KallistiOS<span id="projectnumber">&#160;##version##</span>
   </div>
   <div id="projectbrief">Independent SDK for the Sega Dreamcast</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('rwsem_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">rwsem.h File Reference<div class="ingroups"><a class="el" href="group__threading.html">Threading</a> &raquo; <a class="el" href="group__kthreads.html">Kernel</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Definition for a reader/writer semaphore.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="cdefs_8h_source.html">kos/cdefs.h</a>&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;<a class="el" href="thread_8h_source.html">kos/thread.h</a>&gt;</code><br />
</div>
<p><a href="rwsem_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reader/writer semaphore structure.  <a href="structrw__semaphore__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1e077aa42fda2bdfcddd9276fbb4b516" id="r_a1e077aa42fda2bdfcddd9276fbb4b516"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#a1e077aa42fda2bdfcddd9276fbb4b516">RWSEM_INITIALIZER</a>&#160;&#160;&#160;{ 0, 0, NULL, NULL }</td></tr>
<tr class="memdesc:a1e077aa42fda2bdfcddd9276fbb4b516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for a transient reader/writer semaphore.  <br /></td></tr>
<tr class="separator:a1e077aa42fda2bdfcddd9276fbb4b516"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2fb7ca5577aa0e4c43d062b12eea3223" id="r_a2fb7ca5577aa0e4c43d062b12eea3223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#a2fb7ca5577aa0e4c43d062b12eea3223">rwsem_create</a> (void) <a class="el" href="group__system__macros.html#ga392e91d0f8a0af994874aadeed30534d">__depr</a>(&quot;Use <a class="el" href="rwsem_8h.html#aecabee230a8ad6b3b7b5877e6ab5c564">rwsem_init</a> or RWSEM_INITIALIZER.&quot;)</td></tr>
<tr class="memdesc:a2fb7ca5577aa0e4c43d062b12eea3223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a reader/writer semaphore.  <br /></td></tr>
<tr class="separator:a2fb7ca5577aa0e4c43d062b12eea3223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecabee230a8ad6b3b7b5877e6ab5c564" id="r_aecabee230a8ad6b3b7b5877e6ab5c564"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#aecabee230a8ad6b3b7b5877e6ab5c564">rwsem_init</a> (<a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *s)</td></tr>
<tr class="memdesc:aecabee230a8ad6b3b7b5877e6ab5c564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a reader/writer semaphore.  <br /></td></tr>
<tr class="separator:aecabee230a8ad6b3b7b5877e6ab5c564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca2f2ec42664eeeb0a39f35ae0cdb44" id="r_a4ca2f2ec42664eeeb0a39f35ae0cdb44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#a4ca2f2ec42664eeeb0a39f35ae0cdb44">rwsem_destroy</a> (<a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *s)</td></tr>
<tr class="memdesc:a4ca2f2ec42664eeeb0a39f35ae0cdb44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a reader/writer semaphore.  <br /></td></tr>
<tr class="separator:a4ca2f2ec42664eeeb0a39f35ae0cdb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab02b961ea92547647a82da791064fa" id="r_a9ab02b961ea92547647a82da791064fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#a9ab02b961ea92547647a82da791064fa">rwsem_read_lock_timed</a> (<a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *s, int timeout)</td></tr>
<tr class="memdesc:a9ab02b961ea92547647a82da791064fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a reader/writer semaphore for reading (with a timeout).  <br /></td></tr>
<tr class="separator:a9ab02b961ea92547647a82da791064fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48bf4e07df12b3d6a0b05a2c0b9b1a0" id="r_ab48bf4e07df12b3d6a0b05a2c0b9b1a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#ab48bf4e07df12b3d6a0b05a2c0b9b1a0">rwsem_read_lock</a> (<a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *s)</td></tr>
<tr class="memdesc:ab48bf4e07df12b3d6a0b05a2c0b9b1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a reader/writer semaphore for reading.  <br /></td></tr>
<tr class="separator:ab48bf4e07df12b3d6a0b05a2c0b9b1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde4aa5703ca5e7678d1f3bbe9a5191e" id="r_adde4aa5703ca5e7678d1f3bbe9a5191e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#adde4aa5703ca5e7678d1f3bbe9a5191e">rwsem_write_lock_timed</a> (<a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *s, int timeout)</td></tr>
<tr class="memdesc:adde4aa5703ca5e7678d1f3bbe9a5191e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a reader/writer semaphore for writing (with a timeout).  <br /></td></tr>
<tr class="separator:adde4aa5703ca5e7678d1f3bbe9a5191e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02022ecde855c95828d9762209a3d4e6" id="r_a02022ecde855c95828d9762209a3d4e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#a02022ecde855c95828d9762209a3d4e6">rwsem_write_lock</a> (<a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *s)</td></tr>
<tr class="memdesc:a02022ecde855c95828d9762209a3d4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a reader/writer semaphore for writing.  <br /></td></tr>
<tr class="separator:a02022ecde855c95828d9762209a3d4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3788ca89e8d60336adfe919116e7cf" id="r_acc3788ca89e8d60336adfe919116e7cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#acc3788ca89e8d60336adfe919116e7cf">rwsem_read_unlock</a> (<a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *s)</td></tr>
<tr class="memdesc:acc3788ca89e8d60336adfe919116e7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a reader/writer semaphore from a read lock.  <br /></td></tr>
<tr class="separator:acc3788ca89e8d60336adfe919116e7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157aca2974642e593f8ad2def163b431" id="r_a157aca2974642e593f8ad2def163b431"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#a157aca2974642e593f8ad2def163b431">rwsem_write_unlock</a> (<a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *s)</td></tr>
<tr class="memdesc:a157aca2974642e593f8ad2def163b431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a reader/writer semaphore from a write lock.  <br /></td></tr>
<tr class="separator:a157aca2974642e593f8ad2def163b431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45618d5cb7eb922a765f603f77b3727e" id="r_a45618d5cb7eb922a765f603f77b3727e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#a45618d5cb7eb922a765f603f77b3727e">rwsem_unlock</a> (<a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *s)</td></tr>
<tr class="memdesc:a45618d5cb7eb922a765f603f77b3727e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a reader/writer semaphore.  <br /></td></tr>
<tr class="separator:a45618d5cb7eb922a765f603f77b3727e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116c6de5182dc8b031d3c5f893f918e5" id="r_a116c6de5182dc8b031d3c5f893f918e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#a116c6de5182dc8b031d3c5f893f918e5">rwsem_read_trylock</a> (<a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *s)</td></tr>
<tr class="memdesc:a116c6de5182dc8b031d3c5f893f918e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to lock a reader/writer semaphore for reading.  <br /></td></tr>
<tr class="separator:a116c6de5182dc8b031d3c5f893f918e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae810d821cfe88e02691274082287f221" id="r_ae810d821cfe88e02691274082287f221"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#ae810d821cfe88e02691274082287f221">rwsem_write_trylock</a> (<a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *s)</td></tr>
<tr class="memdesc:ae810d821cfe88e02691274082287f221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to lock a reader/writer semaphore for writing.  <br /></td></tr>
<tr class="separator:ae810d821cfe88e02691274082287f221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0479334279d21451f73ce6b80d23ae7" id="r_af0479334279d21451f73ce6b80d23ae7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#af0479334279d21451f73ce6b80d23ae7">rwsem_read_upgrade_timed</a> (<a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *s, int timeout)</td></tr>
<tr class="memdesc:af0479334279d21451f73ce6b80d23ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upgrade a thread from reader status to writer status (with a timeout).  <br /></td></tr>
<tr class="separator:af0479334279d21451f73ce6b80d23ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca6c9682649cef79c74d88b9f800f60" id="r_a8ca6c9682649cef79c74d88b9f800f60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#a8ca6c9682649cef79c74d88b9f800f60">rwsem_read_upgrade</a> (<a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *s)</td></tr>
<tr class="memdesc:a8ca6c9682649cef79c74d88b9f800f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upgrade a thread from reader status to writer status.  <br /></td></tr>
<tr class="separator:a8ca6c9682649cef79c74d88b9f800f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2fc79b795b45081b61b78496f58b54" id="r_a3e2fc79b795b45081b61b78496f58b54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#a3e2fc79b795b45081b61b78496f58b54">rwsem_read_tryupgrade</a> (<a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *s)</td></tr>
<tr class="memdesc:a3e2fc79b795b45081b61b78496f58b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to upgrade a thread from reader status to writer status.  <br /></td></tr>
<tr class="separator:a3e2fc79b795b45081b61b78496f58b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868cd8d213c973e9a5f010227ba920a7" id="r_a868cd8d213c973e9a5f010227ba920a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#a868cd8d213c973e9a5f010227ba920a7">rwsem_read_count</a> (<a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *s)</td></tr>
<tr class="memdesc:a868cd8d213c973e9a5f010227ba920a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the reader count on the reader/writer semaphore.  <br /></td></tr>
<tr class="separator:a868cd8d213c973e9a5f010227ba920a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63ae4d778fcb933e2223f22ae169d1a" id="r_af63ae4d778fcb933e2223f22ae169d1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html#af63ae4d778fcb933e2223f22ae169d1a">rwsem_write_locked</a> (<a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *s)</td></tr>
<tr class="memdesc:af63ae4d778fcb933e2223f22ae169d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the state of the writer lock on the reader/writer semaphore.  <br /></td></tr>
<tr class="separator:af63ae4d778fcb933e2223f22ae169d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Definition for a reader/writer semaphore. </p>
<p>This file defines a concept of reader/writer semaphores. Basically, this type of lock allows an unlimited number of "readers" to acquire the lock at a time, but only one "writer" (and only if no readers hold the lock). Readers, by definition, should not change any global data (since they are defined to only be reading), and since this is the case it is safe to allow multiple readers to access global data that is shared amongst threads. Writers on the other hand require exclusive access since they will be changing global data in the critical section, and they cannot share with a reader either (since the reader might attempt to read while the writer is changing data).</p>
<dl class="section author"><dt>Author</dt><dd>Lawrence Sebald </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a1e077aa42fda2bdfcddd9276fbb4b516" name="a1e077aa42fda2bdfcddd9276fbb4b516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e077aa42fda2bdfcddd9276fbb4b516">&#9670;&#160;</a></span>RWSEM_INITIALIZER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RWSEM_INITIALIZER&#160;&#160;&#160;{ 0, 0, NULL, NULL }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for a transient reader/writer semaphore. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2fb7ca5577aa0e4c43d062b12eea3223" name="a2fb7ca5577aa0e4c43d062b12eea3223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb7ca5577aa0e4c43d062b12eea3223">&#9670;&#160;</a></span>rwsem_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> * rwsem_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a reader/writer semaphore. </p>
<p>This function allocates a new reader/writer lock that is initially not locked either for reading or writing.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>This function is formally deprecated, and should not be used in newly written code. Instead, please use <a class="el" href="rwsem_8h.html#aecabee230a8ad6b3b7b5877e6ab5c564" title="Initialize a reader/writer semaphore.">rwsem_init()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The created semaphore, or NULL on failure (errno will be set as appropriate).</dd></dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>ENOMEM</em> - out of memory </dd></dl>

</div>
</div>
<a id="a4ca2f2ec42664eeeb0a39f35ae0cdb44" name="a4ca2f2ec42664eeeb0a39f35ae0cdb44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca2f2ec42664eeeb0a39f35ae0cdb44">&#9670;&#160;</a></span>rwsem_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rwsem_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a reader/writer semaphore. </p>
<p>This function cleans up a reader/writer semaphore. It is an error to attempt to destroy a r/w semaphore that is locked either for reading or writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The r/w semaphore to destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EBUSY</em> - the semaphore is still locked </dd></dl>

</div>
</div>
<a id="aecabee230a8ad6b3b7b5877e6ab5c564" name="aecabee230a8ad6b3b7b5877e6ab5c564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecabee230a8ad6b3b7b5877e6ab5c564">&#9670;&#160;</a></span>rwsem_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rwsem_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a reader/writer semaphore. </p>
<p>This function initializes a new reader/writer semaphore for use.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success (no error conditions currently defined). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a868cd8d213c973e9a5f010227ba920a7" name="a868cd8d213c973e9a5f010227ba920a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868cd8d213c973e9a5f010227ba920a7">&#9670;&#160;</a></span>rwsem_read_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rwsem_read_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the reader count on the reader/writer semaphore. </p>
<p>This function is not a safe way to see if the lock will be locked by any readers when you get around to locking it, so do not use it in this way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The r/w semaphore to count the readers on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of readers holding the r/w semaphore. </dd></dl>

</div>
</div>
<a id="ab48bf4e07df12b3d6a0b05a2c0b9b1a0" name="ab48bf4e07df12b3d6a0b05a2c0b9b1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48bf4e07df12b3d6a0b05a2c0b9b1a0">&#9670;&#160;</a></span>rwsem_read_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rwsem_read_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a reader/writer semaphore for reading. </p>
<p>This function attempts to lock the r/w semaphore for reading. If the semaphore is locked for writing, this function will block until it is possible to obtain the lock for reading. This function is <b>NOT</b> safe to call inside of an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The r/w semaphore to lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EPERM</em> - called inside an interrupt <br  />
<em>EINVAL</em> - the semaphore is not initialized </dd></dl>

</div>
</div>
<a id="a9ab02b961ea92547647a82da791064fa" name="a9ab02b961ea92547647a82da791064fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab02b961ea92547647a82da791064fa">&#9670;&#160;</a></span>rwsem_read_lock_timed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rwsem_read_lock_timed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a reader/writer semaphore for reading (with a timeout). </p>
<p>This function attempts to lock the r/w semaphore for reading. If the semaphore is locked for writing, this function will block until it is possible to obtain the lock for reading or the timeout expires. This function is <b>NOT</b> safe to call inside of an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The r/w semaphore to lock. </td></tr>
    <tr><td class="paramname">timeout</td><td>The maximum time to wait (in milliseconds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EPERM</em> - called inside an interrupt <br  />
<em>ETIMEDOUT</em> - the timeout expires before the lock can be acquired <br  />
<em>EINVAL</em> - the timeout value is invalid <br  />
<em>EINVAL</em> - the semaphore is not initialized </dd></dl>

</div>
</div>
<a id="a116c6de5182dc8b031d3c5f893f918e5" name="a116c6de5182dc8b031d3c5f893f918e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116c6de5182dc8b031d3c5f893f918e5">&#9670;&#160;</a></span>rwsem_read_trylock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rwsem_read_trylock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to lock a reader/writer semaphore for reading. </p>
<p>This function attempts to lock the r/w semaphore for reading. If for any reason rwsem_read_lock would normally block, this function will return an error. This function is safe to call inside an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The r/w semaphore to attempt to lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EWOULDBLOCK</em> - a call to rwsem_read_lock would block <br  />
<em>EINVAL</em> - the semaphore is not initialized </dd></dl>

</div>
</div>
<a id="a3e2fc79b795b45081b61b78496f58b54" name="a3e2fc79b795b45081b61b78496f58b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2fc79b795b45081b61b78496f58b54">&#9670;&#160;</a></span>rwsem_read_tryupgrade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rwsem_read_tryupgrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to upgrade a thread from reader status to writer status. </p>
<p>This function will attempt to upgrade the lock on the calling thread to writer status. If for any reason rwsem_read_upgrade would block, this function will return an error. This function is safe to call inside an interrupt. Note that on error, the read lock is still held!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The r/w semaphore to upgrade. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EWOULDBLOCK</em> - a call to rwsem_read_upgrade would block <br  />
<em>EBUSY</em> - another reader has already requested an upgrade <br  />
<em>EINVAL</em> - the semaphore is not initialized </dd></dl>

</div>
</div>
<a id="acc3788ca89e8d60336adfe919116e7cf" name="acc3788ca89e8d60336adfe919116e7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3788ca89e8d60336adfe919116e7cf">&#9670;&#160;</a></span>rwsem_read_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rwsem_read_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock a reader/writer semaphore from a read lock. </p>
<p>This function releases one instance of the read lock on the r/w semaphore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The r/w semaphore to release the read lock on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EPERM</em> - the read lock is not currently held <br  />
<em>EINVAL</em> - the semaphore is not initialized </dd></dl>

</div>
</div>
<a id="a8ca6c9682649cef79c74d88b9f800f60" name="a8ca6c9682649cef79c74d88b9f800f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca6c9682649cef79c74d88b9f800f60">&#9670;&#160;</a></span>rwsem_read_upgrade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rwsem_read_upgrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upgrade a thread from reader status to writer status. </p>
<p>This function will upgrade the lock on the calling thread from a reader state to a writer state. If it cannot do this at the moment, it will block until it is possible. This function is <b>NOT</b> safe to call inside an interrupt.</p>
<p>You can only have one reader waiting to upgrade at a time, otherwise the state would potentially become corrupted between when this is called and when you get the lock. If you get -1 back from this, you must not assume that you can write safely! On error, the calling thread will still hold a read lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The r/w semaphore to upgrade. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EPERM</em> - called inside an interrupt <br  />
<em>EINVAL</em> - the semaphore is not initialized <br  />
<em>EBUSY</em> - another reader has already requested an upgrade </dd></dl>

</div>
</div>
<a id="af0479334279d21451f73ce6b80d23ae7" name="af0479334279d21451f73ce6b80d23ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0479334279d21451f73ce6b80d23ae7">&#9670;&#160;</a></span>rwsem_read_upgrade_timed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rwsem_read_upgrade_timed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upgrade a thread from reader status to writer status (with a timeout). </p>
<p>This function will upgrade the lock on the calling thread from a reader state to a writer state. If it cannot do this at the moment, it will block until it is possible. This function is <b>NOT</b> safe to call inside an interrupt.</p>
<p>You can only have one reader waiting to upgrade at a time, otherwise the state would potentially become corrupted between when this is called and when you get the lock. If you get -1 back from this, you must not assume that you can write safely! On error, the calling thread will still hold a read lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The r/w semaphore to upgrade. </td></tr>
    <tr><td class="paramname">timeout</td><td>The maximum time to wait (in milliseconds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EPERM</em> - called inside an interrupt <br  />
<em>EINVAL</em> - the semaphore is not initialized <br  />
<em>EINVAL</em> - the timeout value is invalid <br  />
<em>EBUSY</em> - another reader has already requested an upgrade <br  />
<em>ETIMEDOUT</em> - the timeout expired before the write lock could be acquired </dd></dl>

</div>
</div>
<a id="a45618d5cb7eb922a765f603f77b3727e" name="a45618d5cb7eb922a765f603f77b3727e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45618d5cb7eb922a765f603f77b3727e">&#9670;&#160;</a></span>rwsem_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rwsem_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock a reader/writer semaphore. </p>
<p>This function releases the lock held by the current thread on the specified reader/writer semaphore. This function will automatically determine which lock is held by the calling thread and release it as appropriate.</p>
<p>This function is <b>NOT</b> safe to call (in general) if you do not hold the lock!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The r/w semaphore to release the lock on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EPERM</em> - the lock is not currently held by the calling thread <br  />
<em>EINVAL</em> - the semaphore is not initialized </dd></dl>

</div>
</div>
<a id="a02022ecde855c95828d9762209a3d4e6" name="a02022ecde855c95828d9762209a3d4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02022ecde855c95828d9762209a3d4e6">&#9670;&#160;</a></span>rwsem_write_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rwsem_write_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a reader/writer semaphore for writing. </p>
<p>This function attempts to lock the r/w semaphore for writing. If the semaphore is locked for reading or writing, this function will block until it is possible to obtain the lock for writing. This function is <b>NOT</b> safe to call inside of an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The r/w semaphore to lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error conditions:</dt><dd><em>EPERM</em> - called inside an interrupt <br  />
<em>EINVAL</em> - the semaphore is not initialized </dd></dl>

</div>
</div>
<a id="adde4aa5703ca5e7678d1f3bbe9a5191e" name="adde4aa5703ca5e7678d1f3bbe9a5191e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde4aa5703ca5e7678d1f3bbe9a5191e">&#9670;&#160;</a></span>rwsem_write_lock_timed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rwsem_write_lock_timed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a reader/writer semaphore for writing (with a timeout). </p>
<p>This function attempts to lock the r/w semaphore for writing. If the semaphore is locked for reading or writing, this function will block until it is possible to obtain the lock for writing or the timeout expires. This function is <b>NOT</b> safe to call inside of an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The r/w semaphore to lock. </td></tr>
    <tr><td class="paramname">timeout</td><td>The maximum time to wait (in milliseconds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EPERM</em> - called inside an interrupt <br  />
<em>ETIMEDOUT</em> - the timeout expires before the lock can be acquired <br  />
<em>EINVAL</em> - the timeout value is invalid <br  />
<em>EINVAL</em> - the semaphore is not initialized </dd></dl>

</div>
</div>
<a id="af63ae4d778fcb933e2223f22ae169d1a" name="af63ae4d778fcb933e2223f22ae169d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63ae4d778fcb933e2223f22ae169d1a">&#9670;&#160;</a></span>rwsem_write_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rwsem_write_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the state of the writer lock on the reader/writer semaphore. </p>
<p>This function is not a safe way to see if the lock will be locked by a writer by the time you get around to doing something with it, so don't try to use it for that purpose.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The r/w semaphore to check the writer status on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the writer lock of the r/w semaphore. </dd></dl>

</div>
</div>
<a id="ae810d821cfe88e02691274082287f221" name="ae810d821cfe88e02691274082287f221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae810d821cfe88e02691274082287f221">&#9670;&#160;</a></span>rwsem_write_trylock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rwsem_write_trylock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to lock a reader/writer semaphore for writing. </p>
<p>This function attempts to lock the r/w semaphore for writing. If for any reason rwsem_write_lock would normally block, this function will return an error. This function is safe to call inside an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The r/w semaphore to attempt to lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EWOULDBLOCK</em> - a call to rwsem_write_lock would block <br  />
<em>EINVAL</em> - the semaphore is not initialized </dd></dl>

</div>
</div>
<a id="a157aca2974642e593f8ad2def163b431" name="a157aca2974642e593f8ad2def163b431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157aca2974642e593f8ad2def163b431">&#9670;&#160;</a></span>rwsem_write_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rwsem_write_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__semaphore__t.html">rw_semaphore_t</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock a reader/writer semaphore from a write lock. </p>
<p>This function releases one instance of the write lock on the r/w semaphore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The r/w semaphore to release the write lock on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On error, errno will be set as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EPERM</em> - the write lock is not currently held by the calling thread <br  />
<em>EINVAL</em> - the semaphore is not initialized </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_db731743ba9f17d1ef3041653c74f067.html">kos</a></li><li class="navelem"><a class="el" href="rwsem_8h.html">rwsem.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
