<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KallistiOS: Scene Submission</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">KallistiOS<span id="projectnumber">&#160;##version##</span>
   </div>
   <div id="projectbrief">Independent SDK for the Sega Dreamcast</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__pvr__scene__mgmt.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Scene Submission<div class="ingroups"><a class="el" href="group__video.html">Video</a> &raquo; <a class="el" href="group__pvr.html">PowerVR API</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>PowerVR API for submitting scene geometry.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__pvr__direct" id="r_group__pvr__direct"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pvr__direct.html">Direct Rendering</a></td></tr>
<tr class="memdesc:group__pvr__direct"><td class="mdescLeft">&#160;</td><td class="mdescRight">API for using direct rendering with the PVR. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__pvr__list__mgmt" id="r_group__pvr__list__mgmt"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pvr__list__mgmt.html">Polygon Lists</a></td></tr>
<tr class="memdesc:group__pvr__list__mgmt"><td class="mdescLeft">&#160;</td><td class="mdescRight">PVR API for managing list submission. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__pvr__vertex__dma" id="r_group__pvr__vertex__dma"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pvr__vertex__dma.html">Vertex DMA</a></td></tr>
<tr class="memdesc:group__pvr__vertex__dma"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the DMA to transfer inactive lists to the PVR. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga31ff6483321e2432e064f1659089f405" id="r_ga31ff6483321e2432e064f1659089f405"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pvr__scene__mgmt.html#ga31ff6483321e2432e064f1659089f405">pvr_set_presort_mode</a> (int presort)</td></tr>
<tr class="memdesc:ga31ff6483321e2432e064f1659089f405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the translucent polygon sort mode for the next frame.  <br /></td></tr>
<tr class="separator:ga31ff6483321e2432e064f1659089f405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2591778ee90a30e44c6ea815a71105dd" id="r_ga2591778ee90a30e44c6ea815a71105dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pvr__scene__mgmt.html#ga2591778ee90a30e44c6ea815a71105dd">pvr_scene_begin</a> (void)</td></tr>
<tr class="memdesc:ga2591778ee90a30e44c6ea815a71105dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin collecting data for a frame of 3D output to the off-screen frame buffer.  <br /></td></tr>
<tr class="separator:ga2591778ee90a30e44c6ea815a71105dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga131f41fd16df052c2f4937694c250e69" id="r_ga131f41fd16df052c2f4937694c250e69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pvr__scene__mgmt.html#ga131f41fd16df052c2f4937694c250e69">pvr_scene_begin_txr</a> (<a class="el" href="group__pvr__vram.html#ga621fa8a260d17a31b12d4155426d0fa4">pvr_ptr_t</a> txr, uint32_t *rx, uint32_t *ry)</td></tr>
<tr class="memdesc:ga131f41fd16df052c2f4937694c250e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin collecting data for a frame of 3D output to the specified texture.  <br /></td></tr>
<tr class="separator:ga131f41fd16df052c2f4937694c250e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c93c12bd5268b38de9ff645b308f64f" id="r_ga0c93c12bd5268b38de9ff645b308f64f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pvr__scene__mgmt.html#ga0c93c12bd5268b38de9ff645b308f64f">pvr_scene_finish</a> (void)</td></tr>
<tr class="memdesc:ga0c93c12bd5268b38de9ff645b308f64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this after you have finished submitting all data for a frame.  <br /></td></tr>
<tr class="separator:ga0c93c12bd5268b38de9ff645b308f64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c98c3fa41e7a954bc6f0c3232c634fe" id="r_ga7c98c3fa41e7a954bc6f0c3232c634fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pvr__scene__mgmt.html#ga7c98c3fa41e7a954bc6f0c3232c634fe">pvr_wait_ready</a> (void)</td></tr>
<tr class="memdesc:ga7c98c3fa41e7a954bc6f0c3232c634fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the caller until the PVR system is ready for another frame to be submitted.  <br /></td></tr>
<tr class="separator:ga7c98c3fa41e7a954bc6f0c3232c634fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a75605c69b298038704cbf5e27d4cc0" id="r_ga3a75605c69b298038704cbf5e27d4cc0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pvr__scene__mgmt.html#ga3a75605c69b298038704cbf5e27d4cc0">pvr_check_ready</a> (void)</td></tr>
<tr class="memdesc:ga3a75605c69b298038704cbf5e27d4cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the PVR system is ready for another frame to be submitted.  <br /></td></tr>
<tr class="separator:ga3a75605c69b298038704cbf5e27d4cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>PowerVR API for submitting scene geometry. </p>
<p>This API is used to submit triangle strips to the PVR via the TA interface in the chip.</p>
<p>An important side note about the PVR is that all primitive types must be submitted grouped together. If you have 10 polygons for each list type, then the PVR must receive them via the TA by list type, with a list delimiter in between.</p>
<p>So there are two modes you can use here. The first mode allows you to submit data directly to the TA. Your data will be forwarded to the chip for processing as it is fed to the PVR module. If your data is easily sorted into the primitive types, then this is the fastest mode for submitting data.</p>
<p>The second mode allows you to submit data via main-RAM vertex buffers, which will be queued until the proper primitive type is active. In this case, each piece of data is copied into the vertex buffer while the wrong list is activated, and when the proper list becomes activated, the data is all sent at once. Ideally this would be via DMA, right now it is by store queues. This has the advantage of allowing you to send data in any order and have the PVR functions resolve how it should get sent to the hardware, but it is slower.</p>
<p>The nice thing is that any combination of these modes can be used. You can assign a vertex buffer for any list, and it will be used to hold the incoming vertex data until the proper list has come up. Or if the proper list is already up, the data will be submitted directly. So if most of your polygons are opaque, and you only have a couple of translucents, you can set a small buffer to gather translucent data and then it will get sent when you do a pvr_end_scene().</p>
<p>Thanks to Mikael Kalms for the idea for this API.</p>
<dl class="section note"><dt>Note</dt><dd>Another somewhat subtle point that bears mentioning is that in the normal case (interrupts enabled) an interrupt handler will automatically take care of starting a frame rendering (after scene_finish()) and also flipping pages when appropriate. </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3a75605c69b298038704cbf5e27d4cc0" name="ga3a75605c69b298038704cbf5e27d4cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a75605c69b298038704cbf5e27d4cc0">&#9670;&#160;</a></span>pvr_check_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr_check_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the PVR system is ready for another frame to be submitted. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If the PVR is ready for a new scene. You must call <a class="el" href="group__pvr__scene__mgmt.html#ga7c98c3fa41e7a954bc6f0c3232c634fe" title="Block the caller until the PVR system is ready for another frame to be submitted.">pvr_wait_ready()</a> afterwards, before starting a new scene. </td></tr>
    <tr><td class="paramname">-1</td><td>If the PVR is not ready for a new scene yet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2591778ee90a30e44c6ea815a71105dd" name="ga2591778ee90a30e44c6ea815a71105dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2591778ee90a30e44c6ea815a71105dd">&#9670;&#160;</a></span>pvr_scene_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr_scene_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin collecting data for a frame of 3D output to the off-screen frame buffer. </p>
<p>You must call this function (or <a class="el" href="group__pvr__scene__mgmt.html#ga131f41fd16df052c2f4937694c250e69" title="Begin collecting data for a frame of 3D output to the specified texture.">pvr_scene_begin_txr()</a>) for ever frame of output. </p>

</div>
</div>
<a id="ga131f41fd16df052c2f4937694c250e69" name="ga131f41fd16df052c2f4937694c250e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga131f41fd16df052c2f4937694c250e69">&#9670;&#160;</a></span>pvr_scene_begin_txr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr_scene_begin_txr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pvr__vram.html#ga621fa8a260d17a31b12d4155426d0fa4">pvr_ptr_t</a>&#160;</td>
          <td class="paramname"><em>txr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin collecting data for a frame of 3D output to the specified texture. </p>
<p>This function currently only supports outputting at the same size as the actual screen. Thus, make sure rx and ry are at least large enough for that. For a 640x480 output, rx will generally be 1024 on input and ry 512, as these are the smallest values that are powers of two and will hold the full screen sized output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txr</td><td>The texture to render to. </td></tr>
    <tr><td class="paramname">rx</td><td>Width of the texture buffer (in pixels). </td></tr>
    <tr><td class="paramname">ry</td><td>Height of the texture buffer (in pixels). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0c93c12bd5268b38de9ff645b308f64f" name="ga0c93c12bd5268b38de9ff645b308f64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c93c12bd5268b38de9ff645b308f64f">&#9670;&#160;</a></span>pvr_scene_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr_scene_finish </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this after you have finished submitting all data for a frame. </p>
<p>Once this has been called, you can not submit any more data until one of the <a class="el" href="group__pvr__scene__mgmt.html#ga2591778ee90a30e44c6ea815a71105dd" title="Begin collecting data for a frame of 3D output to the off-screen frame buffer.">pvr_scene_begin()</a> or <a class="el" href="group__pvr__scene__mgmt.html#ga131f41fd16df052c2f4937694c250e69" title="Begin collecting data for a frame of 3D output to the specified texture.">pvr_scene_begin_txr()</a> functions is called again.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On error (no scene started). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga31ff6483321e2432e064f1659089f405" name="ga31ff6483321e2432e064f1659089f405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31ff6483321e2432e064f1659089f405">&#9670;&#160;</a></span>pvr_set_presort_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr_set_presort_mode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>presort</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the translucent polygon sort mode for the next frame. </p>
<p>This function sets the translucent polygon sort mode for the next frame of output, potentially switching between autosort and presort mode.</p>
<p>For most programs, you'll probably want to set this at initialization time (with the autosort_disabled field in the <a class="el" href="structpvr__init__params__t.html" title="PVR initialization structure.">pvr_init_params_t</a> structure) and not mess with it per-frame. It is recommended that if you do use this function to change the mode that you should set it each frame to ensure that the mode is set properly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">presort</td><td>Set to 1 to set the presort mode for translucent polygons, set to 0 to use autosort mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c98c3fa41e7a954bc6f0c3232c634fe" name="ga7c98c3fa41e7a954bc6f0c3232c634fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c98c3fa41e7a954bc6f0c3232c634fe">&#9670;&#160;</a></span>pvr_wait_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr_wait_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block the caller until the PVR system is ready for another frame to be submitted. </p>
<p>The PVR system allocates enough space for two frames: one in data collection mode, and another in rendering mode. If a frame is currently rendering, and another frame has already been closed, then the caller cannot do anything else until the rendering frame completes. Note also that the new frame cannot be activated except during a vertical blanking period, so this essentially waits until a rendered frame is complete and a vertical blank happens.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. A new scene can be started now. </td></tr>
    <tr><td class="paramname">-1</td><td>On error. Something is probably very wrong... </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
