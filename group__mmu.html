<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KallistiOS: MMU</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">KallistiOS<span id="projectnumber">&#160;##version##</span>
   </div>
   <div id="projectbrief">Independent SDK for the Sega Dreamcast</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__mmu.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">MMU<div class="ingroups"><a class="el" href="group__system.html">System</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Driver for the SH4's MMU (disabled by default).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__mmu__bit__macros" id="r_group__mmu__bit__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu__bit__macros.html">Address Bits</a></td></tr>
<tr class="memdesc:group__mmu__bit__macros"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions and masks for address pages. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__mmu__cache__values" id="r_group__mmu__cache__values"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu__cache__values.html">Cacheability Settings</a></td></tr>
<tr class="memdesc:group__mmu__cache__values"><td class="mdescLeft">&#160;</td><td class="mdescRight">SH4 MMU page cachability settings values. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__mmu__prot__values" id="r_group__mmu__prot__values"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu__prot__values.html">Protection Settings</a></td></tr>
<tr class="memdesc:group__mmu__prot__values"><td class="mdescLeft">&#160;</td><td class="mdescRight">SH4 MMU page protection settings values. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:mmu_8h" id="r_mmu_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mmu_8h.html">mmu.h</a></td></tr>
<tr class="memdesc:mmu_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory Management Unit and Translation Lookaside Buffer handling. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmmupage__t.html">mmupage_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MMU TLB entry for a single page.  <a href="structmmupage__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmmusubcontext__t.html">mmusubcontext_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MMU sub-context type.  <a href="structmmusubcontext__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmmucontext__t.html">mmucontext_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MMU context type.  <a href="structmmucontext__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1da93d07c858b66f16d8fb8d55bfc309" id="r_ga1da93d07c858b66f16d8fb8d55bfc309"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#ga1da93d07c858b66f16d8fb8d55bfc309">MMU_SUB_PAGES</a>&#160;&#160;&#160;512</td></tr>
<tr class="memdesc:ga1da93d07c858b66f16d8fb8d55bfc309"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of pages in a sub-context.  <br /></td></tr>
<tr class="separator:ga1da93d07c858b66f16d8fb8d55bfc309"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga85804e94e2c6f22c8d1d1f2c216ba0d1" id="r_ga85804e94e2c6f22c8d1d1f2c216ba0d1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structmmupage__t.html">mmupage_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#ga85804e94e2c6f22c8d1d1f2c216ba0d1">mmu_mapfunc_t</a>) (<a class="el" href="structmmucontext__t.html">mmucontext_t</a> *context, int virtpage)</td></tr>
<tr class="memdesc:ga85804e94e2c6f22c8d1d1f2c216ba0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">MMU mapping handler.  <br /></td></tr>
<tr class="separator:ga85804e94e2c6f22c8d1d1f2c216ba0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga99345af516a0d915069901fd4d2a8582" id="r_ga99345af516a0d915069901fd4d2a8582"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#ga99345af516a0d915069901fd4d2a8582">mmu_use_table</a> (<a class="el" href="structmmucontext__t.html">mmucontext_t</a> *context)</td></tr>
<tr class="memdesc:ga99345af516a0d915069901fd4d2a8582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the "current" page tables for TLB handling.  <br /></td></tr>
<tr class="separator:ga99345af516a0d915069901fd4d2a8582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c300b842e699577ec52b05215ff497a" id="r_ga8c300b842e699577ec52b05215ff497a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmmucontext__t.html">mmucontext_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#ga8c300b842e699577ec52b05215ff497a">mmu_context_create</a> (int asid)</td></tr>
<tr class="memdesc:ga8c300b842e699577ec52b05215ff497a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new MMU context.  <br /></td></tr>
<tr class="separator:ga8c300b842e699577ec52b05215ff497a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00ee028bb7e383e6a478d9c0bc38e394" id="r_ga00ee028bb7e383e6a478d9c0bc38e394"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#ga00ee028bb7e383e6a478d9c0bc38e394">mmu_context_destroy</a> (<a class="el" href="structmmucontext__t.html">mmucontext_t</a> *context)</td></tr>
<tr class="memdesc:ga00ee028bb7e383e6a478d9c0bc38e394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an MMU context when a process is being destroyed.  <br /></td></tr>
<tr class="separator:ga00ee028bb7e383e6a478d9c0bc38e394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7bc7e2e50dc71075798502ee3f49f62" id="r_gaa7bc7e2e50dc71075798502ee3f49f62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#gaa7bc7e2e50dc71075798502ee3f49f62">mmu_virt_to_phys</a> (<a class="el" href="structmmucontext__t.html">mmucontext_t</a> *context, int virtpage)</td></tr>
<tr class="memdesc:gaa7bc7e2e50dc71075798502ee3f49f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the given page tables, translate the virtual page ID to a physical page ID.  <br /></td></tr>
<tr class="separator:gaa7bc7e2e50dc71075798502ee3f49f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51602d6eff020251832042618d493ea5" id="r_ga51602d6eff020251832042618d493ea5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#ga51602d6eff020251832042618d493ea5">mmu_phys_to_virt</a> (<a class="el" href="structmmucontext__t.html">mmucontext_t</a> *context, int physpage)</td></tr>
<tr class="memdesc:ga51602d6eff020251832042618d493ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the given page tables, translate the physical page ID to a virtual page ID.  <br /></td></tr>
<tr class="separator:ga51602d6eff020251832042618d493ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga448c7722206ca064de59cbe2431f349e" id="r_ga448c7722206ca064de59cbe2431f349e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#ga448c7722206ca064de59cbe2431f349e">mmu_switch_context</a> (<a class="el" href="structmmucontext__t.html">mmucontext_t</a> *context)</td></tr>
<tr class="memdesc:ga448c7722206ca064de59cbe2431f349e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch to the given context.  <br /></td></tr>
<tr class="separator:ga448c7722206ca064de59cbe2431f349e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa18eb0616187816f8168f019db521b8" id="r_gaaa18eb0616187816f8168f019db521b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#gaaa18eb0616187816f8168f019db521b8">mmu_page_map</a> (<a class="el" href="structmmucontext__t.html">mmucontext_t</a> *context, int virtpage, int physpage, int count, int prot, int cache, int share, int dirty)</td></tr>
<tr class="memdesc:gaaa18eb0616187816f8168f019db521b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the given virtual page to map to the given physical page.  <br /></td></tr>
<tr class="separator:gaaa18eb0616187816f8168f019db521b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb49f02b9c3421c3db648983eac56b6f" id="r_gacb49f02b9c3421c3db648983eac56b6f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#gacb49f02b9c3421c3db648983eac56b6f">mmu_copyin</a> (<a class="el" href="structmmucontext__t.html">mmucontext_t</a> *context, <a class="el" href="group__system__types.html#ga4b435a49c74bb91f284f075e63416cb6">uint32</a> srcaddr, <a class="el" href="group__system__types.html#ga4b435a49c74bb91f284f075e63416cb6">uint32</a> srccnt, void *buffer)</td></tr>
<tr class="memdesc:gacb49f02b9c3421c3db648983eac56b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a chunk of data from a process' address space into a kernel buffer, taking into account page mappings.  <br /></td></tr>
<tr class="separator:gacb49f02b9c3421c3db648983eac56b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac159acf73a24f4a7cdada65b31b04616" id="r_gac159acf73a24f4a7cdada65b31b04616"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#gac159acf73a24f4a7cdada65b31b04616">mmu_copyv</a> (<a class="el" href="structmmucontext__t.html">mmucontext_t</a> *context1, struct <a class="el" href="structiovec.html">iovec</a> *iov1, int iovcnt1, <a class="el" href="structmmucontext__t.html">mmucontext_t</a> *context2, struct <a class="el" href="structiovec.html">iovec</a> *iov2, int iovcnt2)</td></tr>
<tr class="memdesc:gac159acf73a24f4a7cdada65b31b04616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a chunk of data from one process' address space to another process' address space, taking into account page mappings.  <br /></td></tr>
<tr class="separator:gac159acf73a24f4a7cdada65b31b04616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac88e46560cb86b0e759c6c51c32b4cd9" id="r_gac88e46560cb86b0e759c6c51c32b4cd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mmu.html#ga85804e94e2c6f22c8d1d1f2c216ba0d1">mmu_mapfunc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#gac88e46560cb86b0e759c6c51c32b4cd9">mmu_map_get_callback</a> (void)</td></tr>
<tr class="memdesc:gac88e46560cb86b0e759c6c51c32b4cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current mapping function.  <br /></td></tr>
<tr class="separator:gac88e46560cb86b0e759c6c51c32b4cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fe62887a4c714ac9c7e6db0b7c67c1e" id="r_ga0fe62887a4c714ac9c7e6db0b7c67c1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mmu.html#ga85804e94e2c6f22c8d1d1f2c216ba0d1">mmu_mapfunc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#ga0fe62887a4c714ac9c7e6db0b7c67c1e">mmu_map_set_callback</a> (<a class="el" href="group__mmu.html#ga85804e94e2c6f22c8d1d1f2c216ba0d1">mmu_mapfunc_t</a> newfunc)</td></tr>
<tr class="memdesc:ga0fe62887a4c714ac9c7e6db0b7c67c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new MMU mapping handler.  <br /></td></tr>
<tr class="separator:ga0fe62887a4c714ac9c7e6db0b7c67c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fea2a954713027b1a67b60380ab41d8" id="r_ga8fea2a954713027b1a67b60380ab41d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#ga8fea2a954713027b1a67b60380ab41d8">mmu_init</a> (void)</td></tr>
<tr class="memdesc:ga8fea2a954713027b1a67b60380ab41d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize MMU support.  <br /></td></tr>
<tr class="separator:ga8fea2a954713027b1a67b60380ab41d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa86f8c70fd4601477a2c6c88daa944b4" id="r_gaa86f8c70fd4601477a2c6c88daa944b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#gaa86f8c70fd4601477a2c6c88daa944b4">mmu_shutdown</a> (void)</td></tr>
<tr class="memdesc:gaa86f8c70fd4601477a2c6c88daa944b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown MMU support.  <br /></td></tr>
<tr class="separator:gaa86f8c70fd4601477a2c6c88daa944b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabffee0d7e91dab25c7453f55640752b6" id="r_gabffee0d7e91dab25c7453f55640752b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#gabffee0d7e91dab25c7453f55640752b6">mmu_reset_itlb</a> (void)</td></tr>
<tr class="memdesc:gabffee0d7e91dab25c7453f55640752b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset ITLB.  <br /></td></tr>
<tr class="separator:gabffee0d7e91dab25c7453f55640752b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaa1f70d1e92ed042a002b9c3e84222f" id="r_gadaa1f70d1e92ed042a002b9c3e84222f"><td class="memItemLeft" align="right" valign="top">mmu_token_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#gadaa1f70d1e92ed042a002b9c3e84222f">mmu_disable</a> (void)</td></tr>
<tr class="memdesc:gadaa1f70d1e92ed042a002b9c3e84222f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporarily disable MMU address translation.  <br /></td></tr>
<tr class="separator:gadaa1f70d1e92ed042a002b9c3e84222f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33b30063f7fb61a46b267c50eb8438cd" id="r_ga33b30063f7fb61a46b267c50eb8438cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mmu.html#ga33b30063f7fb61a46b267c50eb8438cd">mmu_restore</a> (mmu_token_t token)</td></tr>
<tr class="memdesc:ga33b30063f7fb61a46b267c50eb8438cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore MMU address translation.  <br /></td></tr>
<tr class="separator:ga33b30063f7fb61a46b267c50eb8438cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the SH4's MMU (disabled by default). </p>
<p>Since the software has to handle TLB misses on the SH-4, we have freedom to use any page table format we want (and thus save space), but we must make it quick to access. The SH-4 can address a maximum of 512M of address space per "area", but we only care about one area, so this is the total maximum addressable space. With 4K pages, that works out to 2^17 pages that must be mappable, or 17 bits. We use 18 bits just to be sure (there are a few left over).</p>
<p>Page tables (per-process) are a sparse two-level array. The virtual address space is actually 2^30 bytes, or 2^(30-12)=2^18 pages, so there must be a possibility of having that many page entries per process space. A full page table for a process would be 1M, so this is obviously too big!! Thus the sparse array.</p>
<p>The bottom layer of the page tables consists of a sub-context array for 512 pages, which translates into 2K of storage space. The process then has the possibility of using one or more of the 512 top-level slots. For a very small process (using one page for code/data and one for stack), it should be possible to achieve a page table footprint of one page. The tables can grow from there as necessary.</p>
<p>Virtual addresses are broken up as follows:</p><ul>
<li>Bits 31 - 22 10 bits top-level page directory</li>
<li>Bits 21 - 13 9 bits bottom-level page entry</li>
<li>Bits 11 - 0 Byte index into page </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga1da93d07c858b66f16d8fb8d55bfc309" name="ga1da93d07c858b66f16d8fb8d55bfc309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1da93d07c858b66f16d8fb8d55bfc309">&#9670;&#160;</a></span>MMU_SUB_PAGES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MMU_SUB_PAGES&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of pages in a sub-context. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga85804e94e2c6f22c8d1d1f2c216ba0d1" name="ga85804e94e2c6f22c8d1d1f2c216ba0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85804e94e2c6f22c8d1d1f2c216ba0d1">&#9670;&#160;</a></span>mmu_mapfunc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structmmupage__t.html">mmupage_t</a> *(* mmu_mapfunc_t) (<a class="el" href="structmmucontext__t.html">mmucontext_t</a> *context, int virtpage)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MMU mapping handler. </p>
<p>This type is used for functions that will take over the mapping for the kernel. In general, there shouldn't be much use for taking this over yourself, unless you want to change the size of the page table entries or something of the like.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The context in use. </td></tr>
    <tr><td class="paramname">virtpage</td><td>The virtual page to map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The page table entry, or NULL if none exists. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8c300b842e699577ec52b05215ff497a" name="ga8c300b842e699577ec52b05215ff497a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c300b842e699577ec52b05215ff497a">&#9670;&#160;</a></span>mmu_context_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmmucontext__t.html">mmucontext_t</a> * mmu_context_create </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>asid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new MMU context. </p>
<p>Each process should have exactly one of these, and these should not exist without a process. Since KOS doesn't actually have a process model of its own, that means you will only ever have one of these, if any.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asid</td><td>The address space ID of this process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created context or NULL on fail. </dd></dl>

</div>
</div>
<a id="ga00ee028bb7e383e6a478d9c0bc38e394" name="ga00ee028bb7e383e6a478d9c0bc38e394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00ee028bb7e383e6a478d9c0bc38e394">&#9670;&#160;</a></span>mmu_context_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmu_context_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmmucontext__t.html">mmucontext_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an MMU context when a process is being destroyed. </p>
<p>This function cleans up a MMU context, deallocating any memory its using.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The context to clean up after. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb49f02b9c3421c3db648983eac56b6f" name="gacb49f02b9c3421c3db648983eac56b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb49f02b9c3421c3db648983eac56b6f">&#9670;&#160;</a></span>mmu_copyin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmu_copyin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmmucontext__t.html">mmucontext_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__system__types.html#ga4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>srcaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__system__types.html#ga4b435a49c74bb91f284f075e63416cb6">uint32</a>&#160;</td>
          <td class="paramname"><em>srccnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a chunk of data from a process' address space into a kernel buffer, taking into account page mappings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The context to use. </td></tr>
    <tr><td class="paramname">srcaddr</td><td>Source, in the mapped memory space. </td></tr>
    <tr><td class="paramname">srccnt</td><td>The number of bytes to copy. </td></tr>
    <tr><td class="paramname">buffer</td><td>The kernel buffer to copy into (should be in P1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied (failure causes arch_panic). </dd></dl>

</div>
</div>
<a id="gac159acf73a24f4a7cdada65b31b04616" name="gac159acf73a24f4a7cdada65b31b04616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac159acf73a24f4a7cdada65b31b04616">&#9670;&#160;</a></span>mmu_copyv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmu_copyv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmmucontext__t.html">mmucontext_t</a> *&#160;</td>
          <td class="paramname"><em>context1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structiovec.html">iovec</a> *&#160;</td>
          <td class="paramname"><em>iov1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmmucontext__t.html">mmucontext_t</a> *&#160;</td>
          <td class="paramname"><em>context2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structiovec.html">iovec</a> *&#160;</td>
          <td class="paramname"><em>iov2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a chunk of data from one process' address space to another process' address space, taking into account page mappings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context1</td><td>The source's context. </td></tr>
    <tr><td class="paramname">iov1</td><td>The scatter/gather array to copy from. </td></tr>
    <tr><td class="paramname">iovcnt1</td><td>The number of entries in iov1. </td></tr>
    <tr><td class="paramname">context2</td><td>The destination's context. </td></tr>
    <tr><td class="paramname">iov2</td><td>The scatter/gather array to copy to. </td></tr>
    <tr><td class="paramname">iovcnt2</td><td>The number of entries in iov2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied (failure causes arch_panic). </dd></dl>

</div>
</div>
<a id="gadaa1f70d1e92ed042a002b9c3e84222f" name="gadaa1f70d1e92ed042a002b9c3e84222f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaa1f70d1e92ed042a002b9c3e84222f">&#9670;&#160;</a></span>mmu_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mmu_token_t mmu_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Temporarily disable MMU address translation. </p>
<dl class="section return"><dt>Returns</dt><dd>An opaque token to be passed to <a class="el" href="group__mmu.html#ga33b30063f7fb61a46b267c50eb8438cd" title="Restore MMU address translation.">mmu_restore()</a> </dd></dl>

</div>
</div>
<a id="ga8fea2a954713027b1a67b60380ab41d8" name="ga8fea2a954713027b1a67b60380ab41d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fea2a954713027b1a67b60380ab41d8">&#9670;&#160;</a></span>mmu_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmu_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize MMU support. </p>
<p>Unlike most things in KOS, the MMU is not initialized by a normal startup. This is because for most homebrew, its not needed.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success (no error conditions defined). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac88e46560cb86b0e759c6c51c32b4cd9" name="gac88e46560cb86b0e759c6c51c32b4cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac88e46560cb86b0e759c6c51c32b4cd9">&#9670;&#160;</a></span>mmu_map_get_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mmu.html#ga85804e94e2c6f22c8d1d1f2c216ba0d1">mmu_mapfunc_t</a> mmu_map_get_callback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current mapping function. </p>
<dl class="section return"><dt>Returns</dt><dd>The current function that maps pages. </dd></dl>

</div>
</div>
<a id="ga0fe62887a4c714ac9c7e6db0b7c67c1e" name="ga0fe62887a4c714ac9c7e6db0b7c67c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fe62887a4c714ac9c7e6db0b7c67c1e">&#9670;&#160;</a></span>mmu_map_set_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mmu.html#ga85804e94e2c6f22c8d1d1f2c216ba0d1">mmu_mapfunc_t</a> mmu_map_set_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mmu.html#ga85804e94e2c6f22c8d1d1f2c216ba0d1">mmu_mapfunc_t</a>&#160;</td>
          <td class="paramname"><em>newfunc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new MMU mapping handler. </p>
<p>This function will allow you to set a new function to handle mapping for memory pages. There's not much of a reason to do this unless you really do not like the way KOS handles the page mapping internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newfunc</td><td>The new function to handle mapping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old function that did mapping. </dd></dl>

</div>
</div>
<a id="gaaa18eb0616187816f8168f019db521b8" name="gaaa18eb0616187816f8168f019db521b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa18eb0616187816f8168f019db521b8">&#9670;&#160;</a></span>mmu_page_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmu_page_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmmucontext__t.html">mmucontext_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>virtpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>physpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>share</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dirty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the given virtual page to map to the given physical page. </p>
<p>This implies turning on the "valid" bit. Also sets the other named attributes as specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The context to modify. </td></tr>
    <tr><td class="paramname">virtpage</td><td>The first virtual page to map. </td></tr>
    <tr><td class="paramname">physpage</td><td>The first physical page to map. </td></tr>
    <tr><td class="paramname">count</td><td>The number of sequential pages to map. </td></tr>
    <tr><td class="paramname">prot</td><td>Memory protection for page (see <a class="el" href="group__mmu__prot__values.html">Protection Settings</a>). </td></tr>
    <tr><td class="paramname">cache</td><td>Cache scheme for page (see <a class="el" href="group__mmu__cache__values.html">Cacheability Settings</a>). </td></tr>
    <tr><td class="paramname">share</td><td>Set to 1 to share between processes (meaningless), otherwise set to 0. </td></tr>
    <tr><td class="paramname">dirty</td><td>Set to 1 to mark the page as dirty, otherwise set to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga51602d6eff020251832042618d493ea5" name="ga51602d6eff020251832042618d493ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51602d6eff020251832042618d493ea5">&#9670;&#160;</a></span>mmu_phys_to_virt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmu_phys_to_virt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmmucontext__t.html">mmucontext_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>physpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using the given page tables, translate the physical page ID to a virtual page ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The context to look in. </td></tr>
    <tr><td class="paramname">physpage</td><td>The physical page number to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The virtual page number, or -1 on failure. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__mmu.html#gaa7bc7e2e50dc71075798502ee3f49f62" title="Using the given page tables, translate the virtual page ID to a physical page ID.">mmu_virt_to_phys()</a> </dd></dl>

</div>
</div>
<a id="gabffee0d7e91dab25c7453f55640752b6" name="gabffee0d7e91dab25c7453f55640752b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabffee0d7e91dab25c7453f55640752b6">&#9670;&#160;</a></span>mmu_reset_itlb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmu_reset_itlb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset ITLB. </p>

</div>
</div>
<a id="ga33b30063f7fb61a46b267c50eb8438cd" name="ga33b30063f7fb61a46b267c50eb8438cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33b30063f7fb61a46b267c50eb8438cd">&#9670;&#160;</a></span>mmu_restore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmu_restore </td>
          <td>(</td>
          <td class="paramtype">mmu_token_t&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore MMU address translation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The opaque token obtained from <a class="el" href="group__mmu.html#gadaa1f70d1e92ed042a002b9c3e84222f" title="Temporarily disable MMU address translation.">mmu_disable()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa86f8c70fd4601477a2c6c88daa944b4" name="gaa86f8c70fd4601477a2c6c88daa944b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa86f8c70fd4601477a2c6c88daa944b4">&#9670;&#160;</a></span>mmu_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmu_shutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown MMU support. </p>
<p>Turn off the MMU after it was initialized. You should try to make sure this gets done if you initialize the MMU in your program, so as to play nice with loaders and the like (that will not expect that its on, in general). </p>

</div>
</div>
<a id="ga448c7722206ca064de59cbe2431f349e" name="ga448c7722206ca064de59cbe2431f349e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga448c7722206ca064de59cbe2431f349e">&#9670;&#160;</a></span>mmu_switch_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmu_switch_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmmucontext__t.html">mmucontext_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch to the given context. </p>
<p>This function switches to the given context's address space ID. The context should have already been made current with <a class="el" href="group__mmu.html#ga99345af516a0d915069901fd4d2a8582" title="Set the &quot;current&quot; page tables for TLB handling.">mmu_use_table()</a>. You are responsible for invalidating any caches as necessary, as well as invalidating any stale TLB entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The context to make current. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga99345af516a0d915069901fd4d2a8582" name="ga99345af516a0d915069901fd4d2a8582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99345af516a0d915069901fd4d2a8582">&#9670;&#160;</a></span>mmu_use_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmu_use_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmmucontext__t.html">mmucontext_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the "current" page tables for TLB handling. </p>
<p>This function is useful if you're trying to implement a process model or something of the like on top of KOS. Essentially, this allows you to completely boot the MMU context in use out and replace it with another. You will need to call the <a class="el" href="group__mmu.html#ga448c7722206ca064de59cbe2431f349e" title="Switch to the given context.">mmu_switch_context()</a> function afterwards to set the address space id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The context to make current. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa7bc7e2e50dc71075798502ee3f49f62" name="gaa7bc7e2e50dc71075798502ee3f49f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7bc7e2e50dc71075798502ee3f49f62">&#9670;&#160;</a></span>mmu_virt_to_phys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mmu_virt_to_phys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmmucontext__t.html">mmucontext_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>virtpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using the given page tables, translate the virtual page ID to a physical page ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The context to look in. </td></tr>
    <tr><td class="paramname">virtpage</td><td>The virtual page number to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The physical page number, or -1 on failure. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__mmu.html#ga51602d6eff020251832042618d493ea5" title="Using the given page tables, translate the physical page ID to a virtual page ID.">mmu_phys_to_virt()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
