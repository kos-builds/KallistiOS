<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KallistiOS: Kernel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">KallistiOS<span id="projectnumber">&#160;##version##</span>
   </div>
   <div id="projectbrief">Independent SDK for the Sega Dreamcast</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__kthreads.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Kernel<div class="ingroups"><a class="el" href="group__threading.html">Threading</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>KOS Native Kernel Threading API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:cond_8h" id="r_cond_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cond_8h.html">cond.h</a></td></tr>
<tr class="memdesc:cond_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition variables. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:genwait_8h" id="r_genwait_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="genwait_8h.html">genwait.h</a></td></tr>
<tr class="memdesc:genwait_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic wait system. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:mutex_8h" id="r_mutex_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mutex_8h.html">mutex.h</a></td></tr>
<tr class="memdesc:mutex_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutual exclusion locks. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:once_8h" id="r_once_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="once_8h.html">once.h</a></td></tr>
<tr class="memdesc:once_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic package initialization. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:oneshot__timer_8h" id="r_oneshot__timer_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="oneshot__timer_8h.html">oneshot_timer.h</a></td></tr>
<tr class="memdesc:oneshot__timer_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-shot timer support. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:recursive__lock_8h" id="r_recursive__lock_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="recursive__lock_8h.html">recursive_lock.h</a></td></tr>
<tr class="memdesc:recursive__lock_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for a recursive mutex. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rwsem_8h" id="r_rwsem_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rwsem_8h.html">rwsem.h</a></td></tr>
<tr class="memdesc:rwsem_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition for a reader/writer semaphore. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:sem_8h" id="r_sem_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sem_8h.html">sem.h</a></td></tr>
<tr class="memdesc:sem_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semaphores. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:thread_8h" id="r_thread_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html">thread.h</a></td></tr>
<tr class="memdesc:thread_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threading support. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:tls_8h" id="r_tls_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tls_8h.html">tls.h</a></td></tr>
<tr class="memdesc:tls_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-local storage support. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:worker__thread_8h" id="r_worker__thread_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="worker__thread_8h.html">worker_thread.h</a></td></tr>
<tr class="memdesc:worker__thread_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded worker support. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:spinlock_8h" id="r_spinlock_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spinlock_8h.html">spinlock.h</a></td></tr>
<tr class="memdesc:spinlock_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple locking. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcbhead__t.html">tcbhead_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread Control Block Header.  <a href="structtcbhead__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkthread__t.html">kthread_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure describing one running thread.  <a href="structkthread__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkthread__attr__t.html">kthread_attr_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread creation attributes.  <a href="structkthread__attr__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga07a18c87aee351e96d36e4321437edcf" id="r_ga07a18c87aee351e96d36e4321437edcf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga07a18c87aee351e96d36e4321437edcf">KOS_PID</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga07a18c87aee351e96d36e4321437edcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process ID.  <br /></td></tr>
<tr class="separator:ga07a18c87aee351e96d36e4321437edcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66190d2aecfafef957fa492ce8a8c7f0" id="r_ga66190d2aecfafef957fa492ce8a8c7f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga66190d2aecfafef957fa492ce8a8c7f0">PRIO_MAX</a>&#160;&#160;&#160;4096</td></tr>
<tr class="memdesc:ga66190d2aecfafef957fa492ce8a8c7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal thread priority.  <br /></td></tr>
<tr class="separator:ga66190d2aecfafef957fa492ce8a8c7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6781270983dc22e17a95f21348d6accd" id="r_ga6781270983dc22e17a95f21348d6accd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga6781270983dc22e17a95f21348d6accd">PRIO_DEFAULT</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:ga6781270983dc22e17a95f21348d6accd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default thread priority.  <br /></td></tr>
<tr class="separator:ga6781270983dc22e17a95f21348d6accd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga846238b2c9c889d07dcbe0bfa53c8951" id="r_ga846238b2c9c889d07dcbe0bfa53c8951"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga846238b2c9c889d07dcbe0bfa53c8951">KTHREAD_LABEL_SIZE</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:ga846238b2c9c889d07dcbe0bfa53c8951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a kthread's label.  <br /></td></tr>
<tr class="separator:ga846238b2c9c889d07dcbe0bfa53c8951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9cd59287c639540dbe1fd82c38ba4d2" id="r_gad9cd59287c639540dbe1fd82c38ba4d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#gad9cd59287c639540dbe1fd82c38ba4d2">KTHREAD_PWD_SIZE</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:gad9cd59287c639540dbe1fd82c38ba4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a kthread's current directory.  <br /></td></tr>
<tr class="separator:gad9cd59287c639540dbe1fd82c38ba4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa41caf9ffc4e969b9e6d1218b0f5b0a4" id="r_gaa41caf9ffc4e969b9e6d1218b0f5b0a4"><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#gaa41caf9ffc4e969b9e6d1218b0f5b0a4">kthread_flags_t</a></td></tr>
<tr class="memdesc:gaa41caf9ffc4e969b9e6d1218b0f5b0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel thread flags type.  <br /></td></tr>
<tr class="separator:gaa41caf9ffc4e969b9e6d1218b0f5b0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga8655c45b73db243808d161ab3fab90a7" id="r_ga8655c45b73db243808d161ab3fab90a7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga8655c45b73db243808d161ab3fab90a7">kthread_state_t</a> { <br />
&#160;&#160;<a class="el" href="group__kthreads.html#gga8655c45b73db243808d161ab3fab90a7afb0756b8d0b7dd0cecbe3b0a4cd7c6dd">STATE_ZOMBIE</a> = 0x0000
, <a class="el" href="group__kthreads.html#gga8655c45b73db243808d161ab3fab90a7addfe11c6d06c4e27bd6efc18cc4862a6">STATE_RUNNING</a> = 0x0001
, <a class="el" href="group__kthreads.html#gga8655c45b73db243808d161ab3fab90a7a5ae0bbfe1a737c76e53253b05168b56b">STATE_READY</a> = 0x0002
, <a class="el" href="group__kthreads.html#gga8655c45b73db243808d161ab3fab90a7a66d8f16a4988ddb948cc00bcdefafbb8">STATE_WAIT</a> = 0x0003
, <br />
&#160;&#160;<a class="el" href="group__kthreads.html#gga8655c45b73db243808d161ab3fab90a7a5e09161e3e14f41b526727f69a2e4148">STATE_FINISHED</a> = 0x0004
<br />
 }</td></tr>
<tr class="memdesc:ga8655c45b73db243808d161ab3fab90a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel thread state.  <a href="group__kthreads.html#ga8655c45b73db243808d161ab3fab90a7">More...</a><br /></td></tr>
<tr class="separator:ga8655c45b73db243808d161ab3fab90a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90d0ea4ed54cf85bcae2fbac1b85f52a" id="r_ga90d0ea4ed54cf85bcae2fbac1b85f52a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga90d0ea4ed54cf85bcae2fbac1b85f52a">kthread_mode_t</a> { <a class="el" href="group__kthreads.html#gga90d0ea4ed54cf85bcae2fbac1b85f52aa0ba240fa2bc06b5c053cae161d085592">THD_MODE_NONE</a> = -1
, <a class="el" href="group__kthreads.html#gga90d0ea4ed54cf85bcae2fbac1b85f52aaaeaebfe9ca54bccf7bbd58a277025fbd">THD_MODE_COOP</a> = 0
, <a class="el" href="group__kthreads.html#gga90d0ea4ed54cf85bcae2fbac1b85f52aa5f48609b5402cd0bb37d073f2398d8ab">THD_MODE_PREEMPT</a> = 1
 }</td></tr>
<tr class="memdesc:ga90d0ea4ed54cf85bcae2fbac1b85f52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">kthread mode values  <a href="group__kthreads.html#ga90d0ea4ed54cf85bcae2fbac1b85f52a">More...</a><br /></td></tr>
<tr class="separator:ga90d0ea4ed54cf85bcae2fbac1b85f52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga47e84ffe7caf93ee355fb1b5c41e87d2" id="r_ga47e84ffe7caf93ee355fb1b5c41e87d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga47e84ffe7caf93ee355fb1b5c41e87d2">thd_block_now</a> (<a class="el" href="structirq__context__t.html">irq_context_t</a> *mycxt)</td></tr>
<tr class="memdesc:ga47e84ffe7caf93ee355fb1b5c41e87d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the current thread.  <br /></td></tr>
<tr class="separator:ga47e84ffe7caf93ee355fb1b5c41e87d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga036601c3dfd9d079729a867f691c7251" id="r_ga036601c3dfd9d079729a867f691c7251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structirq__context__t.html">irq_context_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga036601c3dfd9d079729a867f691c7251">thd_choose_new</a> (void)</td></tr>
<tr class="memdesc:ga036601c3dfd9d079729a867f691c7251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a new thread to swap in.  <br /></td></tr>
<tr class="separator:ga036601c3dfd9d079729a867f691c7251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga972488281f7020676ad985cdd4d96ad9" id="r_ga972488281f7020676ad985cdd4d96ad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga972488281f7020676ad985cdd4d96ad9">thd_by_tid</a> (<a class="el" href="group__system__types.html#gadffe598a3ea01dc03e080c77ece14d65">tid_t</a> tid)</td></tr>
<tr class="memdesc:ga972488281f7020676ad985cdd4d96ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a thread ID, locates the thread structure.  <br /></td></tr>
<tr class="separator:ga972488281f7020676ad985cdd4d96ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e70db4ad3ea0a5d97a168beb2b10133" id="r_ga6e70db4ad3ea0a5d97a168beb2b10133"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga6e70db4ad3ea0a5d97a168beb2b10133">thd_add_to_runnable</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *t, bool front_of_line)</td></tr>
<tr class="memdesc:ga6e70db4ad3ea0a5d97a168beb2b10133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a process in the runnable queue.  <br /></td></tr>
<tr class="separator:ga6e70db4ad3ea0a5d97a168beb2b10133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2459a9ed83fed30df5515c46d8c8b32f" id="r_ga2459a9ed83fed30df5515c46d8c8b32f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga2459a9ed83fed30df5515c46d8c8b32f">thd_remove_from_runnable</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:ga2459a9ed83fed30df5515c46d8c8b32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a thread from the runnable queue, if it's there.  <br /></td></tr>
<tr class="separator:ga2459a9ed83fed30df5515c46d8c8b32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78c79e8185667cc332ff2d7a8268fa70" id="r_ga78c79e8185667cc332ff2d7a8268fa70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga78c79e8185667cc332ff2d7a8268fa70">thd_create</a> (bool detach, void *(*routine)(void *param), void *param)</td></tr>
<tr class="memdesc:ga78c79e8185667cc332ff2d7a8268fa70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new thread.  <br /></td></tr>
<tr class="separator:ga78c79e8185667cc332ff2d7a8268fa70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4862dddd62e84e192d7831105555cc1" id="r_gac4862dddd62e84e192d7831105555cc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#gac4862dddd62e84e192d7831105555cc1">thd_create_ex</a> (const <a class="el" href="structkthread__attr__t.html">kthread_attr_t</a> *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a> attr, void *(*routine)(void *param), void *param)</td></tr>
<tr class="memdesc:gac4862dddd62e84e192d7831105555cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new thread with the specified set of attributes.  <br /></td></tr>
<tr class="separator:gac4862dddd62e84e192d7831105555cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46580d9fc434ae5d832d08bdc798f487" id="r_ga46580d9fc434ae5d832d08bdc798f487"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga46580d9fc434ae5d832d08bdc798f487">thd_destroy</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:ga46580d9fc434ae5d832d08bdc798f487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brutally kill the given thread.  <br /></td></tr>
<tr class="separator:ga46580d9fc434ae5d832d08bdc798f487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6cbf2f872e306735a95fffc0439106" id="r_ga1b6cbf2f872e306735a95fffc0439106"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga1b6cbf2f872e306735a95fffc0439106">thd_exit</a> (void *rv) <a class="el" href="group__system__macros.html#ga5b6df4fe38493e14648842364a76075f">__noreturn</a></td></tr>
<tr class="memdesc:ga1b6cbf2f872e306735a95fffc0439106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit the current thread.  <br /></td></tr>
<tr class="separator:ga1b6cbf2f872e306735a95fffc0439106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga314b55cd3cae0c7d22114f4e4d0153fd" id="r_ga314b55cd3cae0c7d22114f4e4d0153fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga314b55cd3cae0c7d22114f4e4d0153fd">thd_schedule</a> (bool front_of_line, uint64_t now)</td></tr>
<tr class="memdesc:ga314b55cd3cae0c7d22114f4e4d0153fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a thread reschedule.  <br /></td></tr>
<tr class="separator:ga314b55cd3cae0c7d22114f4e4d0153fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76c272a52c8f7d805685287aec67ddf1" id="r_ga76c272a52c8f7d805685287aec67ddf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga76c272a52c8f7d805685287aec67ddf1">thd_schedule_next</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:ga76c272a52c8f7d805685287aec67ddf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a given thread to the front of the queue.  <br /></td></tr>
<tr class="separator:ga76c272a52c8f7d805685287aec67ddf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8fa787b9408d6e108ba49097afb8a17" id="r_gae8fa787b9408d6e108ba49097afb8a17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#gae8fa787b9408d6e108ba49097afb8a17">thd_pass</a> (void)</td></tr>
<tr class="memdesc:gae8fa787b9408d6e108ba49097afb8a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw away the current thread's timeslice.  <br /></td></tr>
<tr class="separator:gae8fa787b9408d6e108ba49097afb8a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979dc66b2ad0d2a4b7ab1eeec3d4d0ed" id="r_ga979dc66b2ad0d2a4b7ab1eeec3d4d0ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga979dc66b2ad0d2a4b7ab1eeec3d4d0ed">thd_sleep</a> (unsigned ms)</td></tr>
<tr class="memdesc:ga979dc66b2ad0d2a4b7ab1eeec3d4d0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep for a given number of milliseconds.  <br /></td></tr>
<tr class="separator:ga979dc66b2ad0d2a4b7ab1eeec3d4d0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga763b92de76217ba97aa5f86b3b5791e3" id="r_ga763b92de76217ba97aa5f86b3b5791e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga763b92de76217ba97aa5f86b3b5791e3">thd_set_prio</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd, <a class="el" href="group__system__types.html#ga399ab71ffbe0a6db9d6981a7b4fbc44a">prio_t</a> prio)</td></tr>
<tr class="memdesc:ga763b92de76217ba97aa5f86b3b5791e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a thread's priority value.  <br /></td></tr>
<tr class="separator:ga763b92de76217ba97aa5f86b3b5791e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2882fd7a4d6371ab7d5e2af1195c888" id="r_gaa2882fd7a4d6371ab7d5e2af1195c888"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#gaa2882fd7a4d6371ab7d5e2af1195c888">thd_get_current</a> (void)</td></tr>
<tr class="memdesc:gaa2882fd7a4d6371ab7d5e2af1195c888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current thread's kthread struct.  <br /></td></tr>
<tr class="separator:gaa2882fd7a4d6371ab7d5e2af1195c888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac07d8fb5d1cab6ac36081effb1ff80de" id="r_gac07d8fb5d1cab6ac36081effb1ff80de"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#gac07d8fb5d1cab6ac36081effb1ff80de">thd_get_label</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:gac07d8fb5d1cab6ac36081effb1ff80de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the thread's label.  <br /></td></tr>
<tr class="separator:gac07d8fb5d1cab6ac36081effb1ff80de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf60fbc4829be062daba4f2520f503cd0" id="r_gaf60fbc4829be062daba4f2520f503cd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#gaf60fbc4829be062daba4f2520f503cd0">thd_set_label</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd, const char *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a> label)</td></tr>
<tr class="memdesc:gaf60fbc4829be062daba4f2520f503cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thread's label.  <br /></td></tr>
<tr class="separator:gaf60fbc4829be062daba4f2520f503cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ad0b1c2495f1fdf11df6d7ba38e2620" id="r_ga5ad0b1c2495f1fdf11df6d7ba38e2620"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga5ad0b1c2495f1fdf11df6d7ba38e2620">thd_get_pwd</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:ga5ad0b1c2495f1fdf11df6d7ba38e2620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the thread's current working directory.  <br /></td></tr>
<tr class="separator:ga5ad0b1c2495f1fdf11df6d7ba38e2620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12a497953adc81df5bea7bf50dbd917" id="r_gab12a497953adc81df5bea7bf50dbd917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#gab12a497953adc81df5bea7bf50dbd917">thd_set_pwd</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd, const char *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a> pwd)</td></tr>
<tr class="memdesc:gab12a497953adc81df5bea7bf50dbd917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thread's current working directory.  <br /></td></tr>
<tr class="separator:gab12a497953adc81df5bea7bf50dbd917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94704cdb804720b06e7558d6167e9a51" id="r_ga94704cdb804720b06e7558d6167e9a51"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga94704cdb804720b06e7558d6167e9a51">thd_get_errno</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:ga94704cdb804720b06e7558d6167e9a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the thread errno.  <br /></td></tr>
<tr class="separator:ga94704cdb804720b06e7558d6167e9a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42fb0ef4f8b4901fbb9a515b08db0ff6" id="r_ga42fb0ef4f8b4901fbb9a515b08db0ff6"><td class="memItemLeft" align="right" valign="top">struct _reent *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga42fb0ef4f8b4901fbb9a515b08db0ff6">thd_get_reent</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:ga42fb0ef4f8b4901fbb9a515b08db0ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the thread reent struct.  <br /></td></tr>
<tr class="separator:ga42fb0ef4f8b4901fbb9a515b08db0ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5284a45993b16ea36c23e12e56ddd2bc" id="r_ga5284a45993b16ea36c23e12e56ddd2bc"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga5284a45993b16ea36c23e12e56ddd2bc">thd_get_cpu_time</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:ga5284a45993b16ea36c23e12e56ddd2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the thread's elapsed CPU time.  <br /></td></tr>
<tr class="separator:ga5284a45993b16ea36c23e12e56ddd2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3eb4652a1578c25dd5c6bebe5ddadcb" id="r_gad3eb4652a1578c25dd5c6bebe5ddadcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#gad3eb4652a1578c25dd5c6bebe5ddadcb">thd_set_mode</a> (<a class="el" href="group__kthreads.html#ga90d0ea4ed54cf85bcae2fbac1b85f52a">kthread_mode_t</a> mode) <a class="el" href="group__system__macros.html#ga4e1585cb1b8a465a6a9a702d97bb4ad8">__deprecated</a></td></tr>
<tr class="memdesc:gad3eb4652a1578c25dd5c6bebe5ddadcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change threading modes.  <br /></td></tr>
<tr class="separator:gad3eb4652a1578c25dd5c6bebe5ddadcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga064e68e032ac7b6478142c5806a4eb2c" id="r_ga064e68e032ac7b6478142c5806a4eb2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__kthreads.html#ga90d0ea4ed54cf85bcae2fbac1b85f52a">kthread_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga064e68e032ac7b6478142c5806a4eb2c">thd_get_mode</a> (void) <a class="el" href="group__system__macros.html#ga4e1585cb1b8a465a6a9a702d97bb4ad8">__deprecated</a></td></tr>
<tr class="memdesc:ga064e68e032ac7b6478142c5806a4eb2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the current threading mode.  <br /></td></tr>
<tr class="separator:ga064e68e032ac7b6478142c5806a4eb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12dad87642cf1a5c8190752b0573f812" id="r_ga12dad87642cf1a5c8190752b0573f812"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga12dad87642cf1a5c8190752b0573f812">thd_set_hz</a> (unsigned int hertz)</td></tr>
<tr class="memdesc:ga12dad87642cf1a5c8190752b0573f812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scheduler's frequency.  <br /></td></tr>
<tr class="separator:ga12dad87642cf1a5c8190752b0573f812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49f240a1e9fc3737dfccb4b61635de92" id="r_ga49f240a1e9fc3737dfccb4b61635de92"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga49f240a1e9fc3737dfccb4b61635de92">thd_get_hz</a> (void)</td></tr>
<tr class="memdesc:ga49f240a1e9fc3737dfccb4b61635de92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the scheduler's current frequency.  <br /></td></tr>
<tr class="separator:ga49f240a1e9fc3737dfccb4b61635de92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e1d141b734cf8614afdb11d30ca5575" id="r_ga8e1d141b734cf8614afdb11d30ca5575"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga8e1d141b734cf8614afdb11d30ca5575">thd_join</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd, void **value_ptr)</td></tr>
<tr class="memdesc:ga8e1d141b734cf8614afdb11d30ca5575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a thread to exit.  <br /></td></tr>
<tr class="separator:ga8e1d141b734cf8614afdb11d30ca5575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga724bf784df854173a2b74e71697a62a0" id="r_ga724bf784df854173a2b74e71697a62a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga724bf784df854173a2b74e71697a62a0">thd_detach</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:ga724bf784df854173a2b74e71697a62a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a joinable thread.  <br /></td></tr>
<tr class="separator:ga724bf784df854173a2b74e71697a62a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16573d932033e584af5828f2d2e723a0" id="r_ga16573d932033e584af5828f2d2e723a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga16573d932033e584af5828f2d2e723a0">thd_each</a> (int(*cb)(<a class="el" href="structkthread__t.html">kthread_t</a> *thd, void *user_data), void *data)</td></tr>
<tr class="memdesc:ga16573d932033e584af5828f2d2e723a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate all threads and call the passed callback for each.  <br /></td></tr>
<tr class="separator:ga16573d932033e584af5828f2d2e723a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9c082bca35dc855807f6aa048dd19ba" id="r_gac9c082bca35dc855807f6aa048dd19ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#gac9c082bca35dc855807f6aa048dd19ba">thd_pslist</a> (int(*pf)(const char *fmt,...))</td></tr>
<tr class="memdesc:gac9c082bca35dc855807f6aa048dd19ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a list of all threads using the given print function.  <br /></td></tr>
<tr class="separator:gac9c082bca35dc855807f6aa048dd19ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac60ff417061399c9c9371a2c7354f5d1" id="r_gac60ff417061399c9c9371a2c7354f5d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#gac60ff417061399c9c9371a2c7354f5d1">thd_pslist_queue</a> (int(*pf)(const char *fmt,...))</td></tr>
<tr class="memdesc:gac60ff417061399c9c9371a2c7354f5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a list of all queued threads using the given print function.  <br /></td></tr>
<tr class="separator:gac60ff417061399c9c9371a2c7354f5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga972488281f7020676ad985cdd4d96ad9" id="r_ga972488281f7020676ad985cdd4d96ad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga972488281f7020676ad985cdd4d96ad9">thd_by_tid</a> (<a class="el" href="group__system__types.html#gadffe598a3ea01dc03e080c77ece14d65">tid_t</a> <a class="el" href="structkthread__t.html#a1e683af33bafb9b13eb2d9caf02b14d6">tid</a>)</td></tr>
<tr class="memdesc:ga972488281f7020676ad985cdd4d96ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a thread ID, locates the thread structure.  <br /></td></tr>
<tr class="separator:ga972488281f7020676ad985cdd4d96ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e70db4ad3ea0a5d97a168beb2b10133" id="r_ga6e70db4ad3ea0a5d97a168beb2b10133"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga6e70db4ad3ea0a5d97a168beb2b10133">thd_add_to_runnable</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *t, bool front_of_line)</td></tr>
<tr class="memdesc:ga6e70db4ad3ea0a5d97a168beb2b10133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a process in the runnable queue.  <br /></td></tr>
<tr class="separator:ga6e70db4ad3ea0a5d97a168beb2b10133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2459a9ed83fed30df5515c46d8c8b32f" id="r_ga2459a9ed83fed30df5515c46d8c8b32f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga2459a9ed83fed30df5515c46d8c8b32f">thd_remove_from_runnable</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:ga2459a9ed83fed30df5515c46d8c8b32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a thread from the runnable queue, if it's there.  <br /></td></tr>
<tr class="separator:ga2459a9ed83fed30df5515c46d8c8b32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78c79e8185667cc332ff2d7a8268fa70" id="r_ga78c79e8185667cc332ff2d7a8268fa70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga78c79e8185667cc332ff2d7a8268fa70">thd_create</a> (bool detach, void *(*routine)(void *param), void *param)</td></tr>
<tr class="memdesc:ga78c79e8185667cc332ff2d7a8268fa70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new thread.  <br /></td></tr>
<tr class="separator:ga78c79e8185667cc332ff2d7a8268fa70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4862dddd62e84e192d7831105555cc1" id="r_gac4862dddd62e84e192d7831105555cc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#gac4862dddd62e84e192d7831105555cc1">thd_create_ex</a> (const <a class="el" href="structkthread__attr__t.html">kthread_attr_t</a> *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a> attr, void *(*routine)(void *param), void *param)</td></tr>
<tr class="memdesc:gac4862dddd62e84e192d7831105555cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new thread with the specified set of attributes.  <br /></td></tr>
<tr class="separator:gac4862dddd62e84e192d7831105555cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46580d9fc434ae5d832d08bdc798f487" id="r_ga46580d9fc434ae5d832d08bdc798f487"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga46580d9fc434ae5d832d08bdc798f487">thd_destroy</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:ga46580d9fc434ae5d832d08bdc798f487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brutally kill the given thread.  <br /></td></tr>
<tr class="separator:ga46580d9fc434ae5d832d08bdc798f487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76c272a52c8f7d805685287aec67ddf1" id="r_ga76c272a52c8f7d805685287aec67ddf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga76c272a52c8f7d805685287aec67ddf1">thd_schedule_next</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:ga76c272a52c8f7d805685287aec67ddf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a given thread to the front of the queue.  <br /></td></tr>
<tr class="separator:ga76c272a52c8f7d805685287aec67ddf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga763b92de76217ba97aa5f86b3b5791e3" id="r_ga763b92de76217ba97aa5f86b3b5791e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga763b92de76217ba97aa5f86b3b5791e3">thd_set_prio</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd, <a class="el" href="group__system__types.html#ga399ab71ffbe0a6db9d6981a7b4fbc44a">prio_t</a> <a class="el" href="structkthread__t.html#a83313dc1ac814ea2ee625bc17d1a2398">prio</a>)</td></tr>
<tr class="memdesc:ga763b92de76217ba97aa5f86b3b5791e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a thread's priority value.  <br /></td></tr>
<tr class="separator:ga763b92de76217ba97aa5f86b3b5791e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2882fd7a4d6371ab7d5e2af1195c888" id="r_gaa2882fd7a4d6371ab7d5e2af1195c888"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#gaa2882fd7a4d6371ab7d5e2af1195c888">thd_get_current</a> (void)</td></tr>
<tr class="memdesc:gaa2882fd7a4d6371ab7d5e2af1195c888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current thread's kthread struct.  <br /></td></tr>
<tr class="separator:gaa2882fd7a4d6371ab7d5e2af1195c888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac07d8fb5d1cab6ac36081effb1ff80de" id="r_gac07d8fb5d1cab6ac36081effb1ff80de"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#gac07d8fb5d1cab6ac36081effb1ff80de">thd_get_label</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:gac07d8fb5d1cab6ac36081effb1ff80de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the thread's label.  <br /></td></tr>
<tr class="separator:gac07d8fb5d1cab6ac36081effb1ff80de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf60fbc4829be062daba4f2520f503cd0" id="r_gaf60fbc4829be062daba4f2520f503cd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#gaf60fbc4829be062daba4f2520f503cd0">thd_set_label</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd, const char *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a> <a class="el" href="structkthread__t.html#a536277c2ece6b62ceee8a49c90df97e5">label</a>)</td></tr>
<tr class="memdesc:gaf60fbc4829be062daba4f2520f503cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thread's label.  <br /></td></tr>
<tr class="separator:gaf60fbc4829be062daba4f2520f503cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ad0b1c2495f1fdf11df6d7ba38e2620" id="r_ga5ad0b1c2495f1fdf11df6d7ba38e2620"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga5ad0b1c2495f1fdf11df6d7ba38e2620">thd_get_pwd</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:ga5ad0b1c2495f1fdf11df6d7ba38e2620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the thread's current working directory.  <br /></td></tr>
<tr class="separator:ga5ad0b1c2495f1fdf11df6d7ba38e2620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12a497953adc81df5bea7bf50dbd917" id="r_gab12a497953adc81df5bea7bf50dbd917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#gab12a497953adc81df5bea7bf50dbd917">thd_set_pwd</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd, const char *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a> <a class="el" href="structkthread__t.html#aac3521e4b3523fbbee700d97a97440c3">pwd</a>)</td></tr>
<tr class="memdesc:gab12a497953adc81df5bea7bf50dbd917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thread's current working directory.  <br /></td></tr>
<tr class="separator:gab12a497953adc81df5bea7bf50dbd917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94704cdb804720b06e7558d6167e9a51" id="r_ga94704cdb804720b06e7558d6167e9a51"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga94704cdb804720b06e7558d6167e9a51">thd_get_errno</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:ga94704cdb804720b06e7558d6167e9a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the thread errno.  <br /></td></tr>
<tr class="separator:ga94704cdb804720b06e7558d6167e9a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42fb0ef4f8b4901fbb9a515b08db0ff6" id="r_ga42fb0ef4f8b4901fbb9a515b08db0ff6"><td class="memItemLeft" align="right" valign="top">struct _reent *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga42fb0ef4f8b4901fbb9a515b08db0ff6">thd_get_reent</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:ga42fb0ef4f8b4901fbb9a515b08db0ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the thread reent struct.  <br /></td></tr>
<tr class="separator:ga42fb0ef4f8b4901fbb9a515b08db0ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5284a45993b16ea36c23e12e56ddd2bc" id="r_ga5284a45993b16ea36c23e12e56ddd2bc"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga5284a45993b16ea36c23e12e56ddd2bc">thd_get_cpu_time</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:ga5284a45993b16ea36c23e12e56ddd2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the thread's elapsed CPU time.  <br /></td></tr>
<tr class="separator:ga5284a45993b16ea36c23e12e56ddd2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e1d141b734cf8614afdb11d30ca5575" id="r_ga8e1d141b734cf8614afdb11d30ca5575"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga8e1d141b734cf8614afdb11d30ca5575">thd_join</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd, void **value_ptr)</td></tr>
<tr class="memdesc:ga8e1d141b734cf8614afdb11d30ca5575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a thread to exit.  <br /></td></tr>
<tr class="separator:ga8e1d141b734cf8614afdb11d30ca5575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga724bf784df854173a2b74e71697a62a0" id="r_ga724bf784df854173a2b74e71697a62a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga724bf784df854173a2b74e71697a62a0">thd_detach</a> (<a class="el" href="structkthread__t.html">kthread_t</a> *thd)</td></tr>
<tr class="memdesc:ga724bf784df854173a2b74e71697a62a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a joinable thread.  <br /></td></tr>
<tr class="separator:ga724bf784df854173a2b74e71697a62a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16573d932033e584af5828f2d2e723a0" id="r_ga16573d932033e584af5828f2d2e723a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga16573d932033e584af5828f2d2e723a0">thd_each</a> (int(*cb)(<a class="el" href="structkthread__t.html">kthread_t</a> *thd, void *user_data), void *data)</td></tr>
<tr class="memdesc:ga16573d932033e584af5828f2d2e723a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate all threads and call the passed callback for each.  <br /></td></tr>
<tr class="separator:ga16573d932033e584af5828f2d2e723a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Thread flag values</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Flags for kthread_flags_t</p>
<p>These are possible values for the flags field on the <a class="el" href="structkthread__t.html" title="Structure describing one running thread.">kthread_t</a> structure. These can be ORed together. </p>
</td></tr>
<tr class="memitem:gab7935df2c3df92dde6ccf3dd27a951ee" id="r_gab7935df2c3df92dde6ccf3dd27a951ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#gab7935df2c3df92dde6ccf3dd27a951ee">THD_DEFAULTS</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gab7935df2c3df92dde6ccf3dd27a951ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaults: no flags.  <br /></td></tr>
<tr class="separator:gab7935df2c3df92dde6ccf3dd27a951ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga818485ada164ee2f9e9683fd0086484d" id="r_ga818485ada164ee2f9e9683fd0086484d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga818485ada164ee2f9e9683fd0086484d">THD_USER</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga818485ada164ee2f9e9683fd0086484d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread runs in user mode.  <br /></td></tr>
<tr class="separator:ga818485ada164ee2f9e9683fd0086484d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3719aaf87bedc12f173345a58920a2f2" id="r_ga3719aaf87bedc12f173345a58920a2f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga3719aaf87bedc12f173345a58920a2f2">THD_QUEUED</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga3719aaf87bedc12f173345a58920a2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread is in the run queue.  <br /></td></tr>
<tr class="separator:ga3719aaf87bedc12f173345a58920a2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d01f45ac725636a40f06964c9478530" id="r_ga1d01f45ac725636a40f06964c9478530"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kthreads.html#ga1d01f45ac725636a40f06964c9478530">THD_DETACHED</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ga1d01f45ac725636a40f06964c9478530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread is detached.  <br /></td></tr>
<tr class="separator:ga1d01f45ac725636a40f06964c9478530"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>KOS Native Kernel Threading API. </p>
<p>The thread scheduler itself is a relatively simplistic priority scheduler. There is no provision for priorities to erode over time, so keep that in mind. That practically means that if you have 2 high priority threads that are always runnable and one low priority thread that is always runnable, the low priority thread will never actually run (since it will never get to the front of the run queue because of the high priority threads).</p>
<p>The scheduler supports two distinct types of threads: joinable and detached threads. A joinable thread is one that can return a value to the creating thread (or for that matter, any other thread that wishes to join it). A detached thread is one that is completely detached from the rest of the system and cannot return values by "normal" means. Detached threads automatically clean up all of the internal resources associated with the thread when it exits. Joinable threads, on the other hand, must keep some state available for the ability to return values. To make sure that all memory allocated by the thread's internal structures gets freed, you must either join with the thread (with <a class="el" href="group__kthreads.html#ga8e1d141b734cf8614afdb11d30ca5575" title="Wait for a thread to exit.">thd_join()</a>) or detach it (with <a class="el" href="group__kthreads.html#ga724bf784df854173a2b74e71697a62a0" title="Detach a joinable thread.">thd_detach()</a>). The old KOS threading system only had what would be considered detached threads.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structsemaphore__t.html" title="Semaphore type.">semaphore_t</a>, <a class="el" href="structmutex__t.html" title="Mutual exclusion lock type.">mutex_t</a>, <a class="el" href="once_8h.html#a0a7053da57ccf14871e587a93d168f90" title="Object type backing kthread_once.">kthread_once_t</a>, <a class="el" href="tls_8h.html#aec6736a2ae84b910c077b0e5d42a6882" title="Thread-local storage key type.">kthread_key_t</a>, <a class="el" href="structrw__semaphore__t.html" title="Reader/writer semaphore structure.">rw_semaphore_t</a> </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga07a18c87aee351e96d36e4321437edcf" name="ga07a18c87aee351e96d36e4321437edcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07a18c87aee351e96d36e4321437edcf">&#9670;&#160;</a></span>KOS_PID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KOS_PID&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process ID. </p>
<p>This macro defines the single process ID that encompasses all of KOS and the running application along with all of its threads. </p>

</div>
</div>
<a id="ga846238b2c9c889d07dcbe0bfa53c8951" name="ga846238b2c9c889d07dcbe0bfa53c8951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga846238b2c9c889d07dcbe0bfa53c8951">&#9670;&#160;</a></span>KTHREAD_LABEL_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KTHREAD_LABEL_SIZE&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of a kthread's label. </p>
<p>Maximum number of characters in a thread's label or name (including NULL terminator). </p>

</div>
</div>
<a id="gad9cd59287c639540dbe1fd82c38ba4d2" name="gad9cd59287c639540dbe1fd82c38ba4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9cd59287c639540dbe1fd82c38ba4d2">&#9670;&#160;</a></span>KTHREAD_PWD_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KTHREAD_PWD_SIZE&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of a kthread's current directory. </p>
<p>Maximum number of characters in a thread's current working directory (including NULL terminator). </p>

</div>
</div>
<a id="ga6781270983dc22e17a95f21348d6accd" name="ga6781270983dc22e17a95f21348d6accd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6781270983dc22e17a95f21348d6accd">&#9670;&#160;</a></span>PRIO_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PRIO_DEFAULT&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default thread priority. </p>
<p>Threads are created by default with the priority specified. </p>

</div>
</div>
<a id="ga66190d2aecfafef957fa492ce8a8c7f0" name="ga66190d2aecfafef957fa492ce8a8c7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66190d2aecfafef957fa492ce8a8c7f0">&#9670;&#160;</a></span>PRIO_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PRIO_MAX&#160;&#160;&#160;4096</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximal thread priority. </p>
<p>This macro defines the maximum value for a thread's priority. Note that the larger this number, the lower the priority of the thread. </p>

</div>
</div>
<a id="gab7935df2c3df92dde6ccf3dd27a951ee" name="gab7935df2c3df92dde6ccf3dd27a951ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7935df2c3df92dde6ccf3dd27a951ee">&#9670;&#160;</a></span>THD_DEFAULTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THD_DEFAULTS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defaults: no flags. </p>

</div>
</div>
<a id="ga1d01f45ac725636a40f06964c9478530" name="ga1d01f45ac725636a40f06964c9478530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d01f45ac725636a40f06964c9478530">&#9670;&#160;</a></span>THD_DETACHED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THD_DETACHED&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread is detached. </p>

</div>
</div>
<a id="ga3719aaf87bedc12f173345a58920a2f2" name="ga3719aaf87bedc12f173345a58920a2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3719aaf87bedc12f173345a58920a2f2">&#9670;&#160;</a></span>THD_QUEUED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THD_QUEUED&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread is in the run queue. </p>

</div>
</div>
<a id="ga818485ada164ee2f9e9683fd0086484d" name="ga818485ada164ee2f9e9683fd0086484d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga818485ada164ee2f9e9683fd0086484d">&#9670;&#160;</a></span>THD_USER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THD_USER&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread runs in user mode. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaa41caf9ffc4e969b9e6d1218b0f5b0a4" name="gaa41caf9ffc4e969b9e6d1218b0f5b0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa41caf9ffc4e969b9e6d1218b0f5b0a4">&#9670;&#160;</a></span>kthread_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t <a class="el" href="group__kthreads.html#gaa41caf9ffc4e969b9e6d1218b0f5b0a4">kthread_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel thread flags type. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga90d0ea4ed54cf85bcae2fbac1b85f52a" name="ga90d0ea4ed54cf85bcae2fbac1b85f52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90d0ea4ed54cf85bcae2fbac1b85f52a">&#9670;&#160;</a></span>kthread_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__kthreads.html#ga90d0ea4ed54cf85bcae2fbac1b85f52a">kthread_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>kthread mode values </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Only preemptive scheduling is still supported!</dd></dl>
<p>The threading system will always be in one of the following modes. This represents either pre-emptive scheduling or an un-initialized state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga90d0ea4ed54cf85bcae2fbac1b85f52aa0ba240fa2bc06b5c053cae161d085592" name="gga90d0ea4ed54cf85bcae2fbac1b85f52aa0ba240fa2bc06b5c053cae161d085592"></a>THD_MODE_NONE&#160;</td><td class="fielddoc"><p>Threads not running. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga90d0ea4ed54cf85bcae2fbac1b85f52aaaeaebfe9ca54bccf7bbd58a277025fbd" name="gga90d0ea4ed54cf85bcae2fbac1b85f52aaaeaebfe9ca54bccf7bbd58a277025fbd"></a>THD_MODE_COOP&#160;</td><td class="fielddoc"><p>Cooperative mode. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd></dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga90d0ea4ed54cf85bcae2fbac1b85f52aa5f48609b5402cd0bb37d073f2398d8ab" name="gga90d0ea4ed54cf85bcae2fbac1b85f52aa5f48609b5402cd0bb37d073f2398d8ab"></a>THD_MODE_PREEMPT&#160;</td><td class="fielddoc"><p>Preemptive threading mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga8655c45b73db243808d161ab3fab90a7" name="ga8655c45b73db243808d161ab3fab90a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8655c45b73db243808d161ab3fab90a7">&#9670;&#160;</a></span>kthread_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__kthreads.html#ga8655c45b73db243808d161ab3fab90a7">kthread_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel thread state. </p>
<p>Each thread in the system is in exactly one of this set of states. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8655c45b73db243808d161ab3fab90a7afb0756b8d0b7dd0cecbe3b0a4cd7c6dd" name="gga8655c45b73db243808d161ab3fab90a7afb0756b8d0b7dd0cecbe3b0a4cd7c6dd"></a>STATE_ZOMBIE&#160;</td><td class="fielddoc"><p>Waiting to die. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8655c45b73db243808d161ab3fab90a7addfe11c6d06c4e27bd6efc18cc4862a6" name="gga8655c45b73db243808d161ab3fab90a7addfe11c6d06c4e27bd6efc18cc4862a6"></a>STATE_RUNNING&#160;</td><td class="fielddoc"><p>Process is "current". </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8655c45b73db243808d161ab3fab90a7a5ae0bbfe1a737c76e53253b05168b56b" name="gga8655c45b73db243808d161ab3fab90a7a5ae0bbfe1a737c76e53253b05168b56b"></a>STATE_READY&#160;</td><td class="fielddoc"><p>Ready to be scheduled. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8655c45b73db243808d161ab3fab90a7a66d8f16a4988ddb948cc00bcdefafbb8" name="gga8655c45b73db243808d161ab3fab90a7a66d8f16a4988ddb948cc00bcdefafbb8"></a>STATE_WAIT&#160;</td><td class="fielddoc"><p>Blocked on a genwait. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8655c45b73db243808d161ab3fab90a7a5e09161e3e14f41b526727f69a2e4148" name="gga8655c45b73db243808d161ab3fab90a7a5e09161e3e14f41b526727f69a2e4148"></a>STATE_FINISHED&#160;</td><td class="fielddoc"><p>Finished execution. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6e70db4ad3ea0a5d97a168beb2b10133" name="ga6e70db4ad3ea0a5d97a168beb2b10133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e70db4ad3ea0a5d97a168beb2b10133">&#9670;&#160;</a></span>thd_add_to_runnable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thd_add_to_runnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>front_of_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue a process in the runnable queue. </p>
<p>This function adds a thread to the runnable queue after the process group of the same priority if front_of_line is zero, otherwise queues it at the front of its priority group. Generally, you will not have to do this manually.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The thread to queue. </td></tr>
    <tr><td class="paramname">front_of_line</td><td>Set to true to put this thread in front of other threads of the same priority, false to put it behind the other threads (normal behavior).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga2459a9ed83fed30df5515c46d8c8b32f" title="Removes a thread from the runnable queue, if it&#39;s there.">thd_remove_from_runnable</a> </dd></dl>

</div>
</div>
<a id="ga6e70db4ad3ea0a5d97a168beb2b10133" name="ga6e70db4ad3ea0a5d97a168beb2b10133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e70db4ad3ea0a5d97a168beb2b10133">&#9670;&#160;</a></span>thd_add_to_runnable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void thd_add_to_runnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>front_of_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue a process in the runnable queue. </p>
<p>This function adds a thread to the runnable queue after the process group of the same priority if front_of_line is zero, otherwise queues it at the front of its priority group. Generally, you will not have to do this manually.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The thread to queue. </td></tr>
    <tr><td class="paramname">front_of_line</td><td>Set to true to put this thread in front of other threads of the same priority, false to put it behind the other threads (normal behavior).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga2459a9ed83fed30df5515c46d8c8b32f" title="Removes a thread from the runnable queue, if it&#39;s there.">thd_remove_from_runnable</a> </dd></dl>

</div>
</div>
<a id="ga47e84ffe7caf93ee355fb1b5c41e87d2" name="ga47e84ffe7caf93ee355fb1b5c41e87d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47e84ffe7caf93ee355fb1b5c41e87d2">&#9670;&#160;</a></span>thd_block_now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thd_block_now </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structirq__context__t.html">irq_context_t</a> *&#160;</td>
          <td class="paramname"><em>mycxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block the current thread. </p>
<p>Blocks the calling thread and performs a reschedule as if a context switch timer had been executed. This is useful for, e.g., blocking on sync primitives. The param 'mycxt' should point to the calling thread's context block. This is implemented in arch-specific code.</p>
<p>The meaningfulness of the return value depends on whether the unblocker set a return value or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mycxt</td><td>The IRQ context of the calling thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whatever the unblocker deems necessary to return. </dd></dl>

</div>
</div>
<a id="ga972488281f7020676ad985cdd4d96ad9" name="ga972488281f7020676ad985cdd4d96ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga972488281f7020676ad985cdd4d96ad9">&#9670;&#160;</a></span>thd_by_tid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkthread__t.html">kthread_t</a> * thd_by_tid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__system__types.html#gadffe598a3ea01dc03e080c77ece14d65">tid_t</a>&#160;</td>
          <td class="paramname"><em>tid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a thread ID, locates the thread structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tid</td><td>The thread ID to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The thread on success, NULL on failure. </dd></dl>

</div>
</div>
<a id="ga972488281f7020676ad985cdd4d96ad9" name="ga972488281f7020676ad985cdd4d96ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga972488281f7020676ad985cdd4d96ad9">&#9670;&#160;</a></span>thd_by_tid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkthread__t.html">kthread_t</a> * thd_by_tid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__system__types.html#gadffe598a3ea01dc03e080c77ece14d65">tid_t</a>&#160;</td>
          <td class="paramname"><em>tid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a thread ID, locates the thread structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tid</td><td>The thread ID to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The thread on success, NULL on failure. </dd></dl>

</div>
</div>
<a id="ga036601c3dfd9d079729a867f691c7251" name="ga036601c3dfd9d079729a867f691c7251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga036601c3dfd9d079729a867f691c7251">&#9670;&#160;</a></span>thd_choose_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structirq__context__t.html">irq_context_t</a> * thd_choose_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a new thread to swap in. </p>
<p>This function looks at the state of the system and returns a new thread context to swap in. This is called from <a class="el" href="group__kthreads.html#ga47e84ffe7caf93ee355fb1b5c41e87d2" title="Block the current thread.">thd_block_now()</a> and from the preemptive context switcher. Note that thd_current might be NULL on entering this function, if the caller blocked itself.</p>
<p>It is assumed that by the time this returns, the irq_srt_addr and thd_current will be updated.</p>
<dl class="section return"><dt>Returns</dt><dd>The IRQ context of the thread selected. </dd></dl>

</div>
</div>
<a id="ga78c79e8185667cc332ff2d7a8268fa70" name="ga78c79e8185667cc332ff2d7a8268fa70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78c79e8185667cc332ff2d7a8268fa70">&#9670;&#160;</a></span>thd_create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkthread__t.html">kthread_t</a> * thd_create </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detach</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *param)&#160;</td>
          <td class="paramname"><em>routine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new thread. </p>
<p>This function creates a new kernel thread with default parameters to run the given routine. The thread will terminate and clean up resources when the routine completes if the thread is created detached, otherwise you must join the thread with <a class="el" href="group__kthreads.html#ga8e1d141b734cf8614afdb11d30ca5575" title="Wait for a thread to exit.">thd_join()</a> to clean up after it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">detach</td><td>Set to true to create a detached thread. Set to false to create a joinable thread. </td></tr>
    <tr><td class="paramname">routine</td><td>The function to call in the new thread. </td></tr>
    <tr><td class="paramname">param</td><td>A parameter to pass to the function called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new thread on success, NULL on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#gac4862dddd62e84e192d7831105555cc1" title="Create a new thread with the specified set of attributes.">thd_create_ex</a>, <a class="el" href="group__kthreads.html#ga46580d9fc434ae5d832d08bdc798f487" title="Brutally kill the given thread.">thd_destroy</a> </dd></dl>

</div>
</div>
<a id="ga78c79e8185667cc332ff2d7a8268fa70" name="ga78c79e8185667cc332ff2d7a8268fa70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78c79e8185667cc332ff2d7a8268fa70">&#9670;&#160;</a></span>thd_create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkthread__t.html">kthread_t</a> * thd_create </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detach</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *param)&#160;</td>
          <td class="paramname"><em>routine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new thread. </p>
<p>This function creates a new kernel thread with default parameters to run the given routine. The thread will terminate and clean up resources when the routine completes if the thread is created detached, otherwise you must join the thread with <a class="el" href="group__kthreads.html#ga8e1d141b734cf8614afdb11d30ca5575" title="Wait for a thread to exit.">thd_join()</a> to clean up after it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">detach</td><td>Set to true to create a detached thread. Set to false to create a joinable thread. </td></tr>
    <tr><td class="paramname">routine</td><td>The function to call in the new thread. </td></tr>
    <tr><td class="paramname">param</td><td>A parameter to pass to the function called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new thread on success, NULL on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#gac4862dddd62e84e192d7831105555cc1" title="Create a new thread with the specified set of attributes.">thd_create_ex</a>, <a class="el" href="group__kthreads.html#ga46580d9fc434ae5d832d08bdc798f487" title="Brutally kill the given thread.">thd_destroy</a> </dd></dl>

</div>
</div>
<a id="gac4862dddd62e84e192d7831105555cc1" name="gac4862dddd62e84e192d7831105555cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4862dddd62e84e192d7831105555cc1">&#9670;&#160;</a></span>thd_create_ex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkthread__t.html">kthread_t</a> * thd_create_ex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structkthread__attr__t.html">kthread_attr_t</a> *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *param)&#160;</td>
          <td class="paramname"><em>routine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new thread with the specified set of attributes. </p>
<p>This function creates a new kernel thread with the specified set of parameters to run the given routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>A set of thread attributes for the created thread. Passing NULL will initialize all attributes to their default values. </td></tr>
    <tr><td class="paramname">routine</td><td>The function to call in the new thread. </td></tr>
    <tr><td class="paramname">param</td><td>A parameter to pass to the function called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new thread on success, NULL on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga78c79e8185667cc332ff2d7a8268fa70" title="Create a new thread.">thd_create</a>, <a class="el" href="group__kthreads.html#ga46580d9fc434ae5d832d08bdc798f487" title="Brutally kill the given thread.">thd_destroy</a> </dd></dl>

</div>
</div>
<a id="gac4862dddd62e84e192d7831105555cc1" name="gac4862dddd62e84e192d7831105555cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4862dddd62e84e192d7831105555cc1">&#9670;&#160;</a></span>thd_create_ex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkthread__t.html">kthread_t</a> * thd_create_ex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structkthread__attr__t.html">kthread_attr_t</a> *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *param)&#160;</td>
          <td class="paramname"><em>routine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new thread with the specified set of attributes. </p>
<p>This function creates a new kernel thread with the specified set of parameters to run the given routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>A set of thread attributes for the created thread. Passing NULL will initialize all attributes to their default values. </td></tr>
    <tr><td class="paramname">routine</td><td>The function to call in the new thread. </td></tr>
    <tr><td class="paramname">param</td><td>A parameter to pass to the function called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new thread on success, NULL on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga78c79e8185667cc332ff2d7a8268fa70" title="Create a new thread.">thd_create</a>, <a class="el" href="group__kthreads.html#ga46580d9fc434ae5d832d08bdc798f487" title="Brutally kill the given thread.">thd_destroy</a> </dd></dl>

</div>
</div>
<a id="ga46580d9fc434ae5d832d08bdc798f487" name="ga46580d9fc434ae5d832d08bdc798f487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46580d9fc434ae5d832d08bdc798f487">&#9670;&#160;</a></span>thd_destroy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thd_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Brutally kill the given thread. </p>
<p>This function kills the given thread, removing it from the execution chain, cleaning up thread-local data and other internal structures. In general, you shouldn't call this function at all.</p>
<dl class="section warning"><dt>Warning</dt><dd>You should never call this function on the current thread.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga78c79e8185667cc332ff2d7a8268fa70" title="Create a new thread.">thd_create</a> </dd></dl>

</div>
</div>
<a id="ga46580d9fc434ae5d832d08bdc798f487" name="ga46580d9fc434ae5d832d08bdc798f487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46580d9fc434ae5d832d08bdc798f487">&#9670;&#160;</a></span>thd_destroy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int thd_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Brutally kill the given thread. </p>
<p>This function kills the given thread, removing it from the execution chain, cleaning up thread-local data and other internal structures. In general, you shouldn't call this function at all.</p>
<dl class="section warning"><dt>Warning</dt><dd>You should never call this function on the current thread.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga78c79e8185667cc332ff2d7a8268fa70" title="Create a new thread.">thd_create</a> </dd></dl>

</div>
</div>
<a id="ga724bf784df854173a2b74e71697a62a0" name="ga724bf784df854173a2b74e71697a62a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga724bf784df854173a2b74e71697a62a0">&#9670;&#160;</a></span>thd_detach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int thd_detach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detach a joinable thread. </p>
<p>This function switches the specified thread's mode from THD_MODE_JOINABLE to THD_MODE_DETACHED. This will ensure that the thread cleans up all of its internal resources when it exits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The joinable thread to detach.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or less than 0 if the thread is non-existent or already detached. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga8e1d141b734cf8614afdb11d30ca5575" title="Wait for a thread to exit.">thd_join()</a> </dd></dl>

</div>
</div>
<a id="ga724bf784df854173a2b74e71697a62a0" name="ga724bf784df854173a2b74e71697a62a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga724bf784df854173a2b74e71697a62a0">&#9670;&#160;</a></span>thd_detach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thd_detach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach a joinable thread. </p>
<p>This function switches the specified thread's mode from THD_MODE_JOINABLE to THD_MODE_DETACHED. This will ensure that the thread cleans up all of its internal resources when it exits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The joinable thread to detach.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or less than 0 if the thread is non-existent or already detached. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga8e1d141b734cf8614afdb11d30ca5575" title="Wait for a thread to exit.">thd_join()</a> </dd></dl>

</div>
</div>
<a id="ga16573d932033e584af5828f2d2e723a0" name="ga16573d932033e584af5828f2d2e723a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16573d932033e584af5828f2d2e723a0">&#9670;&#160;</a></span>thd_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int thd_each </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structkthread__t.html">kthread_t</a> *thd, void *user_data)&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate all threads and call the passed callback for each. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The callback to call for each thread. If a nonzero value is returned, iteration ceases immediately. </td></tr>
    <tr><td class="paramname">data</td><td>User data to be passed to the callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>or the first nonzero value returned by <code>cb</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#gac9c082bca35dc855807f6aa048dd19ba" title="Print a list of all threads using the given print function.">thd_pslist</a> </dd></dl>

</div>
</div>
<a id="ga16573d932033e584af5828f2d2e723a0" name="ga16573d932033e584af5828f2d2e723a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16573d932033e584af5828f2d2e723a0">&#9670;&#160;</a></span>thd_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thd_each </td>
          <td>(</td>
          <td class="paramtype">int(*)(<a class="el" href="structkthread__t.html">kthread_t</a> *thd, void *user_data)&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate all threads and call the passed callback for each. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The callback to call for each thread. If a nonzero value is returned, iteration ceases immediately. </td></tr>
    <tr><td class="paramname">data</td><td>User data to be passed to the callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>or the first nonzero value returned by <code>cb</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#gac9c082bca35dc855807f6aa048dd19ba" title="Print a list of all threads using the given print function.">thd_pslist</a> </dd></dl>

</div>
</div>
<a id="ga1b6cbf2f872e306735a95fffc0439106" name="ga1b6cbf2f872e306735a95fffc0439106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b6cbf2f872e306735a95fffc0439106">&#9670;&#160;</a></span>thd_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thd_exit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit the current thread. </p>
<p>This function ends the execution of the current thread, removing it from all execution queues. This function will never return to the thread. Returning from the thread's function is equivalent to calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rv</td><td>The return value of the thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5284a45993b16ea36c23e12e56ddd2bc" name="ga5284a45993b16ea36c23e12e56ddd2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5284a45993b16ea36c23e12e56ddd2bc">&#9670;&#160;</a></span>thd_get_cpu_time() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t thd_get_cpu_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the thread's elapsed CPU time. </p>
<p>Returns the amount of active CPU time the thread has consumed in nanoseconds.</p>
<dl class="section warning"><dt>Warning</dt><dd>The implementation uses <a class="el" href="group__perf__counters__timer.html#ga358fcfefcb2d36710d6cfeb7c97ff77f" title="Gets elapsed CPU time (in nanoseconds)">perf_cntr_timer_ns()</a> internally when maintaining this CPU time, so disabling or clearing the nanosecond timer will interfere with this time keeping.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thead to retrieve the CPU time for</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Total</td><td>utilized CPU time in nanoseconds OR 0 if the nanosecond timer of the performance counters has been disturbed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5284a45993b16ea36c23e12e56ddd2bc" name="ga5284a45993b16ea36c23e12e56ddd2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5284a45993b16ea36c23e12e56ddd2bc">&#9670;&#160;</a></span>thd_get_cpu_time() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t thd_get_cpu_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the thread's elapsed CPU time. </p>
<p>Returns the amount of active CPU time the thread has consumed in nanoseconds.</p>
<dl class="section warning"><dt>Warning</dt><dd>The implementation uses <a class="el" href="group__perf__counters__timer.html#ga358fcfefcb2d36710d6cfeb7c97ff77f" title="Gets elapsed CPU time (in nanoseconds)">perf_cntr_timer_ns()</a> internally when maintaining this CPU time, so disabling or clearing the nanosecond timer will interfere with this time keeping.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thead to retrieve the CPU time for</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Total</td><td>utilized CPU time in nanoseconds OR 0 if the nanosecond timer of the performance counters has been disturbed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa2882fd7a4d6371ab7d5e2af1195c888" name="gaa2882fd7a4d6371ab7d5e2af1195c888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2882fd7a4d6371ab7d5e2af1195c888">&#9670;&#160;</a></span>thd_get_current() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkthread__t.html">kthread_t</a> * thd_get_current </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the current thread's kthread struct. </p>
<dl class="section return"><dt>Returns</dt><dd>The current thread's structure. </dd></dl>

</div>
</div>
<a id="gaa2882fd7a4d6371ab7d5e2af1195c888" name="gaa2882fd7a4d6371ab7d5e2af1195c888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2882fd7a4d6371ab7d5e2af1195c888">&#9670;&#160;</a></span>thd_get_current() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkthread__t.html">kthread_t</a> * thd_get_current </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the current thread's kthread struct. </p>
<dl class="section return"><dt>Returns</dt><dd>The current thread's structure. </dd></dl>

</div>
</div>
<a id="ga94704cdb804720b06e7558d6167e9a51" name="ga94704cdb804720b06e7558d6167e9a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94704cdb804720b06e7558d6167e9a51">&#9670;&#160;</a></span>thd_get_errno() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * thd_get_errno </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a pointer to the thread errno. </p>
<p>This function retrieves a pointer to the errno value for the thread. You should generally just use the errno variable to access this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to retrieve from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the thread's errno. </dd></dl>

</div>
</div>
<a id="ga94704cdb804720b06e7558d6167e9a51" name="ga94704cdb804720b06e7558d6167e9a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94704cdb804720b06e7558d6167e9a51">&#9670;&#160;</a></span>thd_get_errno() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int * thd_get_errno </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a pointer to the thread errno. </p>
<p>This function retrieves a pointer to the errno value for the thread. You should generally just use the errno variable to access this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to retrieve from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the thread's errno. </dd></dl>

</div>
</div>
<a id="ga49f240a1e9fc3737dfccb4b61635de92" name="ga49f240a1e9fc3737dfccb4b61635de92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49f240a1e9fc3737dfccb4b61635de92">&#9670;&#160;</a></span>thd_get_hz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned thd_get_hz </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the scheduler's current frequency. </p>
<p>Queries the scheduler for its interrupt frequency in hertz.</p>
<dl class="section return"><dt>Returns</dt><dd>Scheduler frequency in hertz.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga12dad87642cf1a5c8190752b0573f812" title="Set the scheduler&#39;s frequency.">thd_set_hz()</a>, <a class="el" href="group__arch.html#ga8489802eaedf42fdb5f2ce1708eaffa2" title="Scheduler interrupt frequency.">HZ</a> </dd></dl>

</div>
</div>
<a id="gac07d8fb5d1cab6ac36081effb1ff80de" name="gac07d8fb5d1cab6ac36081effb1ff80de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac07d8fb5d1cab6ac36081effb1ff80de">&#9670;&#160;</a></span>thd_get_label() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * thd_get_label </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the thread's label. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to retrieve from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The human-readable label of the thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#gaf60fbc4829be062daba4f2520f503cd0" title="Set the thread&#39;s label.">thd_set_label</a> </dd></dl>

</div>
</div>
<a id="gac07d8fb5d1cab6ac36081effb1ff80de" name="gac07d8fb5d1cab6ac36081effb1ff80de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac07d8fb5d1cab6ac36081effb1ff80de">&#9670;&#160;</a></span>thd_get_label() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * thd_get_label </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the thread's label. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to retrieve from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The human-readable label of the thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#gaf60fbc4829be062daba4f2520f503cd0" title="Set the thread&#39;s label.">thd_set_label</a> </dd></dl>

</div>
</div>
<a id="ga064e68e032ac7b6478142c5806a4eb2c" name="ga064e68e032ac7b6478142c5806a4eb2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga064e68e032ac7b6478142c5806a4eb2c">&#9670;&#160;</a></span>thd_get_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__kthreads.html#ga90d0ea4ed54cf85bcae2fbac1b85f52a">kthread_mode_t</a> thd_get_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the current threading mode. </p>
<p>With preemptive threading being the only mode.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>This is now deprecated.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The current mode of the threading system.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#gad3eb4652a1578c25dd5c6bebe5ddadcb" title="Change threading modes.">thd_set_mode</a> </dd></dl>

</div>
</div>
<a id="ga5ad0b1c2495f1fdf11df6d7ba38e2620" name="ga5ad0b1c2495f1fdf11df6d7ba38e2620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ad0b1c2495f1fdf11df6d7ba38e2620">&#9670;&#160;</a></span>thd_get_pwd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * thd_get_pwd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the thread's current working directory. </p>
<p>This function retrieves the working directory of a thread. Generally, you will want to use either <a class="el" href="group__vfs__generic.html#ga477e888921c9c8386eb001087037bb69" title="Get the current working directory of the running thread.">fs_getwd()</a> or one of the standard C functions for doing this, but this is here in case you need it when the thread isn't active for some reason.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to retrieve from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The thread's working directory.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>thd_set_pd </dd></dl>

</div>
</div>
<a id="ga5ad0b1c2495f1fdf11df6d7ba38e2620" name="ga5ad0b1c2495f1fdf11df6d7ba38e2620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ad0b1c2495f1fdf11df6d7ba38e2620">&#9670;&#160;</a></span>thd_get_pwd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * thd_get_pwd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the thread's current working directory. </p>
<p>This function retrieves the working directory of a thread. Generally, you will want to use either <a class="el" href="group__vfs__generic.html#ga477e888921c9c8386eb001087037bb69" title="Get the current working directory of the running thread.">fs_getwd()</a> or one of the standard C functions for doing this, but this is here in case you need it when the thread isn't active for some reason.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to retrieve from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The thread's working directory.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>thd_set_pd </dd></dl>

</div>
</div>
<a id="ga42fb0ef4f8b4901fbb9a515b08db0ff6" name="ga42fb0ef4f8b4901fbb9a515b08db0ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42fb0ef4f8b4901fbb9a515b08db0ff6">&#9670;&#160;</a></span>thd_get_reent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct _reent * thd_get_reent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a pointer to the thread reent struct. </p>
<p>This function is used to retrieve some internal state that is used by newlib to provide a reentrant libc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to retrieve from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The thread's reent struct. </dd></dl>

</div>
</div>
<a id="ga42fb0ef4f8b4901fbb9a515b08db0ff6" name="ga42fb0ef4f8b4901fbb9a515b08db0ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42fb0ef4f8b4901fbb9a515b08db0ff6">&#9670;&#160;</a></span>thd_get_reent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct _reent * thd_get_reent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a pointer to the thread reent struct. </p>
<p>This function is used to retrieve some internal state that is used by newlib to provide a reentrant libc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to retrieve from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The thread's reent struct. </dd></dl>

</div>
</div>
<a id="ga8e1d141b734cf8614afdb11d30ca5575" name="ga8e1d141b734cf8614afdb11d30ca5575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e1d141b734cf8614afdb11d30ca5575">&#9670;&#160;</a></span>thd_join() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thd_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>value_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a thread to exit. </p>
<p>This function "joins" a joinable thread. This means effectively that the calling thread blocks until the speified thread completes execution. It is invalid to join a detached thread, only joinable threads may be joined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The joinable thread to join. </td></tr>
    <tr><td class="paramname">value_ptr</td><td>A pointer to storage for the thread's return value, or NULL if you don't care about it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or less than 0 if the thread is non-existent or not joinable.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga724bf784df854173a2b74e71697a62a0" title="Detach a joinable thread.">thd_detach</a> </dd></dl>

</div>
</div>
<a id="ga8e1d141b734cf8614afdb11d30ca5575" name="ga8e1d141b734cf8614afdb11d30ca5575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e1d141b734cf8614afdb11d30ca5575">&#9670;&#160;</a></span>thd_join() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int thd_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>value_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for a thread to exit. </p>
<p>This function "joins" a joinable thread. This means effectively that the calling thread blocks until the speified thread completes execution. It is invalid to join a detached thread, only joinable threads may be joined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The joinable thread to join. </td></tr>
    <tr><td class="paramname">value_ptr</td><td>A pointer to storage for the thread's return value, or NULL if you don't care about it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or less than 0 if the thread is non-existent or not joinable.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga724bf784df854173a2b74e71697a62a0" title="Detach a joinable thread.">thd_detach</a> </dd></dl>

</div>
</div>
<a id="gae8fa787b9408d6e108ba49097afb8a17" name="gae8fa787b9408d6e108ba49097afb8a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8fa787b9408d6e108ba49097afb8a17">&#9670;&#160;</a></span>thd_pass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thd_pass </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throw away the current thread's timeslice. </p>
<p>This function manually yields the current thread's timeslice to the system, forcing a reschedule to occur. </p>

</div>
</div>
<a id="gac9c082bca35dc855807f6aa048dd19ba" name="gac9c082bca35dc855807f6aa048dd19ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9c082bca35dc855807f6aa048dd19ba">&#9670;&#160;</a></span>thd_pslist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thd_pslist </td>
          <td>(</td>
          <td class="paramtype">int(*)(const char *fmt,...)&#160;</td>
          <td class="paramname"><em>pf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a list of all threads using the given print function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pf</td><td>The printf-like function to print with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#gac60ff417061399c9c9371a2c7354f5d1" title="Print a list of all queued threads using the given print function.">thd_pslist_queue</a> </dd></dl>

</div>
</div>
<a id="gac60ff417061399c9c9371a2c7354f5d1" name="gac60ff417061399c9c9371a2c7354f5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac60ff417061399c9c9371a2c7354f5d1">&#9670;&#160;</a></span>thd_pslist_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thd_pslist_queue </td>
          <td>(</td>
          <td class="paramtype">int(*)(const char *fmt,...)&#160;</td>
          <td class="paramname"><em>pf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a list of all queued threads using the given print function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pf</td><td>The printf-like function to print with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#gac9c082bca35dc855807f6aa048dd19ba" title="Print a list of all threads using the given print function.">thd_pslist</a> </dd></dl>

</div>
</div>
<a id="ga2459a9ed83fed30df5515c46d8c8b32f" name="ga2459a9ed83fed30df5515c46d8c8b32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2459a9ed83fed30df5515c46d8c8b32f">&#9670;&#160;</a></span>thd_remove_from_runnable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thd_remove_from_runnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a thread from the runnable queue, if it's there. </p>
<p>This function removes a thread from the runnable queue, if it is currently in that queue. Generally, you shouldn't have to do this manually, as waiting on synchronization primitives and the like will do this for you if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to remove from the runnable queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success, or if the thread isn't runnable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga6e70db4ad3ea0a5d97a168beb2b10133" title="Enqueue a process in the runnable queue.">thd_add_to_runnable</a> </dd></dl>

</div>
</div>
<a id="ga2459a9ed83fed30df5515c46d8c8b32f" name="ga2459a9ed83fed30df5515c46d8c8b32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2459a9ed83fed30df5515c46d8c8b32f">&#9670;&#160;</a></span>thd_remove_from_runnable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int thd_remove_from_runnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a thread from the runnable queue, if it's there. </p>
<p>This function removes a thread from the runnable queue, if it is currently in that queue. Generally, you shouldn't have to do this manually, as waiting on synchronization primitives and the like will do this for you if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to remove from the runnable queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success, or if the thread isn't runnable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga6e70db4ad3ea0a5d97a168beb2b10133" title="Enqueue a process in the runnable queue.">thd_add_to_runnable</a> </dd></dl>

</div>
</div>
<a id="ga314b55cd3cae0c7d22114f4e4d0153fd" name="ga314b55cd3cae0c7d22114f4e4d0153fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga314b55cd3cae0c7d22114f4e4d0153fd">&#9670;&#160;</a></span>thd_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thd_schedule </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>front_of_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>now</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force a thread reschedule. </p>
<p>This function is the thread scheduler, and is generally called from a timer interrupt. You will most likely never have a reason to call this function directly.</p>
<p>For most cases, you'll want to set front_of_line to zero, but read the comments in kernel/thread/thread.c for more info, especially if you need to guarantee low latencies. This function just updates irq_srt_addr and thd_current. Set 'now' to non-zero if you want to use a particular system time for checking timeouts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">front_of_line</td><td>Set to false, unless you have a good reason not to. </td></tr>
    <tr><td class="paramname">now</td><td>Set to 0, unless you have a good reason not to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga76c272a52c8f7d805685287aec67ddf1" title="Force a given thread to the front of the queue.">thd_schedule_next</a> </dd></dl>

</div>
</div>
<a id="ga76c272a52c8f7d805685287aec67ddf1" name="ga76c272a52c8f7d805685287aec67ddf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76c272a52c8f7d805685287aec67ddf1">&#9670;&#160;</a></span>thd_schedule_next() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void thd_schedule_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force a given thread to the front of the queue. </p>
<p>This function promotes the given thread to be the next one that will be swapped in by the scheduler. This function is only callable inside an interrupt context (it simply returns otherwise).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to schedule next. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga76c272a52c8f7d805685287aec67ddf1" name="ga76c272a52c8f7d805685287aec67ddf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76c272a52c8f7d805685287aec67ddf1">&#9670;&#160;</a></span>thd_schedule_next() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thd_schedule_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force a given thread to the front of the queue. </p>
<p>This function promotes the given thread to be the next one that will be swapped in by the scheduler. This function is only callable inside an interrupt context (it simply returns otherwise).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to schedule next. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga12dad87642cf1a5c8190752b0573f812" name="ga12dad87642cf1a5c8190752b0573f812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12dad87642cf1a5c8190752b0573f812">&#9670;&#160;</a></span>thd_set_hz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thd_set_hz </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>hertz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the scheduler's frequency. </p>
<p>Sets the frequency of the scheduler interrupts in hertz.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hertz</td><td>The new frequency in hertz (1-1000)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>The frequency was updated successfully. </td></tr>
    <tr><td class="paramname">-1</td><td><code>hertz</code> is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga49f240a1e9fc3737dfccb4b61635de92" title="Fetch the scheduler&#39;s current frequency.">thd_get_hz()</a>, <a class="el" href="group__arch.html#ga8489802eaedf42fdb5f2ce1708eaffa2" title="Scheduler interrupt frequency.">HZ</a> </dd></dl>

</div>
</div>
<a id="gaf60fbc4829be062daba4f2520f503cd0" name="gaf60fbc4829be062daba4f2520f503cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf60fbc4829be062daba4f2520f503cd0">&#9670;&#160;</a></span>thd_set_label() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void thd_set_label </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a>&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the thread's label. </p>
<p>This function sets the label of a thread, which is simply a human-readable string that is used to identify the thread. These labels aren't used for anything internally, and you can give them any label you want. These are mainly seen in the printouts from <a class="el" href="group__kthreads.html#gac9c082bca35dc855807f6aa048dd19ba" title="Print a list of all threads using the given print function.">thd_pslist()</a> or <a class="el" href="group__kthreads.html#gac60ff417061399c9c9371a2c7354f5d1" title="Print a list of all queued threads using the given print function.">thd_pslist_queue()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to set the label of. </td></tr>
    <tr><td class="paramname">label</td><td>The string to set as the label.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#gac07d8fb5d1cab6ac36081effb1ff80de" title="Retrieve the thread&#39;s label.">thd_get_label</a> </dd></dl>

</div>
</div>
<a id="gaf60fbc4829be062daba4f2520f503cd0" name="gaf60fbc4829be062daba4f2520f503cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf60fbc4829be062daba4f2520f503cd0">&#9670;&#160;</a></span>thd_set_label() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thd_set_label </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a>&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the thread's label. </p>
<p>This function sets the label of a thread, which is simply a human-readable string that is used to identify the thread. These labels aren't used for anything internally, and you can give them any label you want. These are mainly seen in the printouts from <a class="el" href="group__kthreads.html#gac9c082bca35dc855807f6aa048dd19ba" title="Print a list of all threads using the given print function.">thd_pslist()</a> or <a class="el" href="group__kthreads.html#gac60ff417061399c9c9371a2c7354f5d1" title="Print a list of all queued threads using the given print function.">thd_pslist_queue()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to set the label of. </td></tr>
    <tr><td class="paramname">label</td><td>The string to set as the label.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#gac07d8fb5d1cab6ac36081effb1ff80de" title="Retrieve the thread&#39;s label.">thd_get_label</a> </dd></dl>

</div>
</div>
<a id="gad3eb4652a1578c25dd5c6bebe5ddadcb" name="gad3eb4652a1578c25dd5c6bebe5ddadcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3eb4652a1578c25dd5c6bebe5ddadcb">&#9670;&#160;</a></span>thd_set_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thd_set_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__kthreads.html#ga90d0ea4ed54cf85bcae2fbac1b85f52a">kthread_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change threading modes. </p>
<p>This function changes the current threading mode of the system. With preemptive threading being the only mode.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>This is now deprecated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>One of the THD_MODE values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old mode of the threading system.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga064e68e032ac7b6478142c5806a4eb2c" title="Fetch the current threading mode.">thd_get_mode</a> </dd></dl>

</div>
</div>
<a id="ga763b92de76217ba97aa5f86b3b5791e3" name="ga763b92de76217ba97aa5f86b3b5791e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga763b92de76217ba97aa5f86b3b5791e3">&#9670;&#160;</a></span>thd_set_prio() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int thd_set_prio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__system__types.html#ga399ab71ffbe0a6db9d6981a7b4fbc44a">prio_t</a>&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a thread's priority value. </p>
<p>This function is used to change the priority value of a thread. If the thread is scheduled already, it will be rescheduled with the new priority value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to change the priority of. </td></tr>
    <tr><td class="paramname">prio</td><td>The priority value to assign to the thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>thd is NULL. </td></tr>
    <tr><td class="paramname">-2</td><td>prio requested was out of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga763b92de76217ba97aa5f86b3b5791e3" name="ga763b92de76217ba97aa5f86b3b5791e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga763b92de76217ba97aa5f86b3b5791e3">&#9670;&#160;</a></span>thd_set_prio() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thd_set_prio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__system__types.html#ga399ab71ffbe0a6db9d6981a7b4fbc44a">prio_t</a>&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a thread's priority value. </p>
<p>This function is used to change the priority value of a thread. If the thread is scheduled already, it will be rescheduled with the new priority value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to change the priority of. </td></tr>
    <tr><td class="paramname">prio</td><td>The priority value to assign to the thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>thd is NULL. </td></tr>
    <tr><td class="paramname">-2</td><td>prio requested was out of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab12a497953adc81df5bea7bf50dbd917" name="gab12a497953adc81df5bea7bf50dbd917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab12a497953adc81df5bea7bf50dbd917">&#9670;&#160;</a></span>thd_set_pwd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void thd_set_pwd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a>&#160;</td>
          <td class="paramname"><em>pwd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the thread's current working directory. </p>
<p>This function will set the working directory of a thread. Generally, you will want to use either <a class="el" href="group__vfs__generic.html#ga2c3dac0f0cf6dbc0c77ea1f1b567a3ca" title="Change the current working directory of the current thread.">fs_chdir()</a> or the standard C chdir() function to do this, but this is here in case you need to do it while the thread isn't active for some reason.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to set the working directory of. </td></tr>
    <tr><td class="paramname">pwd</td><td>The directory to set as active.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga5ad0b1c2495f1fdf11df6d7ba38e2620" title="Retrieve the thread&#39;s current working directory.">thd_get_pwd</a> </dd></dl>

</div>
</div>
<a id="gab12a497953adc81df5bea7bf50dbd917" name="gab12a497953adc81df5bea7bf50dbd917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab12a497953adc81df5bea7bf50dbd917">&#9670;&#160;</a></span>thd_set_pwd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thd_set_pwd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a>&#160;</td>
          <td class="paramname"><em>pwd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the thread's current working directory. </p>
<p>This function will set the working directory of a thread. Generally, you will want to use either <a class="el" href="group__vfs__generic.html#ga2c3dac0f0cf6dbc0c77ea1f1b567a3ca" title="Change the current working directory of the current thread.">fs_chdir()</a> or the standard C chdir() function to do this, but this is here in case you need to do it while the thread isn't active for some reason.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to set the working directory of. </td></tr>
    <tr><td class="paramname">pwd</td><td>The directory to set as active.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kthreads.html#ga5ad0b1c2495f1fdf11df6d7ba38e2620" title="Retrieve the thread&#39;s current working directory.">thd_get_pwd</a> </dd></dl>

</div>
</div>
<a id="ga979dc66b2ad0d2a4b7ab1eeec3d4d0ed" name="ga979dc66b2ad0d2a4b7ab1eeec3d4d0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga979dc66b2ad0d2a4b7ab1eeec3d4d0ed">&#9670;&#160;</a></span>thd_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thd_sleep </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleep for a given number of milliseconds. </p>
<p>This function puts the current thread to sleep for the specified amount of time. The thread will be removed from the runnable queue until the given number of milliseconds passes. That is to say that the thread will sleep for at least the given number of milliseconds. If another thread is running, it will likely sleep longer.</p>
<dl class="section note"><dt>Note</dt><dd>When <code>ms</code> is given a value of <code>0</code>, this is equivalent to <a class="el" href="group__kthreads.html#gae8fa787b9408d6e108ba49097afb8a17" title="Throw away the current thread&#39;s timeslice.">thd_pass()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>The number of milliseconds to sleep. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
