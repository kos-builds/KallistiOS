<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KallistiOS: C11</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">KallistiOS<span id="projectnumber">&#160;##version##</span>
   </div>
   <div id="projectbrief">Independent SDK for the Sega Dreamcast</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__threading__c11.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">C11<div class="ingroups"><a class="el" href="group__threading.html">Threading</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>C11 Threading APIs.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:threads_8h" id="r_threads_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="threads_8h.html">threads.h</a></td></tr>
<tr class="memdesc:threads_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">C11 Threading API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga0eeb41bf239112f98df3d9f644d48f6e" id="r_ga0eeb41bf239112f98df3d9f644d48f6e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga0eeb41bf239112f98df3d9f644d48f6e">ONCE_FLAG_INIT</a>&#160;&#160;&#160;<a class="el" href="once_8h.html#ab7edaf6616245c7d5a24e8d6725f249a">KTHREAD_ONCE_INIT</a></td></tr>
<tr class="memdesc:ga0eeb41bf239112f98df3d9f644d48f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to initialize a once_flag object.  <br /></td></tr>
<tr class="separator:ga0eeb41bf239112f98df3d9f644d48f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11de84b15b6b59861b4366a192aadd58" id="r_ga11de84b15b6b59861b4366a192aadd58"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga11de84b15b6b59861b4366a192aadd58">TSS_DTOR_ITERATIONS</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga11de84b15b6b59861b4366a192aadd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations over TSS destructors.  <br /></td></tr>
<tr class="separator:ga11de84b15b6b59861b4366a192aadd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0f8ad63f262d12b359f6cfd45c492963" id="r_ga0f8ad63f262d12b359f6cfd45c492963"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="once_8h.html#a0a7053da57ccf14871e587a93d168f90">kthread_once_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga0f8ad63f262d12b359f6cfd45c492963">once_flag</a></td></tr>
<tr class="memdesc:ga0f8ad63f262d12b359f6cfd45c492963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object type backing call_once.  <br /></td></tr>
<tr class="separator:ga0f8ad63f262d12b359f6cfd45c492963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56f6590fbffa7b15263d532fd9640ee5" id="r_ga56f6590fbffa7b15263d532fd9640ee5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structmutex__t.html">mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a></td></tr>
<tr class="memdesc:ga56f6590fbffa7b15263d532fd9640ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">C11 mutual exclusion lock type.  <br /></td></tr>
<tr class="separator:ga56f6590fbffa7b15263d532fd9640ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a8258f951bd19a6dcedbd433edb4dd" id="r_ga11a8258f951bd19a6dcedbd433edb4dd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcondvar__t.html">condvar_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga11a8258f951bd19a6dcedbd433edb4dd">cnd_t</a></td></tr>
<tr class="memdesc:ga11a8258f951bd19a6dcedbd433edb4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">C11 condition variable type.  <br /></td></tr>
<tr class="separator:ga11a8258f951bd19a6dcedbd433edb4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa061fe1137b02e69f5b97ab32d9fa587" id="r_gaa061fe1137b02e69f5b97ab32d9fa587"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structkthread__t.html">kthread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gaa061fe1137b02e69f5b97ab32d9fa587">thrd_t</a></td></tr>
<tr class="memdesc:gaa061fe1137b02e69f5b97ab32d9fa587"><td class="mdescLeft">&#160;</td><td class="mdescRight">C11 thread identifier type.  <br /></td></tr>
<tr class="separator:gaa061fe1137b02e69f5b97ab32d9fa587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga147516955219e436959e755b082eafe1" id="r_ga147516955219e436959e755b082eafe1"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga147516955219e436959e755b082eafe1">thrd_start_t</a>) (void *)</td></tr>
<tr class="memdesc:ga147516955219e436959e755b082eafe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">C11 thread start function type.  <br /></td></tr>
<tr class="separator:ga147516955219e436959e755b082eafe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab270b39c6978f0048ffc583e82528b83" id="r_gab270b39c6978f0048ffc583e82528b83"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="tls_8h.html#aec6736a2ae84b910c077b0e5d42a6882">kthread_key_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gab270b39c6978f0048ffc583e82528b83">tss_t</a></td></tr>
<tr class="memdesc:gab270b39c6978f0048ffc583e82528b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">C11 thread-specific storage type.  <br /></td></tr>
<tr class="separator:gab270b39c6978f0048ffc583e82528b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafce80e0fbade87b49b3230f35e33833f" id="r_gafce80e0fbade87b49b3230f35e33833f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gafce80e0fbade87b49b3230f35e33833f">tss_dtor_t</a>) (void *)</td></tr>
<tr class="memdesc:gafce80e0fbade87b49b3230f35e33833f"><td class="mdescLeft">&#160;</td><td class="mdescRight">C11 thread-specific storage destructor type.  <br /></td></tr>
<tr class="separator:gafce80e0fbade87b49b3230f35e33833f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabff739b74c4ef36c3e4bddd332650493" id="r_gabff739b74c4ef36c3e4bddd332650493"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gabff739b74c4ef36c3e4bddd332650493">call_once</a> (<a class="el" href="group__threading__c11.html#ga0f8ad63f262d12b359f6cfd45c492963">once_flag</a> *flag, void(*func)(void))</td></tr>
<tr class="memdesc:gabff739b74c4ef36c3e4bddd332650493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function one time, no matter how many threads try.  <br /></td></tr>
<tr class="separator:gabff739b74c4ef36c3e4bddd332650493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8b3732298d1d316db6438b4c561c0dd" id="r_gae8b3732298d1d316db6438b4c561c0dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gae8b3732298d1d316db6438b4c561c0dd">mtx_destroy</a> (<a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a> *mtx)</td></tr>
<tr class="memdesc:gae8b3732298d1d316db6438b4c561c0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize a mutex lock.  <br /></td></tr>
<tr class="separator:gae8b3732298d1d316db6438b4c561c0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89200caf0dc25fcc97df171d0034bff2" id="r_ga89200caf0dc25fcc97df171d0034bff2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga89200caf0dc25fcc97df171d0034bff2">mtx_init</a> (<a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a> *mtx, int type)</td></tr>
<tr class="memdesc:ga89200caf0dc25fcc97df171d0034bff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a mutex lock.  <br /></td></tr>
<tr class="separator:ga89200caf0dc25fcc97df171d0034bff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8945984db67db8ee774872da64d0e424" id="r_ga8945984db67db8ee774872da64d0e424"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga8945984db67db8ee774872da64d0e424">mtx_lock</a> (<a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a> *mtx)</td></tr>
<tr class="memdesc:ga8945984db67db8ee774872da64d0e424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a mutex lock.  <br /></td></tr>
<tr class="separator:ga8945984db67db8ee774872da64d0e424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dd1fb3ff6b2bdca4d2f233b3285d02d" id="r_ga5dd1fb3ff6b2bdca4d2f233b3285d02d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga5dd1fb3ff6b2bdca4d2f233b3285d02d">mtx_timedlock</a> (<a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a> *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a> mtx, const struct timespec *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a> ts)</td></tr>
<tr class="memdesc:ga5dd1fb3ff6b2bdca4d2f233b3285d02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a mutex lock with a timeout.  <br /></td></tr>
<tr class="separator:ga5dd1fb3ff6b2bdca4d2f233b3285d02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac577690ddd48f5a1fdf3dc97881a2199" id="r_gac577690ddd48f5a1fdf3dc97881a2199"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gac577690ddd48f5a1fdf3dc97881a2199">mtx_trylock</a> (<a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a> *mtx)</td></tr>
<tr class="memdesc:gac577690ddd48f5a1fdf3dc97881a2199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to acquire a mutex lock.  <br /></td></tr>
<tr class="separator:gac577690ddd48f5a1fdf3dc97881a2199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2fb1d2854461fa583017cc9b0bc6cca" id="r_gae2fb1d2854461fa583017cc9b0bc6cca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gae2fb1d2854461fa583017cc9b0bc6cca">mtx_unlock</a> (<a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a> *mtx)</td></tr>
<tr class="memdesc:gae2fb1d2854461fa583017cc9b0bc6cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a previously acquired lock.  <br /></td></tr>
<tr class="separator:gae2fb1d2854461fa583017cc9b0bc6cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66228b340509733bdf529b93bca8df14" id="r_ga66228b340509733bdf529b93bca8df14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga66228b340509733bdf529b93bca8df14">cnd_broadcast</a> (<a class="el" href="group__threading__c11.html#ga11a8258f951bd19a6dcedbd433edb4dd">cnd_t</a> *cond)</td></tr>
<tr class="memdesc:ga66228b340509733bdf529b93bca8df14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast to all threads locked on a condition variable.  <br /></td></tr>
<tr class="separator:ga66228b340509733bdf529b93bca8df14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa925921fa9edc189f474ae10a23bcfd3" id="r_gaa925921fa9edc189f474ae10a23bcfd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gaa925921fa9edc189f474ae10a23bcfd3">cnd_destroy</a> (<a class="el" href="group__threading__c11.html#ga11a8258f951bd19a6dcedbd433edb4dd">cnd_t</a> *cond)</td></tr>
<tr class="memdesc:gaa925921fa9edc189f474ae10a23bcfd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize a condition variable.  <br /></td></tr>
<tr class="separator:gaa925921fa9edc189f474ae10a23bcfd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga146f4cd218c2a2f770be14c1dee26d08" id="r_ga146f4cd218c2a2f770be14c1dee26d08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga146f4cd218c2a2f770be14c1dee26d08">cnd_init</a> (<a class="el" href="group__threading__c11.html#ga11a8258f951bd19a6dcedbd433edb4dd">cnd_t</a> *cond)</td></tr>
<tr class="memdesc:ga146f4cd218c2a2f770be14c1dee26d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a condition variable.  <br /></td></tr>
<tr class="separator:ga146f4cd218c2a2f770be14c1dee26d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf76e066715b1190d38a69da1c511e30f" id="r_gaf76e066715b1190d38a69da1c511e30f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gaf76e066715b1190d38a69da1c511e30f">cnd_signal</a> (<a class="el" href="group__threading__c11.html#ga11a8258f951bd19a6dcedbd433edb4dd">cnd_t</a> *cond)</td></tr>
<tr class="memdesc:gaf76e066715b1190d38a69da1c511e30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal one thread locked on a condition variable.  <br /></td></tr>
<tr class="separator:gaf76e066715b1190d38a69da1c511e30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2fad6f814228f1eab1d994dfe336f8" id="r_gadf2fad6f814228f1eab1d994dfe336f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gadf2fad6f814228f1eab1d994dfe336f8">cnd_timedwait</a> (<a class="el" href="group__threading__c11.html#ga11a8258f951bd19a6dcedbd433edb4dd">cnd_t</a> *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a> cond, <a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a> *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a> mtx, const struct timespec *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a> ts)</td></tr>
<tr class="memdesc:gadf2fad6f814228f1eab1d994dfe336f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a condition variable (with a timeout).  <br /></td></tr>
<tr class="separator:gadf2fad6f814228f1eab1d994dfe336f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4dfb82fc3d92bb688cb07308af6a659" id="r_gac4dfb82fc3d92bb688cb07308af6a659"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gac4dfb82fc3d92bb688cb07308af6a659">cnd_wait</a> (<a class="el" href="group__threading__c11.html#ga11a8258f951bd19a6dcedbd433edb4dd">cnd_t</a> *cond, <a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a> *mtx)</td></tr>
<tr class="memdesc:gac4dfb82fc3d92bb688cb07308af6a659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a condition variable.  <br /></td></tr>
<tr class="separator:gac4dfb82fc3d92bb688cb07308af6a659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a52b6cd2d15cc6c4741d5124f85d183" id="r_ga1a52b6cd2d15cc6c4741d5124f85d183"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga1a52b6cd2d15cc6c4741d5124f85d183">thrd_create</a> (<a class="el" href="group__threading__c11.html#gaa061fe1137b02e69f5b97ab32d9fa587">thrd_t</a> *thr, <a class="el" href="group__threading__c11.html#ga147516955219e436959e755b082eafe1">thrd_start_t</a> func, void *arg)</td></tr>
<tr class="memdesc:ga1a52b6cd2d15cc6c4741d5124f85d183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and start a new thread.  <br /></td></tr>
<tr class="separator:ga1a52b6cd2d15cc6c4741d5124f85d183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab67b6f182a848d979155d03598325fa7" id="r_gab67b6f182a848d979155d03598325fa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__threading__c11.html#gaa061fe1137b02e69f5b97ab32d9fa587">thrd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gab67b6f182a848d979155d03598325fa7">thrd_current</a> (void)</td></tr>
<tr class="memdesc:gab67b6f182a848d979155d03598325fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the identifier of the currently running thread.  <br /></td></tr>
<tr class="separator:gab67b6f182a848d979155d03598325fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5380997f9e32a31f802bdd9cb266902" id="r_gad5380997f9e32a31f802bdd9cb266902"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gad5380997f9e32a31f802bdd9cb266902">thrd_detach</a> (<a class="el" href="group__threading__c11.html#gaa061fe1137b02e69f5b97ab32d9fa587">thrd_t</a> thr)</td></tr>
<tr class="memdesc:gad5380997f9e32a31f802bdd9cb266902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a running thread.  <br /></td></tr>
<tr class="separator:gad5380997f9e32a31f802bdd9cb266902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga153e65a389814ce51ad07791e42b2118" id="r_ga153e65a389814ce51ad07791e42b2118"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga153e65a389814ce51ad07791e42b2118">thrd_equal</a> (<a class="el" href="group__threading__c11.html#gaa061fe1137b02e69f5b97ab32d9fa587">thrd_t</a> thr0, <a class="el" href="group__threading__c11.html#gaa061fe1137b02e69f5b97ab32d9fa587">thrd_t</a> thr1)</td></tr>
<tr class="memdesc:ga153e65a389814ce51ad07791e42b2118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two threads for equality.  <br /></td></tr>
<tr class="separator:ga153e65a389814ce51ad07791e42b2118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b41b58eeee148228fd188cdee6e9389" id="r_ga3b41b58eeee148228fd188cdee6e9389"><td class="memItemLeft" align="right" valign="top">_Noreturn void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga3b41b58eeee148228fd188cdee6e9389">thrd_exit</a> (int res)</td></tr>
<tr class="memdesc:ga3b41b58eeee148228fd188cdee6e9389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate the current thread immediately.  <br /></td></tr>
<tr class="separator:ga3b41b58eeee148228fd188cdee6e9389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2e83a544f49f74cf217a69a882b5d80" id="r_gaa2e83a544f49f74cf217a69a882b5d80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gaa2e83a544f49f74cf217a69a882b5d80">thrd_join</a> (<a class="el" href="group__threading__c11.html#gaa061fe1137b02e69f5b97ab32d9fa587">thrd_t</a> thr, int *res)</td></tr>
<tr class="memdesc:gaa2e83a544f49f74cf217a69a882b5d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a running thread.  <br /></td></tr>
<tr class="separator:gaa2e83a544f49f74cf217a69a882b5d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f5f79db415e2363470a8570250f785" id="r_ga77f5f79db415e2363470a8570250f785"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga77f5f79db415e2363470a8570250f785">thrd_sleep</a> (const struct timespec *duration, struct timespec *remaining)</td></tr>
<tr class="memdesc:ga77f5f79db415e2363470a8570250f785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the currently running thread to sleep.  <br /></td></tr>
<tr class="separator:ga77f5f79db415e2363470a8570250f785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbfb78346e6b76b23da1d2d8df03549a" id="r_gacbfb78346e6b76b23da1d2d8df03549a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gacbfb78346e6b76b23da1d2d8df03549a">thrd_yield</a> (void)</td></tr>
<tr class="memdesc:gacbfb78346e6b76b23da1d2d8df03549a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the current thread's timeslice.  <br /></td></tr>
<tr class="separator:gacbfb78346e6b76b23da1d2d8df03549a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga286fe7927e9af276a9cfdbc8b9eb08ad" id="r_ga286fe7927e9af276a9cfdbc8b9eb08ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga286fe7927e9af276a9cfdbc8b9eb08ad">tss_create</a> (<a class="el" href="group__threading__c11.html#gab270b39c6978f0048ffc583e82528b83">tss_t</a> *key, <a class="el" href="group__threading__c11.html#gafce80e0fbade87b49b3230f35e33833f">tss_dtor_t</a> dtor)</td></tr>
<tr class="memdesc:ga286fe7927e9af276a9cfdbc8b9eb08ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread-specific storage pointer.  <br /></td></tr>
<tr class="separator:ga286fe7927e9af276a9cfdbc8b9eb08ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecebbc66b206171d9381ba94528c6cb7" id="r_gaecebbc66b206171d9381ba94528c6cb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gaecebbc66b206171d9381ba94528c6cb7">tss_delete</a> (<a class="el" href="group__threading__c11.html#gab270b39c6978f0048ffc583e82528b83">tss_t</a> key)</td></tr>
<tr class="memdesc:gaecebbc66b206171d9381ba94528c6cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free resources associated with a thread-specific storage key.  <br /></td></tr>
<tr class="separator:gaecebbc66b206171d9381ba94528c6cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf26b78a3f19a4e7b6876f957f2059c" id="r_ga5cf26b78a3f19a4e7b6876f957f2059c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga5cf26b78a3f19a4e7b6876f957f2059c">tss_get</a> (<a class="el" href="group__threading__c11.html#gab270b39c6978f0048ffc583e82528b83">tss_t</a> key)</td></tr>
<tr class="memdesc:ga5cf26b78a3f19a4e7b6876f957f2059c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the value associated with a thread-specific storage key.  <br /></td></tr>
<tr class="separator:ga5cf26b78a3f19a4e7b6876f957f2059c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga608e01c49b84a5ad4f085a9aedc6a680" id="r_ga608e01c49b84a5ad4f085a9aedc6a680"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga608e01c49b84a5ad4f085a9aedc6a680">tss_set</a> (<a class="el" href="group__threading__c11.html#gab270b39c6978f0048ffc583e82528b83">tss_t</a> key, void *val)</td></tr>
<tr class="memdesc:ga608e01c49b84a5ad4f085a9aedc6a680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value associated with a thread-specific storage key.  <br /></td></tr>
<tr class="separator:ga608e01c49b84a5ad4f085a9aedc6a680"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Return values</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>C11 Thread function return values</p>
<p>Most of the C11 thread-related functions that return a result code return one of these. </p>
</td></tr>
<tr class="memitem:ga6f15c94421801f7f6a4338653b9017dc" id="r_ga6f15c94421801f7f6a4338653b9017dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga6f15c94421801f7f6a4338653b9017dc">thrd_success</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga6f15c94421801f7f6a4338653b9017dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Success.  <br /></td></tr>
<tr class="separator:ga6f15c94421801f7f6a4338653b9017dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0944e70c2ce4eed616f7bcfd604fba96" id="r_ga0944e70c2ce4eed616f7bcfd604fba96"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga0944e70c2ce4eed616f7bcfd604fba96">thrd_error</a>&#160;&#160;&#160;-1</td></tr>
<tr class="memdesc:ga0944e70c2ce4eed616f7bcfd604fba96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncategorized error.  <br /></td></tr>
<tr class="separator:ga0944e70c2ce4eed616f7bcfd604fba96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga110a67f47dae673b72b3c8f462d29384" id="r_ga110a67f47dae673b72b3c8f462d29384"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga110a67f47dae673b72b3c8f462d29384">thrd_timedout</a>&#160;&#160;&#160;-2</td></tr>
<tr class="memdesc:ga110a67f47dae673b72b3c8f462d29384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time out error.  <br /></td></tr>
<tr class="separator:ga110a67f47dae673b72b3c8f462d29384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c563aa25920a041d83d4019b113ab5d" id="r_ga3c563aa25920a041d83d4019b113ab5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga3c563aa25920a041d83d4019b113ab5d">thrd_busy</a>&#160;&#160;&#160;-3</td></tr>
<tr class="memdesc:ga3c563aa25920a041d83d4019b113ab5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resource busy.  <br /></td></tr>
<tr class="separator:ga3c563aa25920a041d83d4019b113ab5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6010b6ba8c0508cef692f066b09e2ef" id="r_gad6010b6ba8c0508cef692f066b09e2ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gad6010b6ba8c0508cef692f066b09e2ef">thrd_nomem</a>&#160;&#160;&#160;-4</td></tr>
<tr class="memdesc:gad6010b6ba8c0508cef692f066b09e2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Out of memory.  <br /></td></tr>
<tr class="separator:gad6010b6ba8c0508cef692f066b09e2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Mutex types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>C11 mutual exclusion lock types</p>
<p>These are the possible types of mutex locks that C11 allows for. Note that mtx_plain or mtx_recursive can be ORed with mtx_timed as well. </p>
</td></tr>
<tr class="memitem:gaf5ebc375e7a7dca3e9fdcc0bc338f201" id="r_gaf5ebc375e7a7dca3e9fdcc0bc338f201"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gaf5ebc375e7a7dca3e9fdcc0bc338f201">mtx_plain</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="memdesc:gaf5ebc375e7a7dca3e9fdcc0bc338f201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plain mutex.  <br /></td></tr>
<tr class="separator:gaf5ebc375e7a7dca3e9fdcc0bc338f201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23baf902554dba287faa32c646e35f61" id="r_ga23baf902554dba287faa32c646e35f61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#ga23baf902554dba287faa32c646e35f61">mtx_recursive</a>&#160;&#160;&#160;(1 &lt;&lt; 1)</td></tr>
<tr class="memdesc:ga23baf902554dba287faa32c646e35f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive mutex.  <br /></td></tr>
<tr class="separator:ga23baf902554dba287faa32c646e35f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf070d6198d7c0419e5eed91db5ac223" id="r_gadf070d6198d7c0419e5eed91db5ac223"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading__c11.html#gadf070d6198d7c0419e5eed91db5ac223">mtx_timed</a>&#160;&#160;&#160;(1 &lt;&lt; 2)</td></tr>
<tr class="memdesc:gadf070d6198d7c0419e5eed91db5ac223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex supporting the mtx_timedlock function.  <br /></td></tr>
<tr class="separator:gadf070d6198d7c0419e5eed91db5ac223"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>C11 Threading APIs. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaf5ebc375e7a7dca3e9fdcc0bc338f201" name="gaf5ebc375e7a7dca3e9fdcc0bc338f201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5ebc375e7a7dca3e9fdcc0bc338f201">&#9670;&#160;</a></span>mtx_plain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mtx_plain&#160;&#160;&#160;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Plain mutex. </p>

</div>
</div>
<a id="ga23baf902554dba287faa32c646e35f61" name="ga23baf902554dba287faa32c646e35f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23baf902554dba287faa32c646e35f61">&#9670;&#160;</a></span>mtx_recursive</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mtx_recursive&#160;&#160;&#160;(1 &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursive mutex. </p>

</div>
</div>
<a id="gadf070d6198d7c0419e5eed91db5ac223" name="gadf070d6198d7c0419e5eed91db5ac223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf070d6198d7c0419e5eed91db5ac223">&#9670;&#160;</a></span>mtx_timed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mtx_timed&#160;&#160;&#160;(1 &lt;&lt; 2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutex supporting the mtx_timedlock function. </p>

</div>
</div>
<a id="ga0eeb41bf239112f98df3d9f644d48f6e" name="ga0eeb41bf239112f98df3d9f644d48f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eeb41bf239112f98df3d9f644d48f6e">&#9670;&#160;</a></span>ONCE_FLAG_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ONCE_FLAG_INIT&#160;&#160;&#160;<a class="el" href="once_8h.html#ab7edaf6616245c7d5a24e8d6725f249a">KTHREAD_ONCE_INIT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to initialize a once_flag object. </p>

</div>
</div>
<a id="ga3c563aa25920a041d83d4019b113ab5d" name="ga3c563aa25920a041d83d4019b113ab5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c563aa25920a041d83d4019b113ab5d">&#9670;&#160;</a></span>thrd_busy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define thrd_busy&#160;&#160;&#160;-3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resource busy. </p>

</div>
</div>
<a id="ga0944e70c2ce4eed616f7bcfd604fba96" name="ga0944e70c2ce4eed616f7bcfd604fba96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0944e70c2ce4eed616f7bcfd604fba96">&#9670;&#160;</a></span>thrd_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define thrd_error&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uncategorized error. </p>

</div>
</div>
<a id="gad6010b6ba8c0508cef692f066b09e2ef" name="gad6010b6ba8c0508cef692f066b09e2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6010b6ba8c0508cef692f066b09e2ef">&#9670;&#160;</a></span>thrd_nomem</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define thrd_nomem&#160;&#160;&#160;-4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Out of memory. </p>

</div>
</div>
<a id="ga6f15c94421801f7f6a4338653b9017dc" name="ga6f15c94421801f7f6a4338653b9017dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f15c94421801f7f6a4338653b9017dc">&#9670;&#160;</a></span>thrd_success</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define thrd_success&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Success. </p>

</div>
</div>
<a id="ga110a67f47dae673b72b3c8f462d29384" name="ga110a67f47dae673b72b3c8f462d29384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga110a67f47dae673b72b3c8f462d29384">&#9670;&#160;</a></span>thrd_timedout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define thrd_timedout&#160;&#160;&#160;-2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time out error. </p>

</div>
</div>
<a id="ga11de84b15b6b59861b4366a192aadd58" name="ga11de84b15b6b59861b4366a192aadd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11de84b15b6b59861b4366a192aadd58">&#9670;&#160;</a></span>TSS_DTOR_ITERATIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TSS_DTOR_ITERATIONS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of iterations over TSS destructors. </p>
<p>This macro defines the maximum number of iterations that will be performed over the destructors for thread-specific storage objects when a thread terminates. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga11a8258f951bd19a6dcedbd433edb4dd" name="ga11a8258f951bd19a6dcedbd433edb4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11a8258f951bd19a6dcedbd433edb4dd">&#9670;&#160;</a></span>cnd_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcondvar__t.html">condvar_t</a> <a class="el" href="group__threading__c11.html#ga11a8258f951bd19a6dcedbd433edb4dd">cnd_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C11 condition variable type. </p>
<p>This type holds an identifier for a condition variable object that is to be used with C11 threading support. </p>

</div>
</div>
<a id="ga56f6590fbffa7b15263d532fd9640ee5" name="ga56f6590fbffa7b15263d532fd9640ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56f6590fbffa7b15263d532fd9640ee5">&#9670;&#160;</a></span>mtx_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structmutex__t.html">mutex_t</a> <a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C11 mutual exclusion lock type. </p>
<p>This type holds an identifier for a mutual exclusion (mutex) lock to be used with C11 threading support. </p>

</div>
</div>
<a id="ga0f8ad63f262d12b359f6cfd45c492963" name="ga0f8ad63f262d12b359f6cfd45c492963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f8ad63f262d12b359f6cfd45c492963">&#9670;&#160;</a></span>once_flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="once_8h.html#a0a7053da57ccf14871e587a93d168f90">kthread_once_t</a> <a class="el" href="group__threading__c11.html#ga0f8ad63f262d12b359f6cfd45c492963">once_flag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Object type backing call_once. </p>
<p>This object type holds a flag that is used by the call_once function to call a function one time. It should always be initialized with the ONCE_FLAG_INIT macro. </p>

</div>
</div>
<a id="ga147516955219e436959e755b082eafe1" name="ga147516955219e436959e755b082eafe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga147516955219e436959e755b082eafe1">&#9670;&#160;</a></span>thrd_start_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* thrd_start_t) (void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C11 thread start function type. </p>
<p>This is a function pointer type representing a function used to begin a thread. The thread exits when the function returns or calls <a class="el" href="group__threading__c11.html#ga3b41b58eeee148228fd188cdee6e9389" title="Terminate the current thread immediately.">thrd_exit()</a>. </p>

</div>
</div>
<a id="gaa061fe1137b02e69f5b97ab32d9fa587" name="gaa061fe1137b02e69f5b97ab32d9fa587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa061fe1137b02e69f5b97ab32d9fa587">&#9670;&#160;</a></span>thrd_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structkthread__t.html">kthread_t</a>* <a class="el" href="group__threading__c11.html#gaa061fe1137b02e69f5b97ab32d9fa587">thrd_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C11 thread identifier type. </p>
<p>This type holds an identifier for a C11 thread. </p>

</div>
</div>
<a id="gafce80e0fbade87b49b3230f35e33833f" name="gafce80e0fbade87b49b3230f35e33833f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafce80e0fbade87b49b3230f35e33833f">&#9670;&#160;</a></span>tss_dtor_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* tss_dtor_t) (void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C11 thread-specific storage destructor type. </p>
<p>This is a function pointer type which describes a destructor for a thread-specific storage object. </p>

</div>
</div>
<a id="gab270b39c6978f0048ffc583e82528b83" name="gab270b39c6978f0048ffc583e82528b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab270b39c6978f0048ffc583e82528b83">&#9670;&#160;</a></span>tss_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="tls_8h.html#aec6736a2ae84b910c077b0e5d42a6882">kthread_key_t</a> <a class="el" href="group__threading__c11.html#gab270b39c6978f0048ffc583e82528b83">tss_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C11 thread-specific storage type. </p>
<p>This type holds a thread-specific storage identifier, which allows a value to be associated with it for each and every thread running. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabff739b74c4ef36c3e4bddd332650493" name="gabff739b74c4ef36c3e4bddd332650493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabff739b74c4ef36c3e4bddd332650493">&#9670;&#160;</a></span>call_once()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void call_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#ga0f8ad63f262d12b359f6cfd45c492963">once_flag</a> *&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a function one time, no matter how many threads try. </p>
<p>This function uses the once_flag object passed in to ensure that a given function is called exactly once, regardless of how many threads attempt to call through the once_flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>The once_flag to run against. </td></tr>
    <tr><td class="paramname">func</td><td>The function to call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga66228b340509733bdf529b93bca8df14" name="ga66228b340509733bdf529b93bca8df14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66228b340509733bdf529b93bca8df14">&#9670;&#160;</a></span>cnd_broadcast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cnd_broadcast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#ga11a8258f951bd19a6dcedbd433edb4dd">cnd_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast to all threads locked on a condition variable. </p>
<p>This function wakes all threads that are blocked on the condition variable cond at the time of the call. If no threads are currently blocked on cond, this call does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>The condition variable to signal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">thrd_success</td><td>On success. </td></tr>
    <tr><td class="paramname">thrd_error</td><td>If the request cannot be honored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa925921fa9edc189f474ae10a23bcfd3" name="gaa925921fa9edc189f474ae10a23bcfd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa925921fa9edc189f474ae10a23bcfd3">&#9670;&#160;</a></span>cnd_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cnd_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#ga11a8258f951bd19a6dcedbd433edb4dd">cnd_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deinitialize a condition variable. </p>
<p>This function cleans up all resources associated with the given condition variable. You must ensure that no threads are currently blocked on the condition variable before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>The condition variable to deinitialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Deinitializing a condition variable that is currently being waited on by threads results in undefined behavior. </dd></dl>

</div>
</div>
<a id="ga146f4cd218c2a2f770be14c1dee26d08" name="ga146f4cd218c2a2f770be14c1dee26d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga146f4cd218c2a2f770be14c1dee26d08">&#9670;&#160;</a></span>cnd_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cnd_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#ga11a8258f951bd19a6dcedbd433edb4dd">cnd_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a condition variable. </p>
<p>This function initializes the specified condition variable for use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>The condition variable to signal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">thrd_success</td><td>On success. </td></tr>
    <tr><td class="paramname">thrd_nomem</td><td>If memory cannot be allocated for the new condition variable. </td></tr>
    <tr><td class="paramname">thrd_error</td><td>If the request cannot be honored for some other reason. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf76e066715b1190d38a69da1c511e30f" name="gaf76e066715b1190d38a69da1c511e30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf76e066715b1190d38a69da1c511e30f">&#9670;&#160;</a></span>cnd_signal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cnd_signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#ga11a8258f951bd19a6dcedbd433edb4dd">cnd_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal one thread locked on a condition variable. </p>
<p>This function wakes one thread that is blocked on the condition variable cond at the time of the call. If no threads are currently blocked on cond, this call does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>The condition variable to signal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">thrd_success</td><td>On success. </td></tr>
    <tr><td class="paramname">thrd_error</td><td>If the request cannot be honored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf2fad6f814228f1eab1d994dfe336f8" name="gadf2fad6f814228f1eab1d994dfe336f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf2fad6f814228f1eab1d994dfe336f8">&#9670;&#160;</a></span>cnd_timedwait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cnd_timedwait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#ga11a8258f951bd19a6dcedbd433edb4dd">cnd_t</a> *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a>&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a> *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a>&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a>&#160;</td>
          <td class="paramname"><em>ts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait on a condition variable (with a timeout). </p>
<p>This function puts the calling thread to sleep until either the condition variable is signaled or the timeout specified expires, whichever happens first. The specified mutex must be held by the calling thread when calling this function and will be held by the thread again when it is unblocked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>The condition variable to wait on. </td></tr>
    <tr><td class="paramname">mtx</td><td>The mutex associated with the condition variable. </td></tr>
    <tr><td class="paramname">ts</td><td>The time to wait before timing out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">thrd_success</td><td>On success. </td></tr>
    <tr><td class="paramname">thrd_timedout</td><td>If the timeout was reached before the condition variable was signaled. </td></tr>
    <tr><td class="paramname">thrd_error</td><td>If the request cannot be honored for some other reason.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function in an interrupt will result in an error being returned. </dd>
<dd>
Although timeouts are specified in seconds and nanoseconds, the timeout will be rounded up to the nearest millisecond. </dd></dl>

</div>
</div>
<a id="gac4dfb82fc3d92bb688cb07308af6a659" name="gac4dfb82fc3d92bb688cb07308af6a659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4dfb82fc3d92bb688cb07308af6a659">&#9670;&#160;</a></span>cnd_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cnd_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#ga11a8258f951bd19a6dcedbd433edb4dd">cnd_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait on a condition variable. </p>
<p>This function puts the calling thread to sleep until the condition variable is signaled. The specified mutex must be held by the calling thread when calling this function and will be held by the thread again when it is unblocked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>The condition variable to wait on. </td></tr>
    <tr><td class="paramname">mtx</td><td>The mutex associated with the condition variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">thrd_success</td><td>On success. </td></tr>
    <tr><td class="paramname">thrd_error</td><td>If the request cannot be honored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function in an interrupt will result in an error being returned. </dd></dl>

</div>
</div>
<a id="gae8b3732298d1d316db6438b4c561c0dd" name="gae8b3732298d1d316db6438b4c561c0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8b3732298d1d316db6438b4c561c0dd">&#9670;&#160;</a></span>mtx_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mtx_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deinitialize a mutex lock. </p>
<p>This function deinitializes a mutex lock that was previously created with <a class="el" href="group__threading__c11.html#ga89200caf0dc25fcc97df171d0034bff2" title="Initialize a mutex lock.">mtx_init()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>The mutex to deinitialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga89200caf0dc25fcc97df171d0034bff2" name="ga89200caf0dc25fcc97df171d0034bff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89200caf0dc25fcc97df171d0034bff2">&#9670;&#160;</a></span>mtx_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mtx_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a mutex lock. </p>
<p>This function initializes a mutex lock of the given type for later use to protect critical sections of code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>The mutex to initialize. </td></tr>
    <tr><td class="paramname">type</td><td>The type of mutex desired </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">thrd_success</td><td>On success. </td></tr>
    <tr><td class="paramname">thrd_error</td><td>If the request could not be honored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8945984db67db8ee774872da64d0e424" name="ga8945984db67db8ee774872da64d0e424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8945984db67db8ee774872da64d0e424">&#9670;&#160;</a></span>mtx_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mtx_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock a mutex lock. </p>
<p>This function locks the specified mutex, preventing any other threads from obtaining the same lock.</p>
<p>This function will block until the lock can be obtained.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>The mutex to lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">thrd_success</td><td>On success. </td></tr>
    <tr><td class="paramname">thrd_error</td><td>If the request could not be honored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function in an interrupt will result in an error being returned. </dd></dl>

</div>
</div>
<a id="ga5dd1fb3ff6b2bdca4d2f233b3285d02d" name="ga5dd1fb3ff6b2bdca4d2f233b3285d02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dd1fb3ff6b2bdca4d2f233b3285d02d">&#9670;&#160;</a></span>mtx_timedlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mtx_timedlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a> *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a>&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *<a class="el" href="group__system__macros.html#ga378ac21329d33f561f90265eef89f564">__RESTRICT</a>&#160;</td>
          <td class="paramname"><em>ts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock a mutex lock with a timeout. </p>
<p>This function locks the specified mutex, assuming that the lock can be obtained in the time period specified.</p>
<p>This function will block until the lock can be obtained or the timeout expires.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>The mutex to lock. </td></tr>
    <tr><td class="paramname">ts</td><td>The amount of time to wait before timing out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">thrd_success</td><td>On success. </td></tr>
    <tr><td class="paramname">thrd_error</td><td>If the request could not be honored for some other reason than a timeout. </td></tr>
    <tr><td class="paramname">thrd_timedout</td><td>If the timeout specified passes without obtaining the lock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function in an interrupt will result in an error being returned. </dd>
<dd>
Although timeouts are specified in seconds and nanoseconds, the timeout will be rounded up to the nearest millisecond. </dd></dl>

</div>
</div>
<a id="gac577690ddd48f5a1fdf3dc97881a2199" name="gac577690ddd48f5a1fdf3dc97881a2199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac577690ddd48f5a1fdf3dc97881a2199">&#9670;&#160;</a></span>mtx_trylock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mtx_trylock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to acquire a mutex lock. </p>
<p>This function attempts to acquire the specified mutex and will not block if it cannot be obtained.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>The mutex to lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">thrd_success</td><td>On success. </td></tr>
    <tr><td class="paramname">thrd_busy</td><td>If the lock is already locked by a thread. </td></tr>
    <tr><td class="paramname">thrd_error</td><td>If the request could not be honored for some other reason.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is safe to call in an interrupt. </dd>
<dd>
Always check the return value to ensure that the lock was obtained. </dd></dl>

</div>
</div>
<a id="gae2fb1d2854461fa583017cc9b0bc6cca" name="gae2fb1d2854461fa583017cc9b0bc6cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2fb1d2854461fa583017cc9b0bc6cca">&#9670;&#160;</a></span>mtx_unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mtx_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#ga56f6590fbffa7b15263d532fd9640ee5">mtx_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlock a previously acquired lock. </p>
<p>This function releases the specified mutex lock, allowing other threads to acquire it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>The mutex to unlock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">thrd_success</td><td>On success. </td></tr>
    <tr><td class="paramname">thrd_error</td><td>If the request cannot be honored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unlocking a mutex that was not previously locked by the calling thread results in undefined behavior. </dd></dl>

</div>
</div>
<a id="ga1a52b6cd2d15cc6c4741d5124f85d183" name="ga1a52b6cd2d15cc6c4741d5124f85d183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a52b6cd2d15cc6c4741d5124f85d183">&#9670;&#160;</a></span>thrd_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int thrd_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#gaa061fe1137b02e69f5b97ab32d9fa587">thrd_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#ga147516955219e436959e755b082eafe1">thrd_start_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and start a new thread. </p>
<p>This function creates a new thread, calling the function specified. The thread is immediately added to the runnable queue of the scheduler and can start at any moment after that. The thread ends when either the function specified returns or when the thread calls <a class="el" href="group__threading__c11.html#ga3b41b58eeee148228fd188cdee6e9389" title="Terminate the current thread immediately.">thrd_exit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>Storage for the thread identifier. </td></tr>
    <tr><td class="paramname">func</td><td>The function to call in the new thread. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument to pass to the function called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">thrd_success</td><td>On success. </td></tr>
    <tr><td class="paramname">thrd_nomem</td><td>If memory cannot be allocated to satisfy the request. </td></tr>
    <tr><td class="paramname">thrd_error</td><td>If the request cannot be honored for some other reason.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>All threads created are joinable threads by default. That means that in order to free all resources at thread termination, the thread must be joined with the <a class="el" href="group__threading__c11.html#gaa2e83a544f49f74cf217a69a882b5d80" title="Join a running thread.">thrd_join()</a> function or detached at some point with <a class="el" href="group__threading__c11.html#gad5380997f9e32a31f802bdd9cb266902" title="Detach a running thread.">thrd_detach()</a>. </dd></dl>

</div>
</div>
<a id="gab67b6f182a848d979155d03598325fa7" name="gab67b6f182a848d979155d03598325fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab67b6f182a848d979155d03598325fa7">&#9670;&#160;</a></span>thrd_current()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__threading__c11.html#gaa061fe1137b02e69f5b97ab32d9fa587">thrd_t</a> thrd_current </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the identifier of the currently running thread. </p>
<dl class="section return"><dt>Returns</dt><dd>The current thread's ID. </dd></dl>

</div>
</div>
<a id="gad5380997f9e32a31f802bdd9cb266902" name="gad5380997f9e32a31f802bdd9cb266902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5380997f9e32a31f802bdd9cb266902">&#9670;&#160;</a></span>thrd_detach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int thrd_detach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#gaa061fe1137b02e69f5b97ab32d9fa587">thrd_t</a>&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detach a running thread. </p>
<p>This function detaches a thread, which informs the kernel that any resources associated with the thread should be freed immediately when it terminates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>The thread to detach. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">thrd_success</td><td>On success. </td></tr>
    <tr><td class="paramname">thrd_error</td><td>If the request cannot be honored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Detaching an already detached thread has no effect. </dd>
<dd>
Detaching a thread that has been joined with another thread results in undefined behavior. </dd></dl>

</div>
</div>
<a id="ga153e65a389814ce51ad07791e42b2118" name="ga153e65a389814ce51ad07791e42b2118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga153e65a389814ce51ad07791e42b2118">&#9670;&#160;</a></span>thrd_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int thrd_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#gaa061fe1137b02e69f5b97ab32d9fa587">thrd_t</a>&#160;</td>
          <td class="paramname"><em>thr0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#gaa061fe1137b02e69f5b97ab32d9fa587">thrd_t</a>&#160;</td>
          <td class="paramname"><em>thr1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two threads for equality. </p>
<p>This function checks the two two thread identifiers passed in to see if they refer to the same thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr0</td><td>The first thread to compare. </td></tr>
    <tr><td class="paramname">thr1</td><td>The second thread to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the threads are not equal, nonzero if the threads are equal. </dd></dl>

</div>
</div>
<a id="ga3b41b58eeee148228fd188cdee6e9389" name="ga3b41b58eeee148228fd188cdee6e9389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b41b58eeee148228fd188cdee6e9389">&#9670;&#160;</a></span>thrd_exit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Noreturn void thrd_exit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Terminate the current thread immediately. </p>
<p>This function terminates the calling thread immediately, setting the return value of the thread to the value specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The return value of the thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will not return. </dd></dl>

</div>
</div>
<a id="gaa2e83a544f49f74cf217a69a882b5d80" name="gaa2e83a544f49f74cf217a69a882b5d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2e83a544f49f74cf217a69a882b5d80">&#9670;&#160;</a></span>thrd_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int thrd_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#gaa061fe1137b02e69f5b97ab32d9fa587">thrd_t</a>&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a running thread. </p>
<p>This function joins the current thread with the specified thread, blocking until that thread has terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>The thread to join with. </td></tr>
    <tr><td class="paramname">res</td><td>Pointer to storage for the result code of the other thread. Set to NULL if you don't care about the result value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">thrd_success</td><td>On success. </td></tr>
    <tr><td class="paramname">thrd_error</td><td>If the request cannot be honored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Joining with a previously detached thread results in undefined behavior. </dd>
<dd>
Joining with a thread that has already been joined to another thread results in undefined behavior. </dd>
<dd>
Calling this function in an interrupt will result in an error being returned. </dd></dl>

</div>
</div>
<a id="ga77f5f79db415e2363470a8570250f785" name="ga77f5f79db415e2363470a8570250f785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77f5f79db415e2363470a8570250f785">&#9670;&#160;</a></span>thrd_sleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int thrd_sleep </td>
          <td>(</td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>remaining</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put the currently running thread to sleep. </p>
<p>This function puts the currently running thread to sleep for the specified duration of time, returning any left over time (if interrupted by a signal, for instance) in the second parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>The amount of time to sleep. </td></tr>
    <tr><td class="paramname">remaining</td><td>Any remaining time from the duration that the thread did not sleep for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the requested time elapsed, a negative value otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Although the duration is expressed in seconds and nanoseconds, all sleeping is done in millisecond increments. The value specified will be rounded up if it is not an even number of milliseconds. </dd>
<dd>
KOS does not support signals, so remaining will only ever have a value after the function if there is some sort of error. </dd>
<dd>
Calling this function in an interrupt will result in an error being returned. </dd></dl>

</div>
</div>
<a id="gacbfb78346e6b76b23da1d2d8df03549a" name="gacbfb78346e6b76b23da1d2d8df03549a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbfb78346e6b76b23da1d2d8df03549a">&#9670;&#160;</a></span>thrd_yield()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void thrd_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Yield the current thread's timeslice. </p>
<p>This function immediately pauses the current thread's execution and switches to another thread in the ready queue (if there are any threads ready to execute).</p>
<dl class="section note"><dt>Note</dt><dd>Calling this function in an interrupt will not have any effect. </dd></dl>

</div>
</div>
<a id="ga286fe7927e9af276a9cfdbc8b9eb08ad" name="ga286fe7927e9af276a9cfdbc8b9eb08ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga286fe7927e9af276a9cfdbc8b9eb08ad">&#9670;&#160;</a></span>tss_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int tss_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#gab270b39c6978f0048ffc583e82528b83">tss_t</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#gafce80e0fbade87b49b3230f35e33833f">tss_dtor_t</a>&#160;</td>
          <td class="paramname"><em>dtor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a thread-specific storage pointer. </p>
<p>This function creates a thread-specific storage pointer and associates the destructor function supplied with it. After creating the pointer, each thread may associate a piece of data with the key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to initialize. </td></tr>
    <tr><td class="paramname">dtor</td><td>The destructor to associate with the key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">thrd_success</td><td>On success. </td></tr>
    <tr><td class="paramname">thrd_error</td><td>On failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaecebbc66b206171d9381ba94528c6cb7" name="gaecebbc66b206171d9381ba94528c6cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecebbc66b206171d9381ba94528c6cb7">&#9670;&#160;</a></span>tss_delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tss_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#gab270b39c6978f0048ffc583e82528b83">tss_t</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free resources associated with a thread-specific storage key. </p>
<p>This function releases any resources used by the thread-specific storage key specified. Note that this DOES NOT call any destructors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to deinitialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5cf26b78a3f19a4e7b6876f957f2059c" name="ga5cf26b78a3f19a4e7b6876f957f2059c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cf26b78a3f19a4e7b6876f957f2059c">&#9670;&#160;</a></span>tss_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * tss_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#gab270b39c6978f0048ffc583e82528b83">tss_t</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the value associated with a thread-specific storage key. </p>
<p>This function retrieves the value associated with the specified thread-specific storage key and returns it to the caller. If no value has been set in the current thread, NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to look up the value associated with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the key. </dd></dl>

</div>
</div>
<a id="ga608e01c49b84a5ad4f085a9aedc6a680" name="ga608e01c49b84a5ad4f085a9aedc6a680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga608e01c49b84a5ad4f085a9aedc6a680">&#9670;&#160;</a></span>tss_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int tss_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading__c11.html#gab270b39c6978f0048ffc583e82528b83">tss_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value associated with a thread-specific storage key. </p>
<p>This function sets the value to be associated with the specified thread-specific storage key, overwriting any previous keys. Note that this DOES NOT call any destructors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to set the value for. </td></tr>
    <tr><td class="paramname">val</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">thrd_success</td><td>On success. </td></tr>
    <tr><td class="paramname">thrd_error</td><td>If the request cannot be honored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
