<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KallistiOS: Store Queues</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">KallistiOS<span id="projectnumber">&#160;##version##</span>
   </div>
   <div id="projectbrief">Independent SDK for the Sega Dreamcast</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__store__queues.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Store Queues<div class="ingroups"><a class="el" href="group__system.html">System</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>SH4 CPU Peripheral for burst memory transactions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:sq_8h" id="r_sq_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sq_8h.html">sq.h</a></td></tr>
<tr class="memdesc:sq_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions to access the SH4 Store Queues. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae3f3b19cc818d9be2940facc19692856" id="r_gae3f3b19cc818d9be2940facc19692856"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__store__queues.html#gae3f3b19cc818d9be2940facc19692856">SQ_MASK_DEST_ADDR</a>(dest)&#160;&#160;&#160;    (<a class="el" href="group__p4mem.html#gac9490e36164a490e0024572e9c4688c5">MEM_AREA_SQ_BASE</a> | ((uintptr_t)(dest) &amp; 0x03ffffe0))</td></tr>
<tr class="memdesc:gae3f3b19cc818d9be2940facc19692856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask dest to Store Queue area as address.  <br /></td></tr>
<tr class="separator:gae3f3b19cc818d9be2940facc19692856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae368a79b7f862bbdd28e89f8fd717a97" id="r_gae368a79b7f862bbdd28e89f8fd717a97"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__store__queues.html#gae368a79b7f862bbdd28e89f8fd717a97">SQ_MASK_DEST</a>(dest)&#160;&#160;&#160;    ((uint32_t *)(void *) <a class="el" href="group__store__queues.html#gae3f3b19cc818d9be2940facc19692856">SQ_MASK_DEST_ADDR</a>(dest))</td></tr>
<tr class="memdesc:gae368a79b7f862bbdd28e89f8fd717a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask dest to Store Queue area as pointer.  <br /></td></tr>
<tr class="separator:gae368a79b7f862bbdd28e89f8fd717a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa981440464e89f52b075abbddfab805" id="r_gaaa981440464e89f52b075abbddfab805"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__store__queues.html#gaaa981440464e89f52b075abbddfab805">sq_flush</a>(dest)&#160;&#160;&#160;<a class="el" href="group__system__cache.html#gab0e4bfd2c4c84423518de9dae6af4eda">dcache_wback_sq</a>(dest)</td></tr>
<tr class="memdesc:gaaa981440464e89f52b075abbddfab805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write-back one Store Queue.  <br /></td></tr>
<tr class="separator:gaaa981440464e89f52b075abbddfab805"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga092fe09c19d32ce2fc6fc4f506c60070" id="r_ga092fe09c19d32ce2fc6fc4f506c60070"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__store__queues.html#ga092fe09c19d32ce2fc6fc4f506c60070">pvr_sq_load</a> (void *dest, const void *src, size_t n, int type)</td></tr>
<tr class="memdesc:ga092fe09c19d32ce2fc6fc4f506c60070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a block of memory to VRAM.  <br /></td></tr>
<tr class="separator:ga092fe09c19d32ce2fc6fc4f506c60070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54cbcd67f3f7bb01334b8e620c50fbf5" id="r_ga54cbcd67f3f7bb01334b8e620c50fbf5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__store__queues.html#ga54cbcd67f3f7bb01334b8e620c50fbf5">pvr_sq_set16</a> (void *dest, uint32_t c, size_t n, int type)</td></tr>
<tr class="memdesc:ga54cbcd67f3f7bb01334b8e620c50fbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a block of PVR memory to a 16-bit value.  <br /></td></tr>
<tr class="separator:ga54cbcd67f3f7bb01334b8e620c50fbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b11c4381d550a1deb9b2aefd82b80c4" id="r_ga4b11c4381d550a1deb9b2aefd82b80c4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__store__queues.html#ga4b11c4381d550a1deb9b2aefd82b80c4">pvr_sq_set32</a> (void *dest, uint32_t c, size_t n, int type)</td></tr>
<tr class="memdesc:ga4b11c4381d550a1deb9b2aefd82b80c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a block of PVR memory to a 32-bit value.  <br /></td></tr>
<tr class="separator:ga4b11c4381d550a1deb9b2aefd82b80c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34060d140ecea2a5da87e14f7071d268" id="r_ga34060d140ecea2a5da87e14f7071d268"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__store__queues.html#ga34060d140ecea2a5da87e14f7071d268">sq_lock</a> (void *dest)</td></tr>
<tr class="memdesc:ga34060d140ecea2a5da87e14f7071d268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock Store Queues.  <br /></td></tr>
<tr class="separator:ga34060d140ecea2a5da87e14f7071d268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83fe109b27f9e7069beeb60c334bd563" id="r_ga83fe109b27f9e7069beeb60c334bd563"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__store__queues.html#ga83fe109b27f9e7069beeb60c334bd563">sq_unlock</a> (void)</td></tr>
<tr class="memdesc:ga83fe109b27f9e7069beeb60c334bd563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock Store Queues.  <br /></td></tr>
<tr class="separator:ga83fe109b27f9e7069beeb60c334bd563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b2f05baceca5ef17dd21ba056ea1113" id="r_ga2b2f05baceca5ef17dd21ba056ea1113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__store__queues.html#ga2b2f05baceca5ef17dd21ba056ea1113">sq_wait</a> (void)</td></tr>
<tr class="memdesc:ga2b2f05baceca5ef17dd21ba056ea1113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for both Store Queues to complete.  <br /></td></tr>
<tr class="separator:ga2b2f05baceca5ef17dd21ba056ea1113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dcb6016c825d951d5aacd15fd137b89" id="r_ga8dcb6016c825d951d5aacd15fd137b89"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__store__queues.html#ga8dcb6016c825d951d5aacd15fd137b89">sq_cpy</a> (void *dest, const void *src, size_t n)</td></tr>
<tr class="memdesc:ga8dcb6016c825d951d5aacd15fd137b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a block of memory.  <br /></td></tr>
<tr class="separator:ga8dcb6016c825d951d5aacd15fd137b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga169559fc4410135c325025b6ee579a24" id="r_ga169559fc4410135c325025b6ee579a24"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__store__queues.html#ga169559fc4410135c325025b6ee579a24">sq_fast_cpy</a> (void *dest, const void *src, size_t n)</td></tr>
<tr class="memdesc:ga169559fc4410135c325025b6ee579a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a block of memory.  <br /></td></tr>
<tr class="separator:ga169559fc4410135c325025b6ee579a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ff22db673ec9c9bca4485fcd00a039f" id="r_ga1ff22db673ec9c9bca4485fcd00a039f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__store__queues.html#ga1ff22db673ec9c9bca4485fcd00a039f">sq_set</a> (void *dest, uint32_t c, size_t n)</td></tr>
<tr class="memdesc:ga1ff22db673ec9c9bca4485fcd00a039f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a block of memory to an 8-bit value.  <br /></td></tr>
<tr class="separator:ga1ff22db673ec9c9bca4485fcd00a039f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30f23e7f5106da1dc68c773b9e7306a5" id="r_ga30f23e7f5106da1dc68c773b9e7306a5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__store__queues.html#ga30f23e7f5106da1dc68c773b9e7306a5">sq_set16</a> (void *dest, uint32_t c, size_t n)</td></tr>
<tr class="memdesc:ga30f23e7f5106da1dc68c773b9e7306a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a block of memory to a 16-bit value.  <br /></td></tr>
<tr class="separator:ga30f23e7f5106da1dc68c773b9e7306a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31a2bae1ddf089207a59b1dc29c3ffb4" id="r_ga31a2bae1ddf089207a59b1dc29c3ffb4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__store__queues.html#ga31a2bae1ddf089207a59b1dc29c3ffb4">sq_set32</a> (void *dest, uint32_t c, size_t n)</td></tr>
<tr class="memdesc:ga31a2bae1ddf089207a59b1dc29c3ffb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a block of memory to a 32-bit value.  <br /></td></tr>
<tr class="separator:ga31a2bae1ddf089207a59b1dc29c3ffb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7c2c6f4ce37eaa9d886efbbd0fa2ec5" id="r_gae7c2c6f4ce37eaa9d886efbbd0fa2ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__store__queues.html#gae7c2c6f4ce37eaa9d886efbbd0fa2ec5">sq_clr</a> (void *dest, size_t n)</td></tr>
<tr class="memdesc:gae7c2c6f4ce37eaa9d886efbbd0fa2ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a block of memory.  <br /></td></tr>
<tr class="separator:gae7c2c6f4ce37eaa9d886efbbd0fa2ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>SH4 CPU Peripheral for burst memory transactions. </p>
<p>The store queues are a way to do efficient burst transfers from the CPU to external memory. They can be used in a variety of ways, such as to transfer a texture to PVR memory. The transfers are in units of 32-bytes, and the destinations must be 32-byte aligned.</p>
<dl class="section note"><dt>Note</dt><dd>Mastery over knowing when and how to utilize the store queues is important when trying to push the limits of the Dreamcast, specifically when transferring chunks of data between regions of memory. It is often the case that the DMA is faster for transactions which are consistently large; however, the store queues tend to have better performance and have less configuration overhead when bursting smaller chunks of data. </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaaa981440464e89f52b075abbddfab805" name="gaaa981440464e89f52b075abbddfab805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa981440464e89f52b075abbddfab805">&#9670;&#160;</a></span>sq_flush</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sq_flush</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dest</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__system__cache.html#gab0e4bfd2c4c84423518de9dae6af4eda">dcache_wback_sq</a>(dest)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write-back one Store Queue. </p>
<p>Initiates write-back from SQ buffer to external memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The address to copy to (32-byte aligned).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__store__queues.html#ga2b2f05baceca5ef17dd21ba056ea1113" title="Wait for both Store Queues to complete.">sq_wait()</a> </dd></dl>

</div>
</div>
<a id="gae368a79b7f862bbdd28e89f8fd717a97" name="gae368a79b7f862bbdd28e89f8fd717a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae368a79b7f862bbdd28e89f8fd717a97">&#9670;&#160;</a></span>SQ_MASK_DEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SQ_MASK_DEST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dest</td><td>)</td>
          <td>&#160;&#160;&#160;    ((uint32_t *)(void *) <a class="el" href="group__store__queues.html#gae3f3b19cc818d9be2940facc19692856">SQ_MASK_DEST_ADDR</a>(dest))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask dest to Store Queue area as pointer. </p>

</div>
</div>
<a id="gae3f3b19cc818d9be2940facc19692856" name="gae3f3b19cc818d9be2940facc19692856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3f3b19cc818d9be2940facc19692856">&#9670;&#160;</a></span>SQ_MASK_DEST_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SQ_MASK_DEST_ADDR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dest</td><td>)</td>
          <td>&#160;&#160;&#160;    (<a class="el" href="group__p4mem.html#gac9490e36164a490e0024572e9c4688c5">MEM_AREA_SQ_BASE</a> | ((uintptr_t)(dest) &amp; 0x03ffffe0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask dest to Store Queue area as address. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga092fe09c19d32ce2fc6fc4f506c60070" name="ga092fe09c19d32ce2fc6fc4f506c60070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga092fe09c19d32ce2fc6fc4f506c60070">&#9670;&#160;</a></span>pvr_sq_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * pvr_sq_load </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a block of memory to VRAM. </p>
<p>This function is similar to <a class="el" href="group__store__queues.html#ga8dcb6016c825d951d5aacd15fd137b89" title="Copy a block of memory.">sq_cpy()</a>, but it has been optimized for writing to a destination residing within VRAM.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function cannot be used at the same time as a PVR DMA transfer.</dd></dl>
<p>The dest pointer must be at least 32-byte aligned and reside in video memory, the src pointer must be at least 8-byte aligned, and n must be a multiple of 32.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The address to copy to (32-byte aligned). </td></tr>
    <tr><td class="paramname">src</td><td>The address to copy from (32-bit (8-byte) aligned). </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to copy (multiple of 32). </td></tr>
    <tr><td class="paramname">type</td><td>The type of SQ/DMA transfer to do (see list of modes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value of dest.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__store__queues.html#ga4b11c4381d550a1deb9b2aefd82b80c4" title="Set a block of PVR memory to a 32-bit value.">pvr_sq_set32()</a> </dd></dl>

</div>
</div>
<a id="ga54cbcd67f3f7bb01334b8e620c50fbf5" name="ga54cbcd67f3f7bb01334b8e620c50fbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54cbcd67f3f7bb01334b8e620c50fbf5">&#9670;&#160;</a></span>pvr_sq_set16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * pvr_sq_set16 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a block of PVR memory to a 16-bit value. </p>
<p>This function is similar to <a class="el" href="group__store__queues.html#ga30f23e7f5106da1dc68c773b9e7306a5" title="Set a block of memory to a 16-bit value.">sq_set16()</a>, but it has been optimized for writing to a destination residing within VRAM.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function cannot be used at the same time as a PVR DMA transfer.</dd></dl>
<p>The dest pointer must be at least 32-byte aligned and reside in video memory, n must be a multiple of 32 and only the low 16-bits are used from c.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The address to begin setting at (32-byte aligned). </td></tr>
    <tr><td class="paramname">c</td><td>The value to set (in the low 16-bits). </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to set (multiple of 32). </td></tr>
    <tr><td class="paramname">type</td><td>The type of SQ/DMA transfer to do (see list of modes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value of dest.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__store__queues.html#ga4b11c4381d550a1deb9b2aefd82b80c4" title="Set a block of PVR memory to a 32-bit value.">pvr_sq_set32()</a> </dd></dl>

</div>
</div>
<a id="ga4b11c4381d550a1deb9b2aefd82b80c4" name="ga4b11c4381d550a1deb9b2aefd82b80c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b11c4381d550a1deb9b2aefd82b80c4">&#9670;&#160;</a></span>pvr_sq_set32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * pvr_sq_set32 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a block of PVR memory to a 32-bit value. </p>
<p>This function is similar to <a class="el" href="group__store__queues.html#ga31a2bae1ddf089207a59b1dc29c3ffb4" title="Set a block of memory to a 32-bit value.">sq_set32()</a>, but it has been optimized for writing to a destination residing within VRAM.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function cannot be used at the same time as a PVR DMA transfer.</dd></dl>
<p>The dest pointer must be at least 32-byte aligned and reside in video memory, n must be a multiple of 32.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The address to begin setting at (32-byte aligned). </td></tr>
    <tr><td class="paramname">c</td><td>The value to set. </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to set (multiple of 32). </td></tr>
    <tr><td class="paramname">type</td><td>The type of SQ/DMA transfer to do (see list of modes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value of dest.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__store__queues.html#ga54cbcd67f3f7bb01334b8e620c50fbf5" title="Set a block of PVR memory to a 16-bit value.">pvr_sq_set16</a> </dd></dl>

</div>
</div>
<a id="gae7c2c6f4ce37eaa9d886efbbd0fa2ec5" name="gae7c2c6f4ce37eaa9d886efbbd0fa2ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7c2c6f4ce37eaa9d886efbbd0fa2ec5">&#9670;&#160;</a></span>sq_clr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sq_clr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a block of memory. </p>
<p>This function is similar to calling memset() with a value to set of 0, but uses the store queues to do its work.</p>
<dl class="section warning"><dt>Warning</dt><dd>The dest pointer must be a 32-byte aligned with n being a multiple of 32!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The address to begin clearing at (32-byte aligned). </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to clear (multiple of 32). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8dcb6016c825d951d5aacd15fd137b89" name="ga8dcb6016c825d951d5aacd15fd137b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dcb6016c825d951d5aacd15fd137b89">&#9670;&#160;</a></span>sq_cpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * sq_cpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a block of memory. </p>
<p>This function is similar to <a class="el" href="group__system__types.html#ga5ec67da835a014140d3cbe2f14925476" title="Copy a block of memory, 4 bytes at a time.">memcpy4()</a>, but uses the store queues to do its work.</p>
<dl class="section warning"><dt>Warning</dt><dd>The dest pointer must be at least 32-byte aligned, the src pointer must be at least 4-byte aligned (8-byte aligned uses fast path), and n must be a multiple of 32!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The address to copy to (32-byte aligned). </td></tr>
    <tr><td class="paramname">src</td><td>The address to copy from (32-bit (4/8-byte) aligned). </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to copy (multiple of 32). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value of dest.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__store__queues.html#ga169559fc4410135c325025b6ee579a24" title="Copy a block of memory.">sq_fast_cpy()</a> </dd></dl>

</div>
</div>
<a id="ga169559fc4410135c325025b6ee579a24" name="ga169559fc4410135c325025b6ee579a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga169559fc4410135c325025b6ee579a24">&#9670;&#160;</a></span>sq_fast_cpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * sq_fast_cpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a block of memory. </p>
<p>This function is similar to <a class="el" href="group__store__queues.html#ga8dcb6016c825d951d5aacd15fd137b89" title="Copy a block of memory.">sq_cpy()</a> but expects the user to lock/unlock the store queues before and after as well as having different requirements for the params.</p>
<dl class="section warning"><dt>Warning</dt><dd>The dest pointer must be at least 32-byte aligned that already has been masked by <a class="el" href="group__store__queues.html#gae368a79b7f862bbdd28e89f8fd717a97" title="Mask dest to Store Queue area as pointer.">SQ_MASK_DEST()</a>, the src pointer must be at least 8-byte aligned, and n must be the number of 32-byte blocks you want to copy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The store queue address to copy to (32-byte aligned). </td></tr>
    <tr><td class="paramname">src</td><td>The address to copy from (8-byte aligned). </td></tr>
    <tr><td class="paramname">n</td><td>The number of 32-byte blocks to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value of dest.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__store__queues.html#ga8dcb6016c825d951d5aacd15fd137b89" title="Copy a block of memory.">sq_cpy()</a> </dd></dl>

</div>
</div>
<a id="ga34060d140ecea2a5da87e14f7071d268" name="ga34060d140ecea2a5da87e14f7071d268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34060d140ecea2a5da87e14f7071d268">&#9670;&#160;</a></span>sq_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sq_lock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock Store Queues. </p>
<p>Locks the store queues so that they cannot be used from another thread until unlocked.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is called automatically by the store queue API provided by KOS; however, it must be called manually when driving the SQs directly from outside of this API.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__store__queues.html#ga83fe109b27f9e7069beeb60c334bd563" title="Unlock Store Queues.">sq_unlock()</a> </dd></dl>

</div>
</div>
<a id="ga1ff22db673ec9c9bca4485fcd00a039f" name="ga1ff22db673ec9c9bca4485fcd00a039f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ff22db673ec9c9bca4485fcd00a039f">&#9670;&#160;</a></span>sq_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * sq_set </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a block of memory to an 8-bit value. </p>
<p>This function is similar to calling memset(), but uses the store queues to do its work.</p>
<dl class="section warning"><dt>Warning</dt><dd>The dest pointer must be a 32-byte aligned with n being a multiple of 32, and only the low 8-bits are used from c.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The address to begin setting at (32-byte aligned). </td></tr>
    <tr><td class="paramname">c</td><td>The value to set (in the low 8-bits). </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to set (multiple of 32). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value of dest.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__store__queues.html#ga30f23e7f5106da1dc68c773b9e7306a5" title="Set a block of memory to a 16-bit value.">sq_set16()</a>, <a class="el" href="group__store__queues.html#ga31a2bae1ddf089207a59b1dc29c3ffb4" title="Set a block of memory to a 32-bit value.">sq_set32()</a> </dd></dl>

</div>
</div>
<a id="ga30f23e7f5106da1dc68c773b9e7306a5" name="ga30f23e7f5106da1dc68c773b9e7306a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30f23e7f5106da1dc68c773b9e7306a5">&#9670;&#160;</a></span>sq_set16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * sq_set16 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a block of memory to a 16-bit value. </p>
<p>This function is similar to calling <a class="el" href="group__system__types.html#ga8bfb449cc3354d2f9f4933db730fabd2" title="Set a block of memory, 2 bytes at a time.">memset2()</a>, but uses the store queues to do its work.</p>
<dl class="section warning"><dt>Warning</dt><dd>The dest pointer must be a 32-byte aligned with n being a multiple of 32, and only the low 16-bits are used from c.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The address to begin setting at (32-byte aligned). </td></tr>
    <tr><td class="paramname">c</td><td>The value to set (in the low 16-bits). </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to set (multiple of 32). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value of dest.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__store__queues.html#ga1ff22db673ec9c9bca4485fcd00a039f" title="Set a block of memory to an 8-bit value.">sq_set()</a>, <a class="el" href="group__store__queues.html#ga31a2bae1ddf089207a59b1dc29c3ffb4" title="Set a block of memory to a 32-bit value.">sq_set32()</a> </dd></dl>

</div>
</div>
<a id="ga31a2bae1ddf089207a59b1dc29c3ffb4" name="ga31a2bae1ddf089207a59b1dc29c3ffb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31a2bae1ddf089207a59b1dc29c3ffb4">&#9670;&#160;</a></span>sq_set32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * sq_set32 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a block of memory to a 32-bit value. </p>
<p>This function is similar to calling <a class="el" href="group__system__types.html#gaa60ff67301aee11d4360c056f30236eb" title="Set a block of memory, 4 bytes at a time.">memset4()</a>, but uses the store queues to do its work.</p>
<dl class="section warning"><dt>Warning</dt><dd>The dest pointer must be a 32-byte aligned with n being a multiple of 32!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The address to begin setting at (32-byte aligned). </td></tr>
    <tr><td class="paramname">c</td><td>The value to set (all 32-bits). </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to set (multiple of 32). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value of dest.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__store__queues.html#ga1ff22db673ec9c9bca4485fcd00a039f" title="Set a block of memory to an 8-bit value.">sq_set()</a>, <a class="el" href="group__store__queues.html#ga30f23e7f5106da1dc68c773b9e7306a5" title="Set a block of memory to a 16-bit value.">sq_set16()</a> </dd></dl>

</div>
</div>
<a id="ga83fe109b27f9e7069beeb60c334bd563" name="ga83fe109b27f9e7069beeb60c334bd563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83fe109b27f9e7069beeb60c334bd563">&#9670;&#160;</a></span>sq_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sq_unlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock Store Queues. </p>
<p>Unlocks the store queues so that they can be used from any thread.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__store__queues.html#ga34060d140ecea2a5da87e14f7071d268" title="Lock Store Queues.">sq_lock()</a> should've already been called previously.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="group__store__queues.html#ga34060d140ecea2a5da87e14f7071d268" title="Lock Store Queues.">sq_lock()</a> and <a class="el" href="group__store__queues.html#ga83fe109b27f9e7069beeb60c334bd563" title="Unlock Store Queues.">sq_unlock()</a> are called automatically by the store queue API provided by KOS; however, they must be called manually when driving the SQs directly from outside this API.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__store__queues.html#ga34060d140ecea2a5da87e14f7071d268" title="Lock Store Queues.">sq_lock()</a> </dd></dl>

</div>
</div>
<a id="ga2b2f05baceca5ef17dd21ba056ea1113" name="ga2b2f05baceca5ef17dd21ba056ea1113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b2f05baceca5ef17dd21ba056ea1113">&#9670;&#160;</a></span>sq_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sq_wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for both Store Queues to complete. </p>
<p>Wait for both store queues to complete by writing to SQ area.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__store__queues.html#ga34060d140ecea2a5da87e14f7071d268" title="Lock Store Queues.">sq_lock()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
