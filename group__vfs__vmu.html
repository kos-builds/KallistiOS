<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KallistiOS: VMU</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">KallistiOS<span id="projectnumber">&#160;##version##</span>
   </div>
   <div id="projectbrief">Independent SDK for the Sega Dreamcast</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__vfs__vmu.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">VMU<div class="ingroups"><a class="el" href="group__vfs.html">Filesystem</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>VFS driver for accessing Visual Memory Unit storage.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:fs__vmu_8h" id="r_fs__vmu_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fs__vmu_8h.html">fs_vmu.h</a></td></tr>
<tr class="memdesc:fs__vmu_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">VMU filesystem driver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:vmufs_8h" id="r_vmufs_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vmufs_8h.html">vmufs.h</a></td></tr>
<tr class="memdesc:vmufs_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level VMU filesystem driver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvmu__timestamp__t.html">vmu_timestamp_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">BCD timestamp, used several places in the vmufs.  <a href="structvmu__timestamp__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvmu__root__t.html">vmu_root_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">VMU FS Root block layout.  <a href="structvmu__root__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvmu__dir__t.html">vmu_dir_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">VMU FS Directory entries, 32 bytes each.  <a href="structvmu__dir__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gafbed836ca1265630c350a957c90dcbe7" id="r_gafbed836ca1265630c350a957c90dcbe7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#gafbed836ca1265630c350a957c90dcbe7">VMUFS_OVERWRITE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gafbed836ca1265630c350a957c90dcbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite existing files.  <br /></td></tr>
<tr class="separator:gafbed836ca1265630c350a957c90dcbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc51d734de26b769d13d418c359dda0" id="r_ga6cc51d734de26b769d13d418c359dda0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#ga6cc51d734de26b769d13d418c359dda0">VMUFS_VMUGAME</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga6cc51d734de26b769d13d418c359dda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file is a VMU game.  <br /></td></tr>
<tr class="separator:ga6cc51d734de26b769d13d418c359dda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7200ea5832decc8605e7b4ca10d0756" id="r_gac7200ea5832decc8605e7b4ca10d0756"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#gac7200ea5832decc8605e7b4ca10d0756">VMUFS_NOCOPY</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:gac7200ea5832decc8605e7b4ca10d0756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the no-copy flag.  <br /></td></tr>
<tr class="separator:gac7200ea5832decc8605e7b4ca10d0756"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad08c7bd843c8ef21174caecf6a47d7e7" id="r_gad08c7bd843c8ef21174caecf6a47d7e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#gad08c7bd843c8ef21174caecf6a47d7e7">vmufs_dir_fill_time</a> (<a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *d)</td></tr>
<tr class="memdesc:gad08c7bd843c8ef21174caecf6a47d7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in the date on a <a class="el" href="structvmu__dir__t.html" title="VMU FS Directory entries, 32 bytes each.">vmu_dir_t</a> for writing.  <br /></td></tr>
<tr class="separator:gad08c7bd843c8ef21174caecf6a47d7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ea06e7b8b671558f2a57755f7bfc10c" id="r_ga1ea06e7b8b671558f2a57755f7bfc10c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#ga1ea06e7b8b671558f2a57755f7bfc10c">vmufs_root_read</a> (<a class="el" href="structmaple__device__t.html">maple_device_t</a> *dev, <a class="el" href="structvmu__root__t.html">vmu_root_t</a> *root_buf)</td></tr>
<tr class="memdesc:ga1ea06e7b8b671558f2a57755f7bfc10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a selected VMU's root block.  <br /></td></tr>
<tr class="separator:ga1ea06e7b8b671558f2a57755f7bfc10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae2f2d1594e0f27ea23df05f4f5f7409" id="r_gaae2f2d1594e0f27ea23df05f4f5f7409"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#gaae2f2d1594e0f27ea23df05f4f5f7409">vmufs_root_write</a> (<a class="el" href="structmaple__device__t.html">maple_device_t</a> *dev, <a class="el" href="structvmu__root__t.html">vmu_root_t</a> *root_buf)</td></tr>
<tr class="memdesc:gaae2f2d1594e0f27ea23df05f4f5f7409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a selected VMU's root block.  <br /></td></tr>
<tr class="separator:gaae2f2d1594e0f27ea23df05f4f5f7409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fa3a9de375757a814f6b821858388c1" id="r_ga2fa3a9de375757a814f6b821858388c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#ga2fa3a9de375757a814f6b821858388c1">vmufs_dir_blocks</a> (<a class="el" href="structvmu__root__t.html">vmu_root_t</a> *root_buf)</td></tr>
<tr class="memdesc:ga2fa3a9de375757a814f6b821858388c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a VMU's root block, return the amount of space in bytes required to hold its directory.  <br /></td></tr>
<tr class="separator:ga2fa3a9de375757a814f6b821858388c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1a5a29fd8786862bd4f323222961f01" id="r_gaf1a5a29fd8786862bd4f323222961f01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#gaf1a5a29fd8786862bd4f323222961f01">vmufs_fat_blocks</a> (<a class="el" href="structvmu__root__t.html">vmu_root_t</a> *root_buf)</td></tr>
<tr class="memdesc:gaf1a5a29fd8786862bd4f323222961f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a VMU's root block, return the amount of space in bytes required to hold its FAT.  <br /></td></tr>
<tr class="separator:gaf1a5a29fd8786862bd4f323222961f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad571bb2a9143bee5ef408f9dbc86e8fa" id="r_gad571bb2a9143bee5ef408f9dbc86e8fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#gad571bb2a9143bee5ef408f9dbc86e8fa">vmufs_dir_read</a> (<a class="el" href="structmaple__device__t.html">maple_device_t</a> *dev, <a class="el" href="structvmu__root__t.html">vmu_root_t</a> *root_buf, <a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *dir_buf)</td></tr>
<tr class="memdesc:gad571bb2a9143bee5ef408f9dbc86e8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a selected VMU's root block, read its directory.  <br /></td></tr>
<tr class="separator:gad571bb2a9143bee5ef408f9dbc86e8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e16c369e8c01f10570a29235e5f269b" id="r_ga4e16c369e8c01f10570a29235e5f269b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#ga4e16c369e8c01f10570a29235e5f269b">vmufs_dir_write</a> (<a class="el" href="structmaple__device__t.html">maple_device_t</a> *dev, <a class="el" href="structvmu__root__t.html">vmu_root_t</a> *root, <a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *dir_buf)</td></tr>
<tr class="memdesc:ga4e16c369e8c01f10570a29235e5f269b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a selected VMU's root block and dir blocks, write the dirty dir blocks back to the VMU. Assumes the mutex is held.  <br /></td></tr>
<tr class="separator:ga4e16c369e8c01f10570a29235e5f269b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c58d2d63a3a8ddfe8a1812f9493755a" id="r_ga5c58d2d63a3a8ddfe8a1812f9493755a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#ga5c58d2d63a3a8ddfe8a1812f9493755a">vmufs_fat_read</a> (<a class="el" href="structmaple__device__t.html">maple_device_t</a> *dev, <a class="el" href="structvmu__root__t.html">vmu_root_t</a> *root, <a class="el" href="group__system__types.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *fat_buf)</td></tr>
<tr class="memdesc:ga5c58d2d63a3a8ddfe8a1812f9493755a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a selected VMU's root block, read its FAT.  <br /></td></tr>
<tr class="separator:ga5c58d2d63a3a8ddfe8a1812f9493755a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13b85e04e86a0723988b97f7b4115309" id="r_ga13b85e04e86a0723988b97f7b4115309"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#ga13b85e04e86a0723988b97f7b4115309">vmufs_fat_write</a> (<a class="el" href="structmaple__device__t.html">maple_device_t</a> *dev, <a class="el" href="structvmu__root__t.html">vmu_root_t</a> *root, <a class="el" href="group__system__types.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *fat_buf)</td></tr>
<tr class="memdesc:ga13b85e04e86a0723988b97f7b4115309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a selected VMU's root block and its FAT, write the FAT blocks back to the VMU.  <br /></td></tr>
<tr class="separator:ga13b85e04e86a0723988b97f7b4115309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f6a4f2d34fb29c7a1ad4519d92bed2" id="r_gaf6f6a4f2d34fb29c7a1ad4519d92bed2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#gaf6f6a4f2d34fb29c7a1ad4519d92bed2">vmufs_dir_find</a> (<a class="el" href="structvmu__root__t.html">vmu_root_t</a> *root, <a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *dir, const char *fn)</td></tr>
<tr class="memdesc:gaf6f6a4f2d34fb29c7a1ad4519d92bed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a previously-read directory, locate a file by filename.  <br /></td></tr>
<tr class="separator:gaf6f6a4f2d34fb29c7a1ad4519d92bed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d3fee989033191d08dece515b3fc4f8" id="r_ga4d3fee989033191d08dece515b3fc4f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#ga4d3fee989033191d08dece515b3fc4f8">vmufs_dir_add</a> (<a class="el" href="structvmu__root__t.html">vmu_root_t</a> *root, <a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *dir, <a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *newdirent)</td></tr>
<tr class="memdesc:ga4d3fee989033191d08dece515b3fc4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a previously-read directory, add a new dirent to the dir.  <br /></td></tr>
<tr class="separator:ga4d3fee989033191d08dece515b3fc4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb06fd772aad39ee1bc7453cf4b0e094" id="r_gaeb06fd772aad39ee1bc7453cf4b0e094"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#gaeb06fd772aad39ee1bc7453cf4b0e094">vmufs_file_read</a> (<a class="el" href="structmaple__device__t.html">maple_device_t</a> *dev, <a class="el" href="group__system__types.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *fat, <a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *<a class="el" href="structdirent.html">dirent</a>, void *outbuf)</td></tr>
<tr class="memdesc:gaeb06fd772aad39ee1bc7453cf4b0e094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pointer to a directory struct and a previously loaded FAT, load the indicated file from the VMU.  <br /></td></tr>
<tr class="separator:gaeb06fd772aad39ee1bc7453cf4b0e094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga543caffb2db3e5edb45ff7e7db82b928" id="r_ga543caffb2db3e5edb45ff7e7db82b928"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#ga543caffb2db3e5edb45ff7e7db82b928">vmufs_file_write</a> (<a class="el" href="structmaple__device__t.html">maple_device_t</a> *dev, <a class="el" href="structvmu__root__t.html">vmu_root_t</a> *root, <a class="el" href="group__system__types.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *fat, <a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *dir, <a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *newdirent, void *filebuf, int size)</td></tr>
<tr class="memdesc:ga543caffb2db3e5edb45ff7e7db82b928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pointer to a mostly-filled directory struct and a previously loaded directory and FAT, write the indicated file to the VMU.  <br /></td></tr>
<tr class="separator:ga543caffb2db3e5edb45ff7e7db82b928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac730e178e3c3343a9e5175252a65015d" id="r_gac730e178e3c3343a9e5175252a65015d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#gac730e178e3c3343a9e5175252a65015d">vmufs_file_delete</a> (<a class="el" href="structvmu__root__t.html">vmu_root_t</a> *root, <a class="el" href="group__system__types.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *fat, <a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *dir, const char *fn)</td></tr>
<tr class="memdesc:gac730e178e3c3343a9e5175252a65015d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a previously-read FAT and directory, delete the named file.  <br /></td></tr>
<tr class="separator:gac730e178e3c3343a9e5175252a65015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefbcbec75ab5706b148411e178133211" id="r_gaefbcbec75ab5706b148411e178133211"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#gaefbcbec75ab5706b148411e178133211">vmufs_fat_free</a> (<a class="el" href="structvmu__root__t.html">vmu_root_t</a> *root, <a class="el" href="group__system__types.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *fat)</td></tr>
<tr class="memdesc:gaefbcbec75ab5706b148411e178133211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a previously-read FAT, return the number of blocks available to write out new file data.  <br /></td></tr>
<tr class="separator:gaefbcbec75ab5706b148411e178133211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae855f64e7ee46404d436fd86bd3b1260" id="r_gae855f64e7ee46404d436fd86bd3b1260"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#gae855f64e7ee46404d436fd86bd3b1260">vmufs_dir_free</a> (<a class="el" href="structvmu__root__t.html">vmu_root_t</a> *root, <a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *dir)</td></tr>
<tr class="memdesc:gae855f64e7ee46404d436fd86bd3b1260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a previously-read directory, return the number of dirents available for new files.  <br /></td></tr>
<tr class="separator:gae855f64e7ee46404d436fd86bd3b1260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85e3a67dc238f019030b6f444dd3fd34" id="r_ga85e3a67dc238f019030b6f444dd3fd34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#ga85e3a67dc238f019030b6f444dd3fd34">vmufs_mutex_lock</a> (void)</td></tr>
<tr class="memdesc:ga85e3a67dc238f019030b6f444dd3fd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the vmufs mutex.  <br /></td></tr>
<tr class="separator:ga85e3a67dc238f019030b6f444dd3fd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef1e03ad75d45013b6ca6a80a43f04c4" id="r_gaef1e03ad75d45013b6ca6a80a43f04c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#gaef1e03ad75d45013b6ca6a80a43f04c4">vmufs_mutex_unlock</a> (void)</td></tr>
<tr class="memdesc:gaef1e03ad75d45013b6ca6a80a43f04c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the vmufs mutex.  <br /></td></tr>
<tr class="separator:gaef1e03ad75d45013b6ca6a80a43f04c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4b569ab35ef840096b502eb845ce26f" id="r_gaa4b569ab35ef840096b502eb845ce26f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#gaa4b569ab35ef840096b502eb845ce26f">vmufs_readdir</a> (<a class="el" href="structmaple__device__t.html">maple_device_t</a> *dev, <a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> **outbuf, int *outcnt)</td></tr>
<tr class="memdesc:gaa4b569ab35ef840096b502eb845ce26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the directory from a VMU.  <br /></td></tr>
<tr class="separator:gaa4b569ab35ef840096b502eb845ce26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7154724fbfccfc95413050e2ca36591" id="r_gab7154724fbfccfc95413050e2ca36591"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#gab7154724fbfccfc95413050e2ca36591">vmufs_read</a> (<a class="el" href="structmaple__device__t.html">maple_device_t</a> *dev, const char *fn, void **outbuf, int *outsize)</td></tr>
<tr class="memdesc:gab7154724fbfccfc95413050e2ca36591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a file from the VMU.  <br /></td></tr>
<tr class="separator:gab7154724fbfccfc95413050e2ca36591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf2ccb874a60cd6fea109039613a9bae" id="r_gaaf2ccb874a60cd6fea109039613a9bae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#gaaf2ccb874a60cd6fea109039613a9bae">vmufs_read_dirent</a> (<a class="el" href="structmaple__device__t.html">maple_device_t</a> *dev, <a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *<a class="el" href="structdirent.html">dirent</a>, void **outbuf, int *outsize)</td></tr>
<tr class="memdesc:gaaf2ccb874a60cd6fea109039613a9bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a file from the VMU, using a pre-read dirent.  <br /></td></tr>
<tr class="separator:gaaf2ccb874a60cd6fea109039613a9bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9930f10c9f93aafd30c8f769024fec06" id="r_ga9930f10c9f93aafd30c8f769024fec06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#ga9930f10c9f93aafd30c8f769024fec06">vmufs_write</a> (<a class="el" href="structmaple__device__t.html">maple_device_t</a> *dev, const char *fn, void *inbuf, int insize, int flags)</td></tr>
<tr class="memdesc:ga9930f10c9f93aafd30c8f769024fec06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a file to the VMU.  <br /></td></tr>
<tr class="separator:ga9930f10c9f93aafd30c8f769024fec06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec34ccd6dd9e062a6fa154744d7ebb7" id="r_ga9ec34ccd6dd9e062a6fa154744d7ebb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#ga9ec34ccd6dd9e062a6fa154744d7ebb7">vmufs_delete</a> (<a class="el" href="structmaple__device__t.html">maple_device_t</a> *dev, const char *fn)</td></tr>
<tr class="memdesc:ga9ec34ccd6dd9e062a6fa154744d7ebb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a file from the VMU.  <br /></td></tr>
<tr class="separator:ga9ec34ccd6dd9e062a6fa154744d7ebb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5893b3e06b372758f22f4a8be5d7d8e" id="r_gaa5893b3e06b372758f22f4a8be5d7d8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#gaa5893b3e06b372758f22f4a8be5d7d8e">vmufs_free_blocks</a> (<a class="el" href="structmaple__device__t.html">maple_device_t</a> *dev)</td></tr>
<tr class="memdesc:gaa5893b3e06b372758f22f4a8be5d7d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of user blocks free for file writing.  <br /></td></tr>
<tr class="separator:gaa5893b3e06b372758f22f4a8be5d7d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8c429cb914f6fa53d44a6f3e753182f" id="r_gad8c429cb914f6fa53d44a6f3e753182f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#gad8c429cb914f6fa53d44a6f3e753182f">vmufs_init</a> (void)</td></tr>
<tr class="memdesc:gad8c429cb914f6fa53d44a6f3e753182f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize vmufs.  <br /></td></tr>
<tr class="separator:gad8c429cb914f6fa53d44a6f3e753182f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga319a6303bfe003dd459fe79ffe4a7738" id="r_ga319a6303bfe003dd459fe79ffe4a7738"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs__vmu.html#ga319a6303bfe003dd459fe79ffe4a7738">vmufs_shutdown</a> (void)</td></tr>
<tr class="memdesc:ga319a6303bfe003dd459fe79ffe4a7738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown vmufs.  <br /></td></tr>
<tr class="separator:ga319a6303bfe003dd459fe79ffe4a7738"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>VFS driver for accessing Visual Memory Unit storage. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gac7200ea5832decc8605e7b4ca10d0756" name="gac7200ea5832decc8605e7b4ca10d0756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7200ea5832decc8605e7b4ca10d0756">&#9670;&#160;</a></span>VMUFS_NOCOPY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMUFS_NOCOPY&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the no-copy flag. </p>

</div>
</div>
<a id="gafbed836ca1265630c350a957c90dcbe7" name="gafbed836ca1265630c350a957c90dcbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbed836ca1265630c350a957c90dcbe7">&#9670;&#160;</a></span>VMUFS_OVERWRITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMUFS_OVERWRITE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrite existing files. </p>

</div>
</div>
<a id="ga6cc51d734de26b769d13d418c359dda0" name="ga6cc51d734de26b769d13d418c359dda0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cc51d734de26b769d13d418c359dda0">&#9670;&#160;</a></span>VMUFS_VMUGAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMUFS_VMUGAME&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This file is a VMU game. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9ec34ccd6dd9e062a6fa154744d7ebb7" name="ga9ec34ccd6dd9e062a6fa154744d7ebb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ec34ccd6dd9e062a6fa154744d7ebb7">&#9670;&#160;</a></span>vmufs_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmaple__device__t.html">maple_device_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a file from the VMU. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>If the file is not found. </td></tr>
    <tr><td class="paramname">-2</td><td>On other failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4d3fee989033191d08dece515b3fc4f8" name="ga4d3fee989033191d08dece515b3fc4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d3fee989033191d08dece515b3fc4f8">&#9670;&#160;</a></span>vmufs_dir_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_dir_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvmu__root__t.html">vmu_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *&#160;</td>
          <td class="paramname"><em>newdirent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a previously-read directory, add a new dirent to the dir. </p>
<p>Another file with the same name should not exist (delete it first if it does). This function will not check for dupes!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The VMU root block. </td></tr>
    <tr><td class="paramname">dir</td><td>The VMU directory. </td></tr>
    <tr><td class="paramname">newdirent</td><td>The new entry to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or &lt;0 on failure. </dd></dl>

</div>
</div>
<a id="ga2fa3a9de375757a814f6b821858388c1" name="ga2fa3a9de375757a814f6b821858388c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fa3a9de375757a814f6b821858388c1">&#9670;&#160;</a></span>vmufs_dir_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_dir_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvmu__root__t.html">vmu_root_t</a> *&#160;</td>
          <td class="paramname"><em>root_buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a VMU's root block, return the amount of space in bytes required to hold its directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_buf</td><td>The root block to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of space, in bytes, needed. </dd></dl>

</div>
</div>
<a id="gad08c7bd843c8ef21174caecf6a47d7e7" name="gad08c7bd843c8ef21174caecf6a47d7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad08c7bd843c8ef21174caecf6a47d7e7">&#9670;&#160;</a></span>vmufs_dir_fill_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmufs_dir_fill_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill in the date on a <a class="el" href="structvmu__dir__t.html" title="VMU FS Directory entries, 32 bytes each.">vmu_dir_t</a> for writing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The directory to fill in the date on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf6f6a4f2d34fb29c7a1ad4519d92bed2" name="gaf6f6a4f2d34fb29c7a1ad4519d92bed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6f6a4f2d34fb29c7a1ad4519d92bed2">&#9670;&#160;</a></span>vmufs_dir_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_dir_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvmu__root__t.html">vmu_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a previously-read directory, locate a file by filename. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The VMU root block. </td></tr>
    <tr><td class="paramname">dir</td><td>The VMU directory. </td></tr>
    <tr><td class="paramname">fn</td><td>The file to find (only checked up to 12 chars). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index into the directory array on success, or &lt;0 on failure. </dd></dl>

</div>
</div>
<a id="gae855f64e7ee46404d436fd86bd3b1260" name="gae855f64e7ee46404d436fd86bd3b1260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae855f64e7ee46404d436fd86bd3b1260">&#9670;&#160;</a></span>vmufs_dir_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_dir_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvmu__root__t.html">vmu_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a previously-read directory, return the number of dirents available for new files. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The VMU root block. </td></tr>
    <tr><td class="paramname">dir</td><td>The directory in question. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of entries available. </dd></dl>

</div>
</div>
<a id="gad571bb2a9143bee5ef408f9dbc86e8fa" name="gad571bb2a9143bee5ef408f9dbc86e8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad571bb2a9143bee5ef408f9dbc86e8fa">&#9670;&#160;</a></span>vmufs_dir_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_dir_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmaple__device__t.html">maple_device_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__root__t.html">vmu_root_t</a> *&#160;</td>
          <td class="paramname"><em>root_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *&#160;</td>
          <td class="paramname"><em>dir_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a selected VMU's root block, read its directory. </p>
<p>This function reads the directory of a given VMU root block. It assumes the mutex is held. There must be at least the number of bytes returned by <a class="el" href="group__vfs__vmu.html#ga2fa3a9de375757a814f6b821858388c1" title="Given a VMU&#39;s root block, return the amount of space in bytes required to hold its directory.">vmufs_dir_blocks()</a> available in the buffer for this to succeed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The VMU to read. </td></tr>
    <tr><td class="paramname">root_buf</td><td>The VMU's root block. </td></tr>
    <tr><td class="paramname">dir_buf</td><td>The buffer to hold the directory. You must have allocated this yourself. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0 on failure. </dd></dl>

</div>
</div>
<a id="ga4e16c369e8c01f10570a29235e5f269b" name="ga4e16c369e8c01f10570a29235e5f269b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e16c369e8c01f10570a29235e5f269b">&#9670;&#160;</a></span>vmufs_dir_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_dir_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmaple__device__t.html">maple_device_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__root__t.html">vmu_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *&#160;</td>
          <td class="paramname"><em>dir_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a selected VMU's root block and dir blocks, write the dirty dir blocks back to the VMU. Assumes the mutex is held. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The VMU to write to. </td></tr>
    <tr><td class="paramname">root</td><td>The VMU's root block. </td></tr>
    <tr><td class="paramname">dir_buf</td><td>The VMU's directory structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0 on failure. </dd></dl>

</div>
</div>
<a id="gaf1a5a29fd8786862bd4f323222961f01" name="gaf1a5a29fd8786862bd4f323222961f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1a5a29fd8786862bd4f323222961f01">&#9670;&#160;</a></span>vmufs_fat_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_fat_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvmu__root__t.html">vmu_root_t</a> *&#160;</td>
          <td class="paramname"><em>root_buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a VMU's root block, return the amount of space in bytes required to hold its FAT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_buf</td><td>The root block to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of space, in bytes, needed. </dd></dl>

</div>
</div>
<a id="gaefbcbec75ab5706b148411e178133211" name="gaefbcbec75ab5706b148411e178133211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefbcbec75ab5706b148411e178133211">&#9670;&#160;</a></span>vmufs_fat_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_fat_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvmu__root__t.html">vmu_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__system__types.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *&#160;</td>
          <td class="paramname"><em>fat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a previously-read FAT, return the number of blocks available to write out new file data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The VMU root block. </td></tr>
    <tr><td class="paramname">fat</td><td>The FAT to be examined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of blocks available. </dd></dl>

</div>
</div>
<a id="ga5c58d2d63a3a8ddfe8a1812f9493755a" name="ga5c58d2d63a3a8ddfe8a1812f9493755a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c58d2d63a3a8ddfe8a1812f9493755a">&#9670;&#160;</a></span>vmufs_fat_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_fat_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmaple__device__t.html">maple_device_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__root__t.html">vmu_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__system__types.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *&#160;</td>
          <td class="paramname"><em>fat_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a selected VMU's root block, read its FAT. </p>
<p>This function reads the FAT of a VMU, given its root block. It assumes the mutex is held. There must be at least the number of bytes returned by <a class="el" href="group__vfs__vmu.html#gaf1a5a29fd8786862bd4f323222961f01" title="Given a VMU&#39;s root block, return the amount of space in bytes required to hold its FAT.">vmufs_fat_blocks()</a> available in the buffer for this to succeed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The VMU to read from. </td></tr>
    <tr><td class="paramname">root</td><td>The VMU's root block. </td></tr>
    <tr><td class="paramname">fat_buf</td><td>The buffer to store the FAT into. You must pre-allocate this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0 on failure. </dd></dl>

</div>
</div>
<a id="ga13b85e04e86a0723988b97f7b4115309" name="ga13b85e04e86a0723988b97f7b4115309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13b85e04e86a0723988b97f7b4115309">&#9670;&#160;</a></span>vmufs_fat_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_fat_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmaple__device__t.html">maple_device_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__root__t.html">vmu_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__system__types.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *&#160;</td>
          <td class="paramname"><em>fat_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a selected VMU's root block and its FAT, write the FAT blocks back to the VMU. </p>
<p>This function assumes the mutex is held.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The VMU to write to. </td></tr>
    <tr><td class="paramname">root</td><td>The VMU's root block. </td></tr>
    <tr><td class="paramname">fat_buf</td><td>The buffer to write to the FAT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0 on failure. </dd></dl>

</div>
</div>
<a id="gac730e178e3c3343a9e5175252a65015d" name="gac730e178e3c3343a9e5175252a65015d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac730e178e3c3343a9e5175252a65015d">&#9670;&#160;</a></span>vmufs_file_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_file_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvmu__root__t.html">vmu_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__system__types.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *&#160;</td>
          <td class="paramname"><em>fat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a previously-read FAT and directory, delete the named file. </p>
<p>No changes are made to the VMU itself, just the in-memory structs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The VMU root block. </td></tr>
    <tr><td class="paramname">fat</td><td>The FAT to be modified. </td></tr>
    <tr><td class="paramname">dir</td><td>The directory to be modified. </td></tr>
    <tr><td class="paramname">fn</td><td>The file name to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>If fn is not found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeb06fd772aad39ee1bc7453cf4b0e094" name="gaeb06fd772aad39ee1bc7453cf4b0e094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb06fd772aad39ee1bc7453cf4b0e094">&#9670;&#160;</a></span>vmufs_file_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_file_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmaple__device__t.html">maple_device_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__system__types.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *&#160;</td>
          <td class="paramname"><em>fat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *&#160;</td>
          <td class="paramname"><em>dirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a pointer to a directory struct and a previously loaded FAT, load the indicated file from the VMU. </p>
<p>An appropriate amount of space must have been allocated previously in the buffer. Assumes the mutex is held.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The VMU to read from. </td></tr>
    <tr><td class="paramname">fat</td><td>The FAT of the VMU. </td></tr>
    <tr><td class="paramname">dirent</td><td>The entry to read. </td></tr>
    <tr><td class="paramname">outbuf</td><td>A buffer to write the data into. You must allocate this yourself with the appropriate amount of space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0 on failure. </dd></dl>

</div>
</div>
<a id="ga543caffb2db3e5edb45ff7e7db82b928" name="ga543caffb2db3e5edb45ff7e7db82b928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga543caffb2db3e5edb45ff7e7db82b928">&#9670;&#160;</a></span>vmufs_file_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_file_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmaple__device__t.html">maple_device_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__root__t.html">vmu_root_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__system__types.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *&#160;</td>
          <td class="paramname"><em>fat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *&#160;</td>
          <td class="paramname"><em>newdirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>filebuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a pointer to a mostly-filled directory struct and a previously loaded directory and FAT, write the indicated file to the VMU. </p>
<p>The named file should not exist in the directory already. The directory and FAT will <em>not</em> be sync'd back to the VMU, this must be done manually. Assumes the mutex is held.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The VMU to write to. </td></tr>
    <tr><td class="paramname">root</td><td>The VMU root block. </td></tr>
    <tr><td class="paramname">fat</td><td>The FAT of the VMU. </td></tr>
    <tr><td class="paramname">dir</td><td>The directory of the VMU. </td></tr>
    <tr><td class="paramname">newdirent</td><td>The new entry to write. </td></tr>
    <tr><td class="paramname">filebuf</td><td>The new file data. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the file in blocks (512-bytes each). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0 on failure. </dd></dl>

</div>
</div>
<a id="gaa5893b3e06b372758f22f4a8be5d7d8e" name="gaa5893b3e06b372758f22f4a8be5d7d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5893b3e06b372758f22f4a8be5d7d8e">&#9670;&#160;</a></span>vmufs_free_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_free_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmaple__device__t.html">maple_device_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of user blocks free for file writing. </p>
<p>You should check this number before attempting to write.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of blocks free for writing. </dd></dl>

</div>
</div>
<a id="gad8c429cb914f6fa53d44a6f3e753182f" name="gad8c429cb914f6fa53d44a6f3e753182f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8c429cb914f6fa53d44a6f3e753182f">&#9670;&#160;</a></span>vmufs_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize vmufs. </p>
<p>Must be called before anything else is useful.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success (no error conditions defined). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga85e3a67dc238f019030b6f444dd3fd34" name="ga85e3a67dc238f019030b6f444dd3fd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85e3a67dc238f019030b6f444dd3fd34">&#9670;&#160;</a></span>vmufs_mutex_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_mutex_lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the vmufs mutex. </p>
<p>This should be done before you attempt any low-level ops.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success (no error conditions defined). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef1e03ad75d45013b6ca6a80a43f04c4" name="gaef1e03ad75d45013b6ca6a80a43f04c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef1e03ad75d45013b6ca6a80a43f04c4">&#9670;&#160;</a></span>vmufs_mutex_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the vmufs mutex. </p>
<p>This should be done once you're done with any low-level ops.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success (no error conditions defined). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab7154724fbfccfc95413050e2ca36591" name="gab7154724fbfccfc95413050e2ca36591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7154724fbfccfc95413050e2ca36591">&#9670;&#160;</a></span>vmufs_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmaple__device__t.html">maple_device_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a file from the VMU. </p>
<p>The output buffer will be allocated for you using <a class="el" href="group__system__allocator.html#ga9c36d0fe3ec4675cbffdc9b52f5fb399" title="Allocate a block of memory.">malloc()</a>, and the size of the file will be returned. On failure, outbuf will not contain a dangling buffer that needs to be freed (no further action required).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The VMU to read from. </td></tr>
    <tr><td class="paramname">fn</td><td>The name of the file to read. </td></tr>
    <tr><td class="paramname">outbuf</td><td>A buffer that will be allocated where the file data will be placed. </td></tr>
    <tr><td class="paramname">outsize</td><td>Storage for the size of the file, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or &lt;0 on failure. </dd></dl>

</div>
</div>
<a id="gaaf2ccb874a60cd6fea109039613a9bae" name="gaaf2ccb874a60cd6fea109039613a9bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf2ccb874a60cd6fea109039613a9bae">&#9670;&#160;</a></span>vmufs_read_dirent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_read_dirent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmaple__device__t.html">maple_device_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> *&#160;</td>
          <td class="paramname"><em>dirent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a file from the VMU, using a pre-read dirent. </p>
<p>This function is faster to use than <a class="el" href="group__vfs__vmu.html#gab7154724fbfccfc95413050e2ca36591" title="Read a file from the VMU.">vmufs_read()</a> if you already have done the lookup, since it won't need to do that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The VMU to read from. </td></tr>
    <tr><td class="paramname">dirent</td><td>The entry to read. </td></tr>
    <tr><td class="paramname">outbuf</td><td>A buffer that will be allocated where the file data will be placed. </td></tr>
    <tr><td class="paramname">outsize</td><td>Storage for the size of the file, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0 on failure. </dd></dl>

</div>
</div>
<a id="gaa4b569ab35ef840096b502eb845ce26f" name="gaa4b569ab35ef840096b502eb845ce26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4b569ab35ef840096b502eb845ce26f">&#9670;&#160;</a></span>vmufs_readdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_readdir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmaple__device__t.html">maple_device_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__dir__t.html">vmu_dir_t</a> **&#160;</td>
          <td class="paramname"><em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the directory from a VMU. </p>
<p>The output buffer will be allocated for you using <a class="el" href="group__system__allocator.html#ga9c36d0fe3ec4675cbffdc9b52f5fb399" title="Allocate a block of memory.">malloc()</a>, and the number of entries will be returned. On failure, outbuf will not contain a dangling buffer that needs to be freed (no further action required).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The VMU to read from. </td></tr>
    <tr><td class="paramname">outbuf</td><td>A buffer that will be allocated where the directory data will be placed. </td></tr>
    <tr><td class="paramname">outcnt</td><td>The number of entries in outbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or &lt;0 on failure. </dd></dl>

</div>
</div>
<a id="ga1ea06e7b8b671558f2a57755f7bfc10c" name="ga1ea06e7b8b671558f2a57755f7bfc10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ea06e7b8b671558f2a57755f7bfc10c">&#9670;&#160;</a></span>vmufs_root_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_root_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmaple__device__t.html">maple_device_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__root__t.html">vmu_root_t</a> *&#160;</td>
          <td class="paramname"><em>root_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a selected VMU's root block. </p>
<p>This function assumes the mutex is held.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The VMU to read from. </td></tr>
    <tr><td class="paramname">root_buf</td><td>A buffer to hold the root block. You must allocate this yourself before calling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>On failure. </td></tr>
    <tr><td class="paramname">0</td><td>On success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaae2f2d1594e0f27ea23df05f4f5f7409" name="gaae2f2d1594e0f27ea23df05f4f5f7409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae2f2d1594e0f27ea23df05f4f5f7409">&#9670;&#160;</a></span>vmufs_root_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_root_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmaple__device__t.html">maple_device_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvmu__root__t.html">vmu_root_t</a> *&#160;</td>
          <td class="paramname"><em>root_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a selected VMU's root block. </p>
<p>This function assumes the mutex is held.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The VMU to write to. </td></tr>
    <tr><td class="paramname">root_buf</td><td>The root block to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>On failure. </td></tr>
    <tr><td class="paramname">0</td><td>On success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga319a6303bfe003dd459fe79ffe4a7738" name="ga319a6303bfe003dd459fe79ffe4a7738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga319a6303bfe003dd459fe79ffe4a7738">&#9670;&#160;</a></span>vmufs_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_shutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown vmufs. </p>
<p>Must be called after everything is finished. </p>

</div>
</div>
<a id="ga9930f10c9f93aafd30c8f769024fec06" name="ga9930f10c9f93aafd30c8f769024fec06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9930f10c9f93aafd30c8f769024fec06">&#9670;&#160;</a></span>vmufs_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vmufs_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmaple__device__t.html">maple_device_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>inbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>insize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a file to the VMU. </p>
<p>If the named file already exists, then the function checks 'flags'. If VMUFS_OVERWRITE is set, then the old file is deleted first before the new one is written (this all happens atomically). On partial failure, some data blocks may have been written, but in general the card should not be damaged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The VMU to write to. </td></tr>
    <tr><td class="paramname">fn</td><td>The filename to write. </td></tr>
    <tr><td class="paramname">inbuf</td><td>The data to write to the file. </td></tr>
    <tr><td class="paramname">insize</td><td>The size of the file in bytes. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags for the write (i.e, VMUFS_OVERWRITE, VMUFS_VMUGAME, VMUFS_NOCOPY). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or &lt;0 for failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
