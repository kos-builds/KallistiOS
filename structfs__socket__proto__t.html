<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KallistiOS: fs_socket_proto_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">KallistiOS<span id="projectnumber">&#160;##version##</span>
   </div>
   <div id="projectbrief">Independent SDK for the Sega Dreamcast</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structfs__socket__proto__t.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle"><div class="title">fs_socket_proto_t Struct Reference<div class="ingroups"><a class="el" href="group__vfs.html">Filesystem</a> &raquo; <a class="el" href="group__vfs__drivers.html">Drivers</a> &raquo; <a class="el" href="group__vfs__sockets.html">Sockets</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Internal sockets protocol handler.  
 <a href="structfs__socket__proto__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="fs__socket_8h_source.html">kos/fs_socket.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf632d902773b2118cbc6e9e32e6dcfd" id="r_acf632d902773b2118cbc6e9e32e6dcfd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#acf632d902773b2118cbc6e9e32e6dcfd">TAILQ_ENTRY</a> (fs_socket_proto) entry</td></tr>
<tr class="memdesc:acf632d902773b2118cbc6e9e32e6dcfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry into the global list of protocols.  <br /></td></tr>
<tr class="separator:acf632d902773b2118cbc6e9e32e6dcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a9d4a04c90c376a04e9cdb6e98e1d780c" id="r_a9d4a04c90c376a04e9cdb6e98e1d780c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#a9d4a04c90c376a04e9cdb6e98e1d780c">domain</a></td></tr>
<tr class="memdesc:a9d4a04c90c376a04e9cdb6e98e1d780c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain of support for this protocol handler.  <br /></td></tr>
<tr class="separator:a9d4a04c90c376a04e9cdb6e98e1d780c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953406ac76959e7a825fb217a52a1f5b" id="r_a953406ac76959e7a825fb217a52a1f5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#a953406ac76959e7a825fb217a52a1f5b">type</a></td></tr>
<tr class="memdesc:a953406ac76959e7a825fb217a52a1f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of support for this protocol handler.  <br /></td></tr>
<tr class="separator:a953406ac76959e7a825fb217a52a1f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45d201cc08373d70809d8636903cae9" id="r_aa45d201cc08373d70809d8636903cae9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#aa45d201cc08373d70809d8636903cae9">protocol</a></td></tr>
<tr class="memdesc:aa45d201cc08373d70809d8636903cae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol of support for this protocol handler.  <br /></td></tr>
<tr class="separator:aa45d201cc08373d70809d8636903cae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a86898f23d85f6eb9b9a61ff12a71e" id="r_ab8a86898f23d85f6eb9b9a61ff12a71e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#ab8a86898f23d85f6eb9b9a61ff12a71e">socket</a> )(<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, int <a class="el" href="structfs__socket__proto__t.html#a9d4a04c90c376a04e9cdb6e98e1d780c">domain</a>, int <a class="el" href="structfs__socket__proto__t.html#a953406ac76959e7a825fb217a52a1f5b">type</a>, int <a class="el" href="structfs__socket__proto__t.html#aa45d201cc08373d70809d8636903cae9">protocol</a>)</td></tr>
<tr class="memdesc:ab8a86898f23d85f6eb9b9a61ff12a71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new socket for the protocol.  <br /></td></tr>
<tr class="separator:ab8a86898f23d85f6eb9b9a61ff12a71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff59b922aa6d6a7d6447807704f93cd" id="r_a5ff59b922aa6d6a7d6447807704f93cd"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#a5ff59b922aa6d6a7d6447807704f93cd">close</a> )(<a class="el" href="structnet__socket__t.html">net_socket_t</a> *hnd)</td></tr>
<tr class="memdesc:a5ff59b922aa6d6a7d6447807704f93cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a socket that was created with the protocol.  <br /></td></tr>
<tr class="separator:a5ff59b922aa6d6a7d6447807704f93cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90911696379ecec4c73ae4350a93977" id="r_ae90911696379ecec4c73ae4350a93977"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#ae90911696379ecec4c73ae4350a93977">accept</a> )(<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, struct <a class="el" href="structsockaddr.html">sockaddr</a> *addr, <a class="el" href="group__networking__sockets.html#ga6e552de056211b018389ac6122675fb0">socklen_t</a> *alen)</td></tr>
<tr class="memdesc:ae90911696379ecec4c73ae4350a93977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a connection on a socket created with the protocol.  <br /></td></tr>
<tr class="separator:ae90911696379ecec4c73ae4350a93977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbc3a6cdfb5e462dd1d8b47572ea340" id="r_a0bbc3a6cdfb5e462dd1d8b47572ea340"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#a0bbc3a6cdfb5e462dd1d8b47572ea340">bind</a> )(<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, const struct <a class="el" href="structsockaddr.html">sockaddr</a> *addr, <a class="el" href="group__networking__sockets.html#ga6e552de056211b018389ac6122675fb0">socklen_t</a> alen)</td></tr>
<tr class="memdesc:a0bbc3a6cdfb5e462dd1d8b47572ea340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a socket created with the protocol to an address.  <br /></td></tr>
<tr class="separator:a0bbc3a6cdfb5e462dd1d8b47572ea340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c1029cc3cc19b22c9586aa3c7cefb6" id="r_a63c1029cc3cc19b22c9586aa3c7cefb6"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#a63c1029cc3cc19b22c9586aa3c7cefb6">connect</a> )(<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, const struct <a class="el" href="structsockaddr.html">sockaddr</a> *addr, <a class="el" href="group__networking__sockets.html#ga6e552de056211b018389ac6122675fb0">socklen_t</a> alen)</td></tr>
<tr class="memdesc:a63c1029cc3cc19b22c9586aa3c7cefb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect a socket created with the protocol to a remote system.  <br /></td></tr>
<tr class="separator:a63c1029cc3cc19b22c9586aa3c7cefb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c761512ff7711fd76fc578f3052aaf6" id="r_a5c761512ff7711fd76fc578f3052aaf6"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#a5c761512ff7711fd76fc578f3052aaf6">listen</a> )(<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, int backlog)</td></tr>
<tr class="memdesc:a5c761512ff7711fd76fc578f3052aaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listen for incoming connections on a socket created with the protocol.  <br /></td></tr>
<tr class="separator:a5c761512ff7711fd76fc578f3052aaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2d895b3d143e6fb801aab6b8c6d091" id="r_a9e2d895b3d143e6fb801aab6b8c6d091"><td class="memItemLeft" align="right" valign="top">ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#a9e2d895b3d143e6fb801aab6b8c6d091">recvfrom</a> )(<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, void *buffer, size_t len, int flags, struct <a class="el" href="structsockaddr.html">sockaddr</a> *addr, <a class="el" href="group__networking__sockets.html#ga6e552de056211b018389ac6122675fb0">socklen_t</a> *alen)</td></tr>
<tr class="memdesc:a9e2d895b3d143e6fb801aab6b8c6d091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data on a socket created with the protocol.  <br /></td></tr>
<tr class="separator:a9e2d895b3d143e6fb801aab6b8c6d091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32acb9e732b24318a0ba3e3ca3fa69ac" id="r_a32acb9e732b24318a0ba3e3ca3fa69ac"><td class="memItemLeft" align="right" valign="top">ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#a32acb9e732b24318a0ba3e3ca3fa69ac">sendto</a> )(<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, const void *msg, size_t len, int flags, const struct <a class="el" href="structsockaddr.html">sockaddr</a> *addr, <a class="el" href="group__networking__sockets.html#ga6e552de056211b018389ac6122675fb0">socklen_t</a> alen)</td></tr>
<tr class="memdesc:a32acb9e732b24318a0ba3e3ca3fa69ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data on a socket created with the protocol.  <br /></td></tr>
<tr class="separator:a32acb9e732b24318a0ba3e3ca3fa69ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e73df79ee8c7a73f6044bedc65e3c76" id="r_a3e73df79ee8c7a73f6044bedc65e3c76"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#a3e73df79ee8c7a73f6044bedc65e3c76">shutdownsock</a> )(<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, int how)</td></tr>
<tr class="memdesc:a3e73df79ee8c7a73f6044bedc65e3c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down a socket created with the protocol.  <br /></td></tr>
<tr class="separator:a3e73df79ee8c7a73f6044bedc65e3c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af788d1f922e3275de70329c3eb3140d7" id="r_af788d1f922e3275de70329c3eb3140d7"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#af788d1f922e3275de70329c3eb3140d7">input</a> )(<a class="el" href="structnetif__t.html">netif_t</a> *src, int <a class="el" href="structfs__socket__proto__t.html#a9d4a04c90c376a04e9cdb6e98e1d780c">domain</a>, const void *hdr, const <a class="el" href="group__system__types.html#gadde6aaee8457bee49c2a92621fe22b79">uint8</a> *data, size_t size)</td></tr>
<tr class="memdesc:af788d1f922e3275de70329c3eb3140d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input a packet into a protocol.  <br /></td></tr>
<tr class="separator:af788d1f922e3275de70329c3eb3140d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c94550ad6d816d0e59a6b61cb2da174" id="r_a1c94550ad6d816d0e59a6b61cb2da174"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#a1c94550ad6d816d0e59a6b61cb2da174">getsockopt</a> )(<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, int level, int option_name, void *option_value, <a class="el" href="group__networking__sockets.html#ga6e552de056211b018389ac6122675fb0">socklen_t</a> *option_len)</td></tr>
<tr class="memdesc:a1c94550ad6d816d0e59a6b61cb2da174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get socket options.  <br /></td></tr>
<tr class="separator:a1c94550ad6d816d0e59a6b61cb2da174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72dd3c4ffa0540ccf66c7c30c5a9d81f" id="r_a72dd3c4ffa0540ccf66c7c30c5a9d81f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#a72dd3c4ffa0540ccf66c7c30c5a9d81f">setsockopt</a> )(<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, int level, int option_name, const void *option_value, <a class="el" href="group__networking__sockets.html#ga6e552de056211b018389ac6122675fb0">socklen_t</a> option_len)</td></tr>
<tr class="memdesc:a72dd3c4ffa0540ccf66c7c30c5a9d81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set socket options.  <br /></td></tr>
<tr class="separator:a72dd3c4ffa0540ccf66c7c30c5a9d81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c41f9dcbcc863c483d1ffe526a584fe" id="r_a1c41f9dcbcc863c483d1ffe526a584fe"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#a1c41f9dcbcc863c483d1ffe526a584fe">getsockname</a> )(<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, struct <a class="el" href="structsockaddr.html">sockaddr</a> *name, <a class="el" href="group__networking__sockets.html#ga6e552de056211b018389ac6122675fb0">socklen_t</a> *name_len)</td></tr>
<tr class="memdesc:a1c41f9dcbcc863c483d1ffe526a584fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get socket name.  <br /></td></tr>
<tr class="separator:a1c41f9dcbcc863c483d1ffe526a584fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a9db3106998f76dc34736a887df85a" id="r_ac7a9db3106998f76dc34736a887df85a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#ac7a9db3106998f76dc34736a887df85a">fcntl</a> )(<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, int cmd, va_list ap)</td></tr>
<tr class="memdesc:ac7a9db3106998f76dc34736a887df85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manipulate file options.  <br /></td></tr>
<tr class="separator:ac7a9db3106998f76dc34736a887df85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7032347cf450de4f8fb380624b67bcba" id="r_a7032347cf450de4f8fb380624b67bcba"><td class="memItemLeft" align="right" valign="top">short(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__socket__proto__t.html#a7032347cf450de4f8fb380624b67bcba">poll</a> )(<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, short events)</td></tr>
<tr class="memdesc:a7032347cf450de4f8fb380624b67bcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll for events.  <br /></td></tr>
<tr class="separator:a7032347cf450de4f8fb380624b67bcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Internal sockets protocol handler. </p>
<p>This structure is a protocol handler used within fs_socket. Each protocol that is supported has one of these registered for it within the kernel. Generally, users will not come in contact with this structure (unless you're planning on writing a protocol handler), and it can generally be ignored.</p>
<p>For a complete list of appropriate errno values to return from any functions that are in here, take a look at the Single Unix Specification (aka, the POSIX spec), specifically the page about <a class="el" href="socket_8h.html" title="Main sockets header.">sys/socket.h</a> (and all the functions that it defines, which is available at <a href="http://www.opengroup.org/onlinepubs/9699919799/basedefs/sys_socket.h.html">http://www.opengroup.org/onlinepubs/9699919799/basedefs/sys_socket.h.html</a> . </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="acf632d902773b2118cbc6e9e32e6dcfd" name="acf632d902773b2118cbc6e9e32e6dcfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf632d902773b2118cbc6e9e32e6dcfd">&#9670;&#160;</a></span>TAILQ_ENTRY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fs_socket_proto_t::TAILQ_ENTRY </td>
          <td>(</td>
          <td class="paramtype">fs_socket_proto&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry into the global list of protocols. </p>
<p>Contrary to what Doxygen might think, this is <b>NOT</b> a function. This should be initialized with the FS_SOCKET_PROTO_ENTRY macro before adding the protocol to the kernel with <a class="el" href="group__vfs__sockets.html#ga6fd5572c54f1300b2ed6ddae855f8629" title="Add a new protocol for use with fs_socket.">fs_socket_proto_add()</a>. </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="ae90911696379ecec4c73ae4350a93977" name="ae90911696379ecec4c73ae4350a93977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90911696379ecec4c73ae4350a93977">&#9670;&#160;</a></span>accept</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fs_socket_proto_t::accept) (<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, struct <a class="el" href="structsockaddr.html">sockaddr</a> *addr, <a class="el" href="group__networking__sockets.html#ga6e552de056211b018389ac6122675fb0">socklen_t</a> *alen)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a connection on a socket created with the protocol. </p>
<p>This function should implement the <a class="el" href="structfs__socket__proto__t.html#ae90911696379ecec4c73ae4350a93977" title="Accept a connection on a socket created with the protocol.">accept()</a> system call for the protocol. The semantics are exactly as expected for that function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to accept a connection on </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the incoming connection </td></tr>
    <tr><td class="paramname">alen</td><td>The length of the address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created socket for the incoming connection or -1 on error (with errno set appropriately) </dd></dl>

</div>
</div>
<a id="a0bbc3a6cdfb5e462dd1d8b47572ea340" name="a0bbc3a6cdfb5e462dd1d8b47572ea340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbc3a6cdfb5e462dd1d8b47572ea340">&#9670;&#160;</a></span>bind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fs_socket_proto_t::bind) (<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, const struct <a class="el" href="structsockaddr.html">sockaddr</a> *addr, <a class="el" href="group__networking__sockets.html#ga6e552de056211b018389ac6122675fb0">socklen_t</a> alen)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a socket created with the protocol to an address. </p>
<p>This function should implement the <a class="el" href="structfs__socket__proto__t.html#a0bbc3a6cdfb5e462dd1d8b47572ea340" title="Bind a socket created with the protocol to an address.">bind()</a> system call for the protocol. The semantics are exactly as expected for that function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to bind to the address </td></tr>
    <tr><td class="paramname">addr</td><td>The address to bind to </td></tr>
    <tr><td class="paramname">alen</td><td>The length of the address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>On error (set errno appropriately) </td></tr>
    <tr><td class="paramname">0</td><td>On success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ff59b922aa6d6a7d6447807704f93cd" name="a5ff59b922aa6d6a7d6447807704f93cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff59b922aa6d6a7d6447807704f93cd">&#9670;&#160;</a></span>close</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fs_socket_proto_t::close) (<a class="el" href="structnet__socket__t.html">net_socket_t</a> *hnd)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a socket that was created with the protocol. </p>
<p>This function must do any work required to close a socket and destroy it. This function will be called when a socket requests to be closed with the close system call. There are no errors defined for this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to close </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63c1029cc3cc19b22c9586aa3c7cefb6" name="a63c1029cc3cc19b22c9586aa3c7cefb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c1029cc3cc19b22c9586aa3c7cefb6">&#9670;&#160;</a></span>connect</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fs_socket_proto_t::connect) (<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, const struct <a class="el" href="structsockaddr.html">sockaddr</a> *addr, <a class="el" href="group__networking__sockets.html#ga6e552de056211b018389ac6122675fb0">socklen_t</a> alen)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect a socket created with the protocol to a remote system. </p>
<p>This function should implement the <a class="el" href="structfs__socket__proto__t.html#a63c1029cc3cc19b22c9586aa3c7cefb6" title="Connect a socket created with the protocol to a remote system.">connect()</a> system call for the protocol. The semantics are exactly as expected for that function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to connect with </td></tr>
    <tr><td class="paramname">addr</td><td>The address to connect to </td></tr>
    <tr><td class="paramname">alen</td><td>The length of the address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>On error (with errno set appropriately) </td></tr>
    <tr><td class="paramname">0</td><td>On success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d4a04c90c376a04e9cdb6e98e1d780c" name="a9d4a04c90c376a04e9cdb6e98e1d780c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4a04c90c376a04e9cdb6e98e1d780c">&#9670;&#160;</a></span>domain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fs_socket_proto_t::domain</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Domain of support for this protocol handler. </p>
<p>This field determines which sockets domain this protocol handler actually supports. This corresponds with the domain argument of the <a class="el" href="structfs__socket__proto__t.html#ab8a86898f23d85f6eb9b9a61ff12a71e" title="Create a new socket for the protocol.">socket()</a> function. </p>

</div>
</div>
<a id="ac7a9db3106998f76dc34736a887df85a" name="ac7a9db3106998f76dc34736a887df85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a9db3106998f76dc34736a887df85a">&#9670;&#160;</a></span>fcntl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fs_socket_proto_t::fcntl) (<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, int cmd, va_list ap)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manipulate file options. </p>
<p>This function should implement the <a class="el" href="structfs__socket__proto__t.html#ac7a9db3106998f76dc34736a887df85a" title="Manipulate file options.">fcntl()</a> system call for the given protocol. The semantics are exactly as defined for that function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to manipulate. </td></tr>
    <tr><td class="paramname">cmd</td><td>The fcntl command to run. </td></tr>
    <tr><td class="paramname">ap</td><td>Arguments to the command. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>On error (generally, set errno appropriately). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c41f9dcbcc863c483d1ffe526a584fe" name="a1c41f9dcbcc863c483d1ffe526a584fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c41f9dcbcc863c483d1ffe526a584fe">&#9670;&#160;</a></span>getsockname</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fs_socket_proto_t::getsockname) (<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, struct <a class="el" href="structsockaddr.html">sockaddr</a> *name, <a class="el" href="group__networking__sockets.html#ga6e552de056211b018389ac6122675fb0">socklen_t</a> *name_len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get socket name. </p>
<p>This function should implement the <a class="el" href="structfs__socket__proto__t.html#a1c41f9dcbcc863c483d1ffe526a584fe" title="Get socket name.">getsockname()</a> system call for the given protocol. The semantics are exactly as defined for that function.</p>
<p>Currently all options (regardless of level) are passed onto the protocol handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to get the name of. </td></tr>
    <tr><td class="paramname">name</td><td>Pointer to a sockaddr structure which will hold the resulting address information. </td></tr>
    <tr><td class="paramname">name_len</td><td>The amount of space pointed to by name, in bytes. On return, this is set to the actual size of the returned address information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>On error (set errno appropriately). </td></tr>
    <tr><td class="paramname">0</td><td>On success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c94550ad6d816d0e59a6b61cb2da174" name="a1c94550ad6d816d0e59a6b61cb2da174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c94550ad6d816d0e59a6b61cb2da174">&#9670;&#160;</a></span>getsockopt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fs_socket_proto_t::getsockopt) (<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, int level, int option_name, void *option_value, <a class="el" href="group__networking__sockets.html#ga6e552de056211b018389ac6122675fb0">socklen_t</a> *option_len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get socket options. </p>
<p>This function should implement the <a class="el" href="structfs__socket__proto__t.html#a1c94550ad6d816d0e59a6b61cb2da174" title="Get socket options.">getsockopt()</a> system call for the given protocol. The semantics are exactly as defined for that function.</p>
<p>Currently all options (regardless of level) are passed onto the protocol handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to get options for. </td></tr>
    <tr><td class="paramname">level</td><td>The protocol level to get options at. </td></tr>
    <tr><td class="paramname">option_name</td><td>The option to look up. </td></tr>
    <tr><td class="paramname">option_value</td><td>Storage for the value of the option. </td></tr>
    <tr><td class="paramname">option_len</td><td>The length of option_value on call, and the real option length (if less than the original value) on return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>On error (set errno appropriately). </td></tr>
    <tr><td class="paramname">0</td><td>On success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af788d1f922e3275de70329c3eb3140d7" name="af788d1f922e3275de70329c3eb3140d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af788d1f922e3275de70329c3eb3140d7">&#9670;&#160;</a></span>input</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fs_socket_proto_t::input) (<a class="el" href="structnetif__t.html">netif_t</a> *src, int <a class="el" href="structfs__socket__proto__t.html#a9d4a04c90c376a04e9cdb6e98e1d780c">domain</a>, const void *hdr, const <a class="el" href="group__system__types.html#gadde6aaee8457bee49c2a92621fe22b79">uint8</a> *data, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Input a packet into a protocol. </p>
<p>This function should read in the packet specified by the arguments and sort out what exactly to do with it. This usually involves checking if there is an open socket with the source address and adding it to a packet queue if there is.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The interface the packet was input on </td></tr>
    <tr><td class="paramname">domain</td><td>The low-level protocol used (AF_INET or AF_INET6) </td></tr>
    <tr><td class="paramname">hdr</td><td>The low-level protocol header </td></tr>
    <tr><td class="paramname">data</td><td>The packet itself, including any protocol headers, but not any from lower-level protocols </td></tr>
    <tr><td class="paramname">size</td><td>The size of the packet, not including any lower- level protocol headers </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>On error (the packet is discarded) </td></tr>
    <tr><td class="paramname">0</td><td>On success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c761512ff7711fd76fc578f3052aaf6" name="a5c761512ff7711fd76fc578f3052aaf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c761512ff7711fd76fc578f3052aaf6">&#9670;&#160;</a></span>listen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fs_socket_proto_t::listen) (<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, int backlog)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Listen for incoming connections on a socket created with the protocol. </p>
<p>This function should implement the <a class="el" href="structfs__socket__proto__t.html#a5c761512ff7711fd76fc578f3052aaf6" title="Listen for incoming connections on a socket created with the protocol.">listen()</a> system call for the protocol. The semantics are exactly as expected for that function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to listen on </td></tr>
    <tr><td class="paramname">backlog</td><td>The number of connections to queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>On error (with errno set appropriately) </td></tr>
    <tr><td class="paramname">0</td><td>On success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7032347cf450de4f8fb380624b67bcba" name="a7032347cf450de4f8fb380624b67bcba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7032347cf450de4f8fb380624b67bcba">&#9670;&#160;</a></span>poll</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short(* fs_socket_proto_t::poll) (<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, short events)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll for events. </p>
<p>This function should check the given socket for any events that may have already occurred that are specified. This is used to back the <a class="el" href="structfs__socket__proto__t.html#a7032347cf450de4f8fb380624b67bcba" title="Poll for events.">poll()</a> system call. This function should not block to wait for any events. This function may be called in an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to poll. </td></tr>
    <tr><td class="paramname">events</td><td>The events to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">A</td><td>mask of any of the events specified that are currently true in the socket. 0 if none are true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa45d201cc08373d70809d8636903cae9" name="aa45d201cc08373d70809d8636903cae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45d201cc08373d70809d8636903cae9">&#9670;&#160;</a></span>protocol</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fs_socket_proto_t::protocol</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Protocol of support for this protocol handler. </p>
<p>This field determines the protocol that this protocol handler actually pays attention to. This corresponds with the protocol argument of the <a class="el" href="structfs__socket__proto__t.html#ab8a86898f23d85f6eb9b9a61ff12a71e" title="Create a new socket for the protocol.">socket()</a> function. </p>

</div>
</div>
<a id="a9e2d895b3d143e6fb801aab6b8c6d091" name="a9e2d895b3d143e6fb801aab6b8c6d091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2d895b3d143e6fb801aab6b8c6d091">&#9670;&#160;</a></span>recvfrom</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t(* fs_socket_proto_t::recvfrom) (<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, void *buffer, size_t len, int flags, struct <a class="el" href="structsockaddr.html">sockaddr</a> *addr, <a class="el" href="group__networking__sockets.html#ga6e552de056211b018389ac6122675fb0">socklen_t</a> *alen)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive data on a socket created with the protocol. </p>
<p>This function should implement the <a class="el" href="structfs__socket__proto__t.html#a9e2d895b3d143e6fb801aab6b8c6d091" title="Receive data on a socket created with the protocol.">recvfrom()</a> system call for the protocol. The semantics are exactly as expected for that function. Also, this function should implement the <a class="el" href="group__networking__sockets.html#ga0c63bfe1c5681c844eb704d739e63c00" title="Receive a message on a connected socket.">recv()</a> system call, which will call this function with NULL for addr and alen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to receive data on </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to save data in </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to the function </td></tr>
    <tr><td class="paramname">addr</td><td>Space to store the address that data came from (NULL if this was called by <a class="el" href="group__networking__sockets.html#ga0c63bfe1c5681c844eb704d739e63c00" title="Receive a message on a connected socket.">recv()</a>) </td></tr>
    <tr><td class="paramname">alen</td><td>Space to store the length of the address (NULL if this was called by <a class="el" href="group__networking__sockets.html#ga0c63bfe1c5681c844eb704d739e63c00" title="Receive a message on a connected socket.">recv()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>On error (set errno appropriately) </td></tr>
    <tr><td class="paramname">0</td><td>No outstanding data and the peer has disconnected cleanly </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes received (may be less than len) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32acb9e732b24318a0ba3e3ca3fa69ac" name="a32acb9e732b24318a0ba3e3ca3fa69ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32acb9e732b24318a0ba3e3ca3fa69ac">&#9670;&#160;</a></span>sendto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t(* fs_socket_proto_t::sendto) (<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, const void *msg, size_t len, int flags, const struct <a class="el" href="structsockaddr.html">sockaddr</a> *addr, <a class="el" href="group__networking__sockets.html#ga6e552de056211b018389ac6122675fb0">socklen_t</a> alen)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data on a socket created with the protocol. </p>
<p>This function should implement the <a class="el" href="structfs__socket__proto__t.html#a32acb9e732b24318a0ba3e3ca3fa69ac" title="Send data on a socket created with the protocol.">sendto()</a> system call for the protocol. The semantics are exactly as expected for that function. Also, this function should implement the <a class="el" href="group__networking__sockets.html#gab89c81591dff4f7a4fcb058cb4edc891" title="Send a message on a connected socket.">send()</a> system call, which will call this function with NULL for addr and 0 for alen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to send data on </td></tr>
    <tr><td class="paramname">msg</td><td>The data to send </td></tr>
    <tr><td class="paramname">len</td><td>The length of data to send </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to the function </td></tr>
    <tr><td class="paramname">addr</td><td>The address to send data to (NULL if this was called by <a class="el" href="group__networking__sockets.html#gab89c81591dff4f7a4fcb058cb4edc891" title="Send a message on a connected socket.">send()</a>) </td></tr>
    <tr><td class="paramname">alen</td><td>The length of the address (0 if this was called by <a class="el" href="group__networking__sockets.html#gab89c81591dff4f7a4fcb058cb4edc891" title="Send a message on a connected socket.">send()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>On error (set errno appropriately) </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes actually sent (may be less than len) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72dd3c4ffa0540ccf66c7c30c5a9d81f" name="a72dd3c4ffa0540ccf66c7c30c5a9d81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72dd3c4ffa0540ccf66c7c30c5a9d81f">&#9670;&#160;</a></span>setsockopt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fs_socket_proto_t::setsockopt) (<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, int level, int option_name, const void *option_value, <a class="el" href="group__networking__sockets.html#ga6e552de056211b018389ac6122675fb0">socklen_t</a> option_len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set socket options. </p>
<p>This function should implement the <a class="el" href="structfs__socket__proto__t.html#a72dd3c4ffa0540ccf66c7c30c5a9d81f" title="Set socket options.">setsockopt()</a> system call for the given protocol. The semantics are exactly as defined for that function.</p>
<p>Currently all options (regardless of level) are passed onto the protocol handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to set options for. </td></tr>
    <tr><td class="paramname">level</td><td>The protocol level to set options at. </td></tr>
    <tr><td class="paramname">option_name</td><td>The option to set. </td></tr>
    <tr><td class="paramname">option_value</td><td>The value to set for the option. </td></tr>
    <tr><td class="paramname">option_len</td><td>The length of the option_value value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>On error (set errno appropriately). </td></tr>
    <tr><td class="paramname">0</td><td>On success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e73df79ee8c7a73f6044bedc65e3c76" name="a3e73df79ee8c7a73f6044bedc65e3c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e73df79ee8c7a73f6044bedc65e3c76">&#9670;&#160;</a></span>shutdownsock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fs_socket_proto_t::shutdownsock) (<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, int how)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shut down a socket created with the protocol. </p>
<p>This function should implement the <a class="el" href="group__networking__sockets.html#ga03016e1f876d02247e91a9aca1ff4f01" title="Shutdown socket send and receive operations.">shutdown()</a> system call for the protocol. The semantics are exactly as expected for that function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to shut down </td></tr>
    <tr><td class="paramname">how</td><td>What should be shut down on the socket </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>On error (set errno appropriately) </td></tr>
    <tr><td class="paramname">0</td><td>On success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8a86898f23d85f6eb9b9a61ff12a71e" name="ab8a86898f23d85f6eb9b9a61ff12a71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a86898f23d85f6eb9b9a61ff12a71e">&#9670;&#160;</a></span>socket</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fs_socket_proto_t::socket) (<a class="el" href="structnet__socket__t.html">net_socket_t</a> *s, int <a class="el" href="structfs__socket__proto__t.html#a9d4a04c90c376a04e9cdb6e98e1d780c">domain</a>, int <a class="el" href="structfs__socket__proto__t.html#a953406ac76959e7a825fb217a52a1f5b">type</a>, int <a class="el" href="structfs__socket__proto__t.html#aa45d201cc08373d70809d8636903cae9">protocol</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new socket for the protocol. </p>
<p>This function must create a new socket, initializing any data that the protocol might need for the socket, based on the parameters passed in. The socket passed in is already initialized prior to the handler being called, and will be cleaned up by fs_socket if an error is returned from the handler (a return value of -1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket structure to initialize </td></tr>
    <tr><td class="paramname">domain</td><td>Domain of the socket </td></tr>
    <tr><td class="paramname">type</td><td>Type of the socket </td></tr>
    <tr><td class="paramname">protocol</td><td>Protocol of the socket </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>On error (errno should be set appropriately) </td></tr>
    <tr><td class="paramname">0</td><td>On success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a953406ac76959e7a825fb217a52a1f5b" name="a953406ac76959e7a825fb217a52a1f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953406ac76959e7a825fb217a52a1f5b">&#9670;&#160;</a></span>type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fs_socket_proto_t::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of support for this protocol handler. </p>
<p>This field determines which types of sockets that this protocol handler pays attention to. This corresponds with the type argument of the <a class="el" href="structfs__socket__proto__t.html#ab8a86898f23d85f6eb9b9a61ff12a71e" title="Create a new socket for the protocol.">socket()</a> function. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/kos/<a class="el" href="fs__socket_8h_source.html">fs_socket.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structfs__socket__proto__t.html">fs_socket_proto_t</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
